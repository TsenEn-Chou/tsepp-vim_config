Vim: Warning: Output is not to a terminal
chdir(/usr/local/share/vim)[?25l[J
fchdir() to previous dir[J
could not source "$VIM/vimrc"[J
chdir(/usr/local/share/vim/vim90)[J
fchdir() to previous dir[J
could not source "$VIMRUNTIME/macmap.vim"[J
chdir(/Users/tsen)[J
fchdir() to previous dir[J
could not source "$HOME/.vimrc"[J
chdir(/Users/tsen/.vim)[J
fchdir() to previous dir[J
sourcing "~/.vim/vimrc"[J
line 1: filetype off                  " required[J

Searching for "ftoff.vim" in "/Users/tsen/.vim,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after"[J
Searching for "/Users/tsen/.vim/ftoff.vim"[J
Searching for "/usr/local/share/vim/vimfiles/ftoff.vim"[J
Searching for "/usr/local/share/vim/vim90/ftoff.vim"[J
chdir(/usr/local/share/vim/vim90)[J
fchdir() to previous dir[J
line 1: sourcing "/usr/local/share/vim/vim90/ftoff.vim"[J
line 1: " Vim support file to switch off detection of file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last change:^I2001 Jun 11[J

line 5: [J

line 6: if exists("did_load_filetypes")[J

line 7:   unlet did_load_filetypes[J

line 8: endif[J

line 9: [J

line 10: " Remove all autocommands in the filetypedetect group[J

line 11: silent! au! filetypedetect *[J

finished sourcing /usr/local/share/vim/vim90/ftoff.vim[J
continuing in /Users/tsen/.vim/vimrc[J
Searching for "/usr/local/share/vim/vimfiles/after/ftoff.vim"[J
Searching for "/Users/tsen/.vim/after/ftoff.vim"[J
line 2: [J

line 3: " set the runtime path to include Vundle and initialize[J

line 4: set rtp+=~/.vim/bundle/Vundle.vim[J

line 5: call vundle#begin()[J

Searching for "autoload/vundle.vim" in "/Users/tsen/.vim,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim"[J
Searching for "/Users/tsen/.vim/autoload/vundle.vim"[J
Searching for "/usr/local/share/vim/vimfiles/autoload/vundle.vim"[J
Searching for "/usr/local/share/vim/vim90/autoload/vundle.vim"[J
Searching for "/usr/local/share/vim/vimfiles/after/autoload/vundle.vim"[J
Searching for "/Users/tsen/.vim/after/autoload/vundle.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/autoload/vundle.vim"[J
chdir(/Users/tsen/.vim/bundle/Vundle.vim/autoload)[J
fchdir() to previous dir[J
line 5: sourcing "/Users/tsen/.vim/bundle/Vundle.vim/autoload/vundle.vim"[J
line 1: " Vundle        is a shortcut for Vim Bundle and Is a simple plugin manager for Vim[J

line 2: " Author:       gmarik[J

line 3: " HomePage:     http://github.com/VundleVim/Vundle.vim[J

line 4: " Readme:       http://github.com/VundleVim/Vundle.vim/blob/master/README.md[J

line 5: " Version:      0.10.2[J

line 6: [J

line 7: " Plugin Commands[J

line 8: com! -nargs=+  -bar   Plugin call vundle#config#bundle(<args>)[J

line 10: [J

line 11: com! -nargs=* -bang -complete=custom,vundle#scripts#complete PluginInstall call vundle#installer#new('!' == '<bang>', <f-args>)[J

line 13: [J

line 14: com! -nargs=? -bang -complete=custom,vundle#scripts#complete PluginSearch call vundle#scripts#all('!' == '<bang>', <q-args>)[J

line 16: [J

line 17: com! -nargs=0 -bang PluginList call vundle#installer#list('!' == '<bang>')[J

line 19: [J

line 20: com! -nargs=? -bang   PluginClean call vundle#installer#clean('!' == '<bang>')[J

line 22: [J

line 23: com! -nargs=0         PluginDocs call vundle#installer#helptags(g:vundle#bundles)[J

line 25: [J

line 26: " Aliases[J

line 27: com! -nargs=* -complete=custom,vundle#scripts#complete PluginUpdate PluginInstall! <args>[J

line 28: [J

line 29: " Vundle Aliases[J

line 30: com! -nargs=? -bang -complete=custom,vundle#scripts#complete VundleInstall PluginInstall<bang> <args>[J

line 31: com! -nargs=? -bang -complete=custom,vundle#scripts#complete VundleSearch  PluginSearch<bang> <args>[J

line 32: com! -nargs=? -bang                                          VundleClean   PluginClean<bang>[J

line 33: com! -nargs=0                                                VundleDocs    PluginDocs[J

line 34: com!                                                         VundleUpdate  PluginInstall![J

line 35: com! -nargs=*       -complete=custom,vundle#scripts#complete VundleUpdate  PluginInstall! <args>[J

line 36: [J

line 37: " Deprecated Commands[J

line 38: com! -nargs=+                                                Bundle        call vundle#config#bundle(<args>)[J

line 39: com! -nargs=? -bang -complete=custom,vundle#scripts#complete BundleInstall PluginInstall<bang> <args>[J

line 40: com! -nargs=? -bang -complete=custom,vundle#scripts#complete BundleSearch  PluginSearch<bang> <args>[J

line 41: com! -nargs=0 -bang                                          BundleList    PluginList<bang>[J

line 42: com! -nargs=? -bang                                          BundleClean   PluginClean<bang>[J

line 43: com! -nargs=0                                                BundleDocs    PluginDocs[J

line 44: com!                                                         BundleUpdate  PluginInstall![J

line 45: [J

line 46: " Set up the signs used in the installer window. (See :help signs)[J

line 47: if (has('signs'))[J

line 48:   sign define Vu_error    text=!  texthl=Error[J

line 49:   sign define Vu_active   text=>  texthl=Comment[J

line 50:   sign define Vu_todate   text=.  texthl=Comment[J

line 51:   sign define Vu_new      text=+  texthl=Comment[J

line 52:   sign define Vu_updated  text=*  texthl=Comment[J

line 53:   sign define Vu_deleted  text=-  texthl=Comment[J

line 54:   sign define Vu_helptags text=*  texthl=Comment[J

line 55:   sign define Vu_pinned   text==  texthl=Comment[J

line 56: endif[J

line 57: [J

line 58: " Set up Vundle.  This function has to be called from the users vimrc file.[J

line 59: " This will force Vim to source this file as a side effect which wil define[J

line 60: " the :Plugin command.  After calling this function the user can use the[J

line 61: " :Plugin command in the vimrc.  It is not possible to do this automatically[J

line 62: " because when loading the vimrc file no plugins where loaded yet.[J

line 63: func! vundle#rc(...) abort[J

line 69: [J

line 70: " Alternative to vundle#rc, offers speed up by modifying rtp only when end()[J

line 71: " called later.[J

line 72: func! vundle#begin(...) abort[J

line 76: [J

line 77: " Finishes putting plugins on the rtp.[J

line 78: func! vundle#end(...) abort[J

line 82: [J

line 83: " Initialize some global variables used by Vundle.[J

line 84: let vundle#bundle_dir = expand('$HOME/.vim/bundle', 1)[J

line 85: let vundle#bundles = [][J

line 86: let vundle#lazy_load = 0[J

line 87: let vundle#log = [][J

line 88: let vundle#updated_bundles = [][J

line 89: [J

line 90: " vim: set expandtab sts=2 ts=2 sw=2 tw=78 norl:[J

finished sourcing /Users/tsen/.vim/bundle/Vundle.vim/autoload/vundle.vim[J
continuing in /Users/tsen/.vim/vimrc[J
calling vundle#begin[J()

line 1:   let g:vundle#lazy_load = 1[J

line 2:   call call('vundle#rc', a:000)[J

calling vundle#rc[J()

line 1:   if a:0 > 0[J

line 2:     let g:vundle#bundle_dir = expand(a:1, 1)[J

line 3:   endif[J

line 4:   call vundle#config#init()[J

Searching for "autoload/vundle/config.vim" in "/Users/tsen/.vim,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim"[J
Searching for "/Users/tsen/.vim/autoload/vundle/config.vim"[J
Searching for "/usr/local/share/vim/vimfiles/autoload/vundle/config.vim"[J
Searching for "/usr/local/share/vim/vim90/autoload/vundle/config.vim"[J
Searching for "/usr/local/share/vim/vimfiles/after/autoload/vundle/config.vim"[J
Searching for "/Users/tsen/.vim/after/autoload/vundle/config.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/autoload/vundle/config.vim"[J
chdir(/Users/tsen/.vim/bundle/Vundle.vim/autoload/vundle)[J
fchdir() to previous dir[J
line 4: sourcing "/Users/tsen/.vim/bundle/Vundle.vim/autoload/vundle/config.vim"[J
line 1: " ---------------------------------------------------------------------------[J

line 2: " Add a plugin to the runtimepath.[J

line 3: "[J

line 4: " arg    -- a string specifying the plugin[J

line 5: " ...    -- a dictionary of options for the plugin[J

line 6: " return -- the return value from vundle#config#init_bundle()[J

line 7: " ---------------------------------------------------------------------------[J

line 8: func! vundle#config#bundle(arg, ...)[J

line 23: [J

line 24: [J

line 25: " ---------------------------------------------------------------------------[J

line 26: "  When lazy bundle load is used (begin/end functions), add all configured[J

line 27: "  bundles to runtimepath and reorder appropriately.[J

line 28: " ---------------------------------------------------------------------------[J

line 29: func! vundle#config#activate_bundles()[J

line 33: [J

line 34: [J

line 35: " ---------------------------------------------------------------------------[J

line 36: " Initialize Vundle.[J

line 37: "[J

line 38: " Start a new bundles list and make sure the runtimepath does not contain[J

line 39: " directories from a previous call. In theory, this should only be called[J

line 40: " once.[J

line 41: " ---------------------------------------------------------------------------[J

line 42: func! vundle#config#init()[J

line 48: [J

line 49: [J

line 50: " ---------------------------------------------------------------------------[J

line 51: " Add a list of bundles to the runtimepath and source them.[J

line 52: "[J

line 53: " bundles -- a list of bundle objects[J

line 54: " ---------------------------------------------------------------------------[J

line 55: func! vundle#config#require(bundles) abort[J

line 66: [J

line 67: [J

line 68: " ---------------------------------------------------------------------------[J

line 69: " Create a bundle object from a bundle specification.[J

line 70: "[J

line 71: " name   -- the bundle specification as a string[J

line 72: " opts   -- the options dictionary from then bundle definition[J

line 73: " return -- an initialized bundle object[J

line 74: " ---------------------------------------------------------------------------[J

line 75: func! vundle#config#init_bundle(name, opts)[J

line 84: [J

line 85: [J

line 86: " ---------------------------------------------------------------------------[J

line 87: " Check if the current bundle name has already been used in this running[J

line 88: " instance and show an error to that effect.[J

line 89: "[J

line 90: " bundle -- a bundle object whose name is to be checked[J

line 91: " return -- 0 if the bundle's name has been seen before, 1 otherwise[J

line 92: " ---------------------------------------------------------------------------[J

line 93: funct! s:check_bundle_name(bundle)[J

line 107: [J

line 108: [J

line 109: " ---------------------------------------------------------------------------[J

line 110: " Parse the options which can be supplied with the bundle specification.[J

line 111: " Corresponding documentation: vundle-plugins-configure[J

line 112: "[J

line 113: " opts   -- a dictionary with the user supplied options for the bundle[J

line 114: " return -- a dictionary with the user supplied options for the bundle, this[J

line 115: "           will be merged with a s:bundle object into one dictionary.[J

line 116: " ---------------------------------------------------------------------------[J

line 117: func! s:parse_options(opts)[J

line 127: [J

line 128: [J

line 129: " ---------------------------------------------------------------------------[J

line 130: " Parse the plugin specification.  Corresponding documentation:[J

line 131: " vundle-plugins-uris[J

line 132: "[J

line 133: " arg    -- the string supplied to identify the plugin[J

line 134: " return -- a dictionary with the folder name (key 'name') and the uri (key[J

line 135: "           'uri') for cloning the plugin  and the original argument (key[J

line 136: "           'name_spec')[J

line 137: " ---------------------------------------------------------------------------[J

line 138: func! s:parse_name(arg)[J

line 160: [J

line 161: [J

line 162: " ---------------------------------------------------------------------------[J

line 163: "  Modify the runtimepath, after all bundles have been added, so that the[J

line 164: "  directories that were in the default runtimepath appear first in the list[J

line 165: "  (with their 'after' directories last).[J

line 166: " ---------------------------------------------------------------------------[J

line 167: func! s:rtp_add_defaults()[J

line 179: [J

line 180: [J

line 181: " ---------------------------------------------------------------------------[J

line 182: " Remove all paths for the plugins which are managed by Vundle from the[J

line 183: " runtimepath.[J

line 184: " ---------------------------------------------------------------------------[J

line 185: func! s:rtp_rm_a()[J

line 192: [J

line 193: [J

line 194: " ---------------------------------------------------------------------------[J

line 195: " Add all paths for the plugins which are managed by Vundle to the[J

line 196: " runtimepath.[J

line 197: " ---------------------------------------------------------------------------[J

line 198: func! s:rtp_add_a()[J

line 205: [J

line 206: [J

line 207: " ---------------------------------------------------------------------------[J

line 208: " Remove a directory and the corresponding 'after' directory from runtimepath.[J

line 209: "[J

line 210: " dir    -- the directory name to be removed as a string.  The corresponding[J

line 211: "           'after' directory will also be removed.[J

line 212: " ---------------------------------------------------------------------------[J

line 213: func! s:rtp_rm(dir) abort[J

line 217: [J

line 218: [J

line 219: " ---------------------------------------------------------------------------[J

line 220: " Add a directory and the corresponding 'after' directory to runtimepath.[J

line 221: "[J

line 222: " dir    -- the directory name to be added as a string.  The corresponding[J

line 223: "           'after' directory will also be added.[J

line 224: " ---------------------------------------------------------------------------[J

line 225: func! s:rtp_add(dir) abort[J

line 229: [J

line 230: [J

line 231: " ---------------------------------------------------------------------------[J

line 232: " Expand and simplify a path.[J

line 233: "[J

line 234: " path   -- the path to expand as a string[J

line 235: " return -- the expanded and simplified path[J

line 236: " ---------------------------------------------------------------------------[J

line 237: func! s:expand_path(path) abort[J

line 240: [J

line 241: [J

line 242: " ---------------------------------------------------------------------------[J

line 243: " Find the actual path inside a bundle directory to be added to the[J

line 244: " runtimepath.  It might be provided by the user with the 'rtp' option.[J

line 245: " Corresponding documentation: vundle-plugins-configure[J

line 246: "[J

line 247: " opts   -- a bundle dict[J

line 248: " return -- expanded path to the corresponding plugin directory[J

line 249: " ---------------------------------------------------------------------------[J

line 250: func! s:rtpath(opts)[J

line 253: [J

line 254: [J

line 255: " ---------------------------------------------------------------------------[J

line 256: " a bundle 'object'[J

line 257: " ---------------------------------------------------------------------------[J

line 258: let s:bundle = {}[J

line 259: [J

line 260: [J

line 261: " ---------------------------------------------------------------------------[J

line 262: " Return the absolute path to the directory inside the bundle directory[J

line 263: " (prefix) where thr bundle will be cloned.[J

line 264: "[J

line 265: " return -- the target location to clone this bundle to[J

line 266: " ---------------------------------------------------------------------------[J

line 267: func! s:bundle.path()[J

line 270: [J

line 271: [J

line 272: " ---------------------------------------------------------------------------[J

line 273: "  Determine if the bundle has the pinned attribute set in the config[J

line 274: "[J

line 275: "  return -- 1 if the bundle is pinned, 0 otherwise[J

line 276: " ---------------------------------------------------------------------------[J

line 277: func! s:bundle.is_pinned()[J

line 280: [J

line 281: " vim: set expandtab sts=2 ts=2 sw=2 tw=78 norl:[J

finished sourcing /Users/tsen/.vim/bundle/Vundle.vim/autoload/vundle/config.vim[J
continuing in vundle#rc[J
calling vundle#config#init[J()

line 1:   if !exists('g:vundle#bundles') | let g:vundle#bundles = [] | endif[J

line 1:  let g:vundle#bundles = [] | endif[J

line 1:  endif[J

line 2:   call s:rtp_rm_a()[J

calling <SNR>4_rtp_rm_a[J()

line 1:   let paths = map(copy(g:vundle#bundles), 'v:val.rtpath')[J

line 2:   let prepends = join(paths, ',')[J

line 3:   let appends = join(paths, '/after,').'/after'[J

line 4:   exec 'set rtp-='.fnameescape(prepends)[J

line 4: set rtp-=[J

line 5:   exec 'set rtp-='.fnameescape(appends)[J

line 5: set rtp-=/after[J

<SNR>4_rtp_rm_a returning #0[J

continuing in vundle#config#init[J

line 3:   let g:vundle#bundles = [][J

line 4:   let s:bundle_names = {}[J

vundle#config#init returning #0[J

continuing in vundle#rc[J

vundle#rc returning #0[J

continuing in vundle#begin[J

vundle#begin returning #0[J

continuing in /Users/tsen/.vim/vimrc[J

line 6: " alternatively, pass a path where Vundle should install plugins[J

line 7: "call vundle#begin('~/some/path/here')[J

line 8: [J

line 9: " let Vundle manage Vundle, required[J

line 10: Plugin 'VundleVim/Vundle.vim'[J

line 10: call vundle#config#bundle('VundleVim/Vundle.vim')[J

calling vundle#config#bundle[J('VundleVim/Vundle.vim')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)[J

calling vundle#config#init_bundle[J('VundleVim/Vundle.vim', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')[J

line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"[J

line 3:   endif[J

line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')[J

calling <SNR>4_parse_options[J([])

line 1:   " TODO: improve this[J

line 2:   if len(a:opts) != 1 | return {} | endif[J

line 2:  return {} | endif[J

<SNR>4_parse_options returning {}[J

continuing in vundle#config#init_bundle[J

calling <SNR>4_parse_name[J('VundleVim/Vundle.vim')

line 1:   let arg = a:arg[J

line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'[J

line 3: [J

line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'[J

line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1][J

line 7:     if uri !~? '\.git$'[J

line 8:       let uri .= '.git'[J

line 9:     endif[J

line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')[J

line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'[J

line 14:     let uri = arg[J

line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1][J

line 16:   else[J

line 17:     let name = arg[J

line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'[J

line 19:   endif[J

line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }[J

<SNR>4_parse_name returning {'uri': 'https://github.com/VundleVim/...', 'name_spec': 'VundleVim/Vundle.vim'}[J

continuing in vundle#config#init_bundle[J

line 5:   let b = extend(opts, copy(s:bundle))[J

line 6:   let b.rtpath = s:rtpath(opts)[J

calling <SNR>4_rtpath[J({'uri': 'https://github.com/VundleVim/...Vim/Vundle.vim', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()[J

calling 1[J()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name[J

calling <SNR>4_expand_path[J('/Users/tsen/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))[J

<SNR>4_expand_path returning '/Users/tsen/.vim/bundle/'[J

continuing in 1[J

1 returning '/Users/tsen/.vim/bundle/Vundle.vim'[J

continuing in <SNR>4_rtpath[J

<SNR>4_rtpath returning '/Users/tsen/.vim/bundle/Vundle.vim'[J

continuing in vundle#config#init_bundle[J

line 7:   return b[J

vundle#config#init_bundle returning {'uri': 'https://github.com/VundleVim/...Vim/Vundle.vim', 'path': function('1')}[J

continuing in vundle#config#bundle[J

line 2:   if !s:check_bundle_name(bundle)[J

calling <SNR>4_check_bundle_name[J({'uri': 'https://github.com/VundleVim/...Vim/Vundle.vim', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)[J

line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'[J

line 6:     return 0[J

line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'[J

line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name[J

line 9:     return 0[J

line 10:   endif[J

line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec[J

line 12:   return 1[J

<SNR>4_check_bundle_name returning #1[J

continuing in vundle#config#bundle[J

line 3:     return[J

line 4:   endif[J

line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load[J

line 6:     call add(g:vundle#bundles, bundle)[J

line 7:   else[J

line 8:     call s:rtp_rm_a()[J

line 9:     call add(g:vundle#bundles, bundle)[J

line 10:     call s:rtp_add_a()[J

line 11:     call s:rtp_add_defaults()[J

line 12:   endif[J

line 13:   return bundle[J

vundle#config#bundle returning {'uri': 'https://github.com/VundleVim/...Vim/Vundle.vim', 'path': function('1')}[J

continuing in /Users/tsen/.vim/vimrc[J

line 11: [J

line 12: " tab[J

line 13: Plugin 'scrooloose/nerdtree'[J

line 13: call vundle#config#bundle('scrooloose/nerdtree')[J

calling vundle#config#bundle[J('scrooloose/nerdtree')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)[J

calling vundle#config#init_bundle[J('scrooloose/nerdtree', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')[J

line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"[J

line 3:   endif[J

line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')[J

calling <SNR>4_parse_options[J([])

line 1:   " TODO: improve this[J

line 2:   if len(a:opts) != 1 | return {} | endif[J

line 2:  return {} | endif[J

<SNR>4_parse_options returning {}[J

continuing in vundle#config#init_bundle[J

calling <SNR>4_parse_name[J('scrooloose/nerdtree')

line 1:   let arg = a:arg[J

line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'[J

line 3: [J

line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'[J

line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1][J

line 7:     if uri !~? '\.git$'[J

line 8:       let uri .= '.git'[J

line 9:     endif[J

line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')[J

line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'[J

line 14:     let uri = arg[J

line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1][J

line 16:   else[J

line 17:     let name = arg[J

line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'[J

line 19:   endif[J

line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }[J

<SNR>4_parse_name returning {'uri': 'https://github.com/scrooloose...e', 'name_spec': 'scrooloose/nerdtree'}[J

continuing in vundle#config#init_bundle[J

line 5:   let b = extend(opts, copy(s:bundle))[J

line 6:   let b.rtpath = s:rtpath(opts)[J

calling <SNR>4_rtpath[J({'uri': 'https://github.com/scrooloose...loose/nerdtree', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()[J

calling 1[J()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name[J

calling <SNR>4_expand_path[J('/Users/tsen/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))[J

<SNR>4_expand_path returning '/Users/tsen/.vim/bundle/'[J

continuing in 1[J

1 returning '/Users/tsen/.vim/bundle/nerdtree'[J

continuing in <SNR>4_rtpath[J

<SNR>4_rtpath returning '/Users/tsen/.vim/bundle/nerdtree'[J

continuing in vundle#config#init_bundle[J

line 7:   return b[J

vundle#config#init_bundle returning {'uri': 'https://github.com/scrooloose...loose/nerdtree', 'path': function('1')}[J

continuing in vundle#config#bundle[J

line 2:   if !s:check_bundle_name(bundle)[J

calling <SNR>4_check_bundle_name[J({'uri': 'https://github.com/scrooloose...loose/nerdtree', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)[J

line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'[J

line 6:     return 0[J

line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'[J

line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name[J

line 9:     return 0[J

line 10:   endif[J

line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec[J

line 12:   return 1[J

<SNR>4_check_bundle_name returning #1[J

continuing in vundle#config#bundle[J

line 3:     return[J

line 4:   endif[J

line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load[J

line 6:     call add(g:vundle#bundles, bundle)[J

line 7:   else[J

line 8:     call s:rtp_rm_a()[J

line 9:     call add(g:vundle#bundles, bundle)[J

line 10:     call s:rtp_add_a()[J

line 11:     call s:rtp_add_defaults()[J

line 12:   endif[J

line 13:   return bundle[J

vundle#config#bundle returning {'uri': 'https://github.com/scrooloose...loose/nerdtree', 'path': function('1')}[J

continuing in /Users/tsen/.vim/vimrc[J

line 14: Plugin 'jistr/vim-nerdtree-tabs'[J

line 14: call vundle#config#bundle('jistr/vim-nerdtree-tabs')[J

calling vundle#config#bundle[J('jistr/vim-nerdtree-tabs')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)[J

calling vundle#config#init_bundle[J('jistr/vim-nerdtree-tabs', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')[J

line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"[J

line 3:   endif[J

line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')[J

calling <SNR>4_parse_options[J([])

line 1:   " TODO: improve this[J

line 2:   if len(a:opts) != 1 | return {} | endif[J

line 2:  return {} | endif[J

<SNR>4_parse_options returning {}[J

continuing in vundle#config#init_bundle[J

calling <SNR>4_parse_name[J('jistr/vim-nerdtree-tabs')

line 1:   let arg = a:arg[J

line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'[J

line 3: [J

line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'[J

line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1][J

line 7:     if uri !~? '\.git$'[J

line 8:       let uri .= '.git'[J

line 9:     endif[J

line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')[J

line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'[J

line 14:     let uri = arg[J

line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1][J

line 16:   else[J

line 17:     let name = arg[J

line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'[J

line 19:   endif[J

line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }[J

<SNR>4_parse_name returning {'uri': 'https://github.com/jistr/vim-...'name_spec': 'jistr/vim-nerdtree-tabs'}[J

continuing in vundle#config#init_bundle[J

line 5:   let b = extend(opts, copy(s:bundle))[J

line 6:   let b.rtpath = s:rtpath(opts)[J

calling <SNR>4_rtpath[J({'uri': 'https://github.com/jistr/vim-...-nerdtree-tabs', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()[J

calling 1[J()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name[J

calling <SNR>4_expand_path[J('/Users/tsen/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))[J

<SNR>4_expand_path returning '/Users/tsen/.vim/bundle/'[J

continuing in 1[J

1 returning '/Users/tsen/.vim/bundle/vim-nerdtree-tabs'[J

continuing in <SNR>4_rtpath[J

<SNR>4_rtpath returning '/Users/tsen/.vim/bundle/vim-nerdtree-tabs'[J

continuing in vundle#config#init_bundle[J

line 7:   return b[J

vundle#config#init_bundle returning {'uri': 'https://github.com/jistr/vim-...-nerdtree-tabs', 'path': function('1')}[J

continuing in vundle#config#bundle[J

line 2:   if !s:check_bundle_name(bundle)[J

calling <SNR>4_check_bundle_name[J({'uri': 'https://github.com/jistr/vim-...-nerdtree-tabs', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)[J

line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'[J

line 6:     return 0[J

line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'[J

line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name[J

line 9:     return 0[J

line 10:   endif[J

line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec[J

line 12:   return 1[J

<SNR>4_check_bundle_name returning #1[J

continuing in vundle#config#bundle[J

line 3:     return[J

line 4:   endif[J

line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load[J

line 6:     call add(g:vundle#bundles, bundle)[J

line 7:   else[J

line 8:     call s:rtp_rm_a()[J

line 9:     call add(g:vundle#bundles, bundle)[J

line 10:     call s:rtp_add_a()[J

line 11:     call s:rtp_add_defaults()[J

line 12:   endif[J

line 13:   return bundle[J

vundle#config#bundle returning {'uri': 'https://github.com/jistr/vim-...-nerdtree-tabs', 'path': function('1')}[J

continuing in /Users/tsen/.vim/vimrc[J

line 15: [J

line 16: " 自動排版 需要安裝 astyle 才支援 c/c++[J

line 17: Plugin 'vim-autoformat/vim-autoformat'[J

line 17: call vundle#config#bundle('vim-autoformat/vim-autoformat')[J

calling vundle#config#bundle[J('vim-autoformat/vim-autoformat')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)[J

calling vundle#config#init_bundle[J('vim-autoformat/vim-autoformat', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')[J

line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"[J

line 3:   endif[J

line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')[J

calling <SNR>4_parse_options[J([])

line 1:   " TODO: improve this[J

line 2:   if len(a:opts) != 1 | return {} | endif[J

line 2:  return {} | endif[J

<SNR>4_parse_options returning {}[J

continuing in vundle#config#init_bundle[J

calling <SNR>4_parse_name[J('vim-autoformat/vim-autoformat')

line 1:   let arg = a:arg[J

line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'[J

line 3: [J

line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'[J

line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1][J

line 7:     if uri !~? '\.git$'[J

line 8:       let uri .= '.git'[J

line 9:     endif[J

line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')[J

line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'[J

line 14:     let uri = arg[J

line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1][J

line 16:   else[J

line 17:     let name = arg[J

line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'[J

line 19:   endif[J

line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }[J

<SNR>4_parse_name returning {'uri': 'https://github.com/vim-autofo...spec': 'vim-autoformat/vim-autoformat'}[J

continuing in vundle#config#init_bundle[J

line 5:   let b = extend(opts, copy(s:bundle))[J

line 6:   let b.rtpath = s:rtpath(opts)[J

calling <SNR>4_rtpath[J({'uri': 'https://github.com/vim-autofo...vim-autoformat', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()[J

calling 1[J()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name[J

calling <SNR>4_expand_path[J('/Users/tsen/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))[J

<SNR>4_expand_path returning '/Users/tsen/.vim/bundle/'[J

continuing in 1[J

1 returning '/Users/tsen/.vim/bundle/vim-autoformat'[J

continuing in <SNR>4_rtpath[J

<SNR>4_rtpath returning '/Users/tsen/.vim/bundle/vim-autoformat'[J

continuing in vundle#config#init_bundle[J

line 7:   return b[J

vundle#config#init_bundle returning {'uri': 'https://github.com/vim-autofo...vim-autoformat', 'path': function('1')}[J

continuing in vundle#config#bundle[J

line 2:   if !s:check_bundle_name(bundle)[J

calling <SNR>4_check_bundle_name[J({'uri': 'https://github.com/vim-autofo...vim-autoformat', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)[J

line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'[J

line 6:     return 0[J

line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'[J

line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name[J

line 9:     return 0[J

line 10:   endif[J

line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec[J

line 12:   return 1[J

<SNR>4_check_bundle_name returning #1[J

continuing in vundle#config#bundle[J

line 3:     return[J

line 4:   endif[J

line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load[J

line 6:     call add(g:vundle#bundles, bundle)[J

line 7:   else[J

line 8:     call s:rtp_rm_a()[J

line 9:     call add(g:vundle#bundles, bundle)[J

line 10:     call s:rtp_add_a()[J

line 11:     call s:rtp_add_defaults()[J

line 12:   endif[J

line 13:   return bundle[J

vundle#config#bundle returning {'uri': 'https://github.com/vim-autofo...vim-autoformat', 'path': function('1')}[J

continuing in /Users/tsen/.vim/vimrc[J

line 18: let g:python3_host_prog="/path/to/python/executable/"[J

line 19: let g:formatterpath = ['/some/path/to/a/folder', '/home/superman/formatters'][J

line 20: [J

line 21: "xml， html 等成對標籤都可以自動補全[J

line 22: Plugin 'docunext/closetag.vim'[J

line 22: call vundle#config#bundle('docunext/closetag.vim')[J

calling vundle#config#bundle[J('docunext/closetag.vim')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)[J

calling vundle#config#init_bundle[J('docunext/closetag.vim', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')[J

line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"[J

line 3:   endif[J

line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')[J

calling <SNR>4_parse_options[J([])

line 1:   " TODO: improve this[J

line 2:   if len(a:opts) != 1 | return {} | endif[J

line 2:  return {} | endif[J

<SNR>4_parse_options returning {}[J

continuing in vundle#config#init_bundle[J

calling <SNR>4_parse_name[J('docunext/closetag.vim')

line 1:   let arg = a:arg[J

line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'[J

line 3: [J

line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'[J

line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1][J

line 7:     if uri !~? '\.git$'[J

line 8:       let uri .= '.git'[J

line 9:     endif[J

line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')[J

line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'[J

line 14:     let uri = arg[J

line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1][J

line 16:   else[J

line 17:     let name = arg[J

line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'[J

line 19:   endif[J

line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }[J

<SNR>4_parse_name returning {'uri': 'https://github.com/docunext/c..., 'name_spec': 'docunext/closetag.vim'}[J

continuing in vundle#config#init_bundle[J

line 5:   let b = extend(opts, copy(s:bundle))[J

line 6:   let b.rtpath = s:rtpath(opts)[J

calling <SNR>4_rtpath[J({'uri': 'https://github.com/docunext/c...t/closetag.vim', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()[J

calling 1[J()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name[J

calling <SNR>4_expand_path[J('/Users/tsen/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))[J

<SNR>4_expand_path returning '/Users/tsen/.vim/bundle/'[J

continuing in 1[J

1 returning '/Users/tsen/.vim/bundle/closetag.vim'[J

continuing in <SNR>4_rtpath[J

<SNR>4_rtpath returning '/Users/tsen/.vim/bundle/closetag.vim'[J

continuing in vundle#config#init_bundle[J

line 7:   return b[J

vundle#config#init_bundle returning {'uri': 'https://github.com/docunext/c...t/closetag.vim', 'path': function('1')}[J

continuing in vundle#config#bundle[J

line 2:   if !s:check_bundle_name(bundle)[J

calling <SNR>4_check_bundle_name[J({'uri': 'https://github.com/docunext/c...t/closetag.vim', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)[J

line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'[J

line 6:     return 0[J

line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'[J

line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name[J

line 9:     return 0[J

line 10:   endif[J

line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec[J

line 12:   return 1[J

<SNR>4_check_bundle_name returning #1[J

continuing in vundle#config#bundle[J

line 3:     return[J

line 4:   endif[J

line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load[J

line 6:     call add(g:vundle#bundles, bundle)[J

line 7:   else[J

line 8:     call s:rtp_rm_a()[J

line 9:     call add(g:vundle#bundles, bundle)[J

line 10:     call s:rtp_add_a()[J

line 11:     call s:rtp_add_defaults()[J

line 12:   endif[J

line 13:   return bundle[J

vundle#config#bundle returning {'uri': 'https://github.com/docunext/c...t/closetag.vim', 'path': function('1')}[J

continuing in /Users/tsen/.vim/vimrc[J

line 23: let b:closetag_html_style=1[J

line 24: [J

line 25: " Func def jump[J

line 26: Plugin 'preservim/tagbar'[J

line 26: call vundle#config#bundle('preservim/tagbar')[J

calling vundle#config#bundle[J('preservim/tagbar')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)[J

calling vundle#config#init_bundle[J('preservim/tagbar', [])

line 1:   if a:name != substitute(a:name, '^\s*\(.\{-}\)\s*$', '\1', '')[J

line 2:     echo "Spurious leading and/or trailing whitespace found in plugin spec '" . a:name . "'"[J

line 3:   endif[J

line 4:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')), 'keep')[J

calling <SNR>4_parse_options[J([])

line 1:   " TODO: improve this[J

line 2:   if len(a:opts) != 1 | return {} | endif[J

line 2:  return {} | endif[J

<SNR>4_parse_options returning {}[J

continuing in vundle#config#init_bundle[J

calling <SNR>4_parse_name[J('preservim/tagbar')

line 1:   let arg = a:arg[J

line 2:   let git_proto = exists('g:vundle_default_git_proto') ? g:vundle_default_git_proto : 'https'[J

line 3: [J

line 4:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'[J

line 6:     let uri = git_proto.'://github.com/'.split(arg, ':')[-1][J

line 7:     if uri !~? '\.git$'[J

line 8:       let uri .= '.git'[J

line 9:     endif[J

line 10:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')[J

line 11:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'   || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'[J

line 14:     let uri = arg[J

line 15:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1][J

line 16:   else[J

line 17:     let name = arg[J

line 18:     let uri  = git_proto.'://github.com/vim-scripts/'.name.'.git'[J

line 19:   endif[J

line 20:   return {'name': name, 'uri': uri, 'name_spec': arg }[J

<SNR>4_parse_name returning {'uri': 'https://github.com/preservim/...gbar', 'name_spec': 'preservim/tagbar'}[J

continuing in vundle#config#init_bundle[J

line 5:   let b = extend(opts, copy(s:bundle))[J

line 6:   let b.rtpath = s:rtpath(opts)[J

calling <SNR>4_rtpath[J({'uri': 'https://github.com/preservim/...eservim/tagbar', 'path': function('1')})

line 1:   return has_key(a:opts, 'rtp') ? s:expand_path(a:opts.path().'/'.a:opts.rtp) : a:opts.path()[J

calling 1[J()

line 1:   return s:expand_path(g:vundle#bundle_dir.'/') . self.name[J

calling <SNR>4_expand_path[J('/Users/tsen/.vim/bundle/')

line 1:   return simplify(expand(a:path, 1))[J

<SNR>4_expand_path returning '/Users/tsen/.vim/bundle/'[J

continuing in 1[J

1 returning '/Users/tsen/.vim/bundle/tagbar'[J

continuing in <SNR>4_rtpath[J

<SNR>4_rtpath returning '/Users/tsen/.vim/bundle/tagbar'[J

continuing in vundle#config#init_bundle[J

line 7:   return b[J

vundle#config#init_bundle returning {'uri': 'https://github.com/preservim/...eservim/tagbar', 'path': function('1')}[J

continuing in vundle#config#bundle[J

line 2:   if !s:check_bundle_name(bundle)[J

calling <SNR>4_check_bundle_name[J({'uri': 'https://github.com/preservim/...eservim/tagbar', 'path': function('1')})

line 1:   if has_key(s:bundle_names, a:bundle.name)[J

line 2:     echoerr 'Vundle error: Name collision for Plugin ' . a:bundle.name_spec . '. Plugin ' . s:bundle_names[a:bundle.name] . ' previously used the name "' . a:bundle.name . '"' . '. Skipping Plugin ' . a:bundle.name_spec . '.'[J

line 6:     return 0[J

line 7:   elseif a:bundle.name !~ '\v^[A-Za-z0-9_-]%(\.?[A-Za-z0-9_-])*$'[J

line 8:     echoerr 'Invalid plugin name: ' . a:bundle.name[J

line 9:     return 0[J

line 10:   endif[J

line 11:   let s:bundle_names[a:bundle.name] = a:bundle.name_spec[J

line 12:   return 1[J

<SNR>4_check_bundle_name returning #1[J

continuing in vundle#config#bundle[J

line 3:     return[J

line 4:   endif[J

line 5:   if exists('g:vundle#lazy_load') && g:vundle#lazy_load[J

line 6:     call add(g:vundle#bundles, bundle)[J

line 7:   else[J

line 8:     call s:rtp_rm_a()[J

line 9:     call add(g:vundle#bundles, bundle)[J

line 10:     call s:rtp_add_a()[J

line 11:     call s:rtp_add_defaults()[J

line 12:   endif[J

line 13:   return bundle[J

vundle#config#bundle returning {'uri': 'https://github.com/preservim/...eservim/tagbar', 'path': function('1')}[J

continuing in /Users/tsen/.vim/vimrc[J

line 27: [J

line 28: call vundle#end()            " required[J

calling vundle#end[J()

line 1:   unlet g:vundle#lazy_load[J

line 2:   call vundle#config#activate_bundles()[J

calling vundle#config#activate_bundles[J()

line 1:   call s:rtp_add_a()[J

calling <SNR>4_rtp_add_a[J()

line 1:   let paths = map(copy(g:vundle#bundles), 'v:val.rtpath')[J

line 2:   let prepends = join(paths, ',')[J

line 3:   let appends = join(paths, '/after,').'/after'[J

line 4:   exec 'set rtp^='.fnameescape(prepends)[J

line 4: set rtp^=/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar[J

line 5:   exec 'set rtp+='.fnameescape(appends)[J

line 5: set rtp+=/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after[J

<SNR>4_rtp_add_a returning #0[J

continuing in vundle#config#activate_bundles[J

line 2:   call s:rtp_add_defaults()[J

calling <SNR>4_rtp_add_defaults[J()

line 1:   let current = &rtp[J

line 2:   set rtp&vim[J

line 3:   let default = &rtp[J

line 4:   let &rtp = current[J

line 5:   let default_rtp_items = split(default, ',')[J

line 6:   if !empty(default_rtp_items)[J

line 7:     let first_item = fnameescape(default_rtp_items[0])[J

line 8:     exec 'set rtp-=' . first_item[J

line 8: set rtp-=/Users/tsen/.vim[J

line 9:     exec 'set rtp^=' . first_item[J

line 9: set rtp^=/Users/tsen/.vim[J

line 10:   endif[J

<SNR>4_rtp_add_defaults returning #0[J

continuing in vundle#config#activate_bundles[J

vundle#config#activate_bundles returning #0[J

continuing in vundle#end[J

vundle#end returning #0[J

continuing in /Users/tsen/.vim/vimrc[J

line 29: filetype plugin indent on    " required[J

Searching for "filetype.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/filetype.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/filetype.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/filetype.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/filetype.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/filetype.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/filetype.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/filetype.vim"[J
Searching for "/usr/local/share/vim/vimfiles/filetype.vim"[J
Searching for "/usr/local/share/vim/vim90/filetype.vim"[J
chdir(/usr/local/share/vim/vim90)[J
fchdir() to previous dir[J
line 29: sourcing "/usr/local/share/vim/vim90/filetype.vim"[J
line 1: " Vim support file to detect file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last Change:^I2022 Dec 05[J

line 5: [J

line 6: " Listen very carefully, I will say this only once[J

line 7: if exists("did_load_filetypes")[J

line 8:   finish[J

line 9: endif[J

line 10: let did_load_filetypes = 1[J

line 11: [J

line 12: " Line continuation is used here, remove 'C' from 'cpoptions'[J

line 13: let s:cpo_save = &cpo[J

line 14: set cpo&vim[J

line 15: [J

line 16: augroup filetypedetect[J

line 17: [J

line 18: " Ignored extensions[J

line 19: if exists("*fnameescape")[J

line 20: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))[J

line 22: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short[J

line 29: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif[J

line 33: elseif &verbose > 0[J

line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"[J

line 35: endif[J

line 36: [J

line 37: " Pattern used to match file names which should not be inspected.[J

line 38: " Currently finds compressed files.[J

line 39: if !exists("g:ft_ignore_pat")[J

line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'[J

line 41: endif[J

line 42: [J

line 43: " Function used for patterns that end in a star: don't set the filetype if the[J

line 44: " file name matches ft_ignore_pat.[J

line 45: " When using this, the entry should probably be further down below with the[J

line 46: " other StarSetf() calls.[J

line 47: func s:StarSetf(ft)[J

line 52: [J

line 53: " Vim help file[J

line 54: au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt^Isetf help[J

line 55: [J

line 56: " Abaqus or Trasys[J

line 57: au BufNewFile,BufRead *.inp^I^I^Icall dist#ft#Check_inp()[J

line 58: [J

line 59: " 8th (Firth-derivative)[J

line 60: au BufNewFile,BufRead *.8th^I^I^Isetf 8th[J

line 61: [J

line 62: " A-A-P recipe[J

line 63: au BufNewFile,BufRead *.aap^I^I^Isetf aap[J

line 64: [J

line 65: " A2ps printing utility[J

line 66: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps[J

line 67: [J

line 68: " ABAB/4[J

line 69: au BufNewFile,BufRead *.abap^I^I^Isetf abap[J

line 70: [J

line 71: " ABC music notation[J

line 72: au BufNewFile,BufRead *.abc^I^I^Isetf abc[J

line 73: [J

line 74: " ABEL[J

line 75: au BufNewFile,BufRead *.abl^I^I^Isetf abel[J

line 76: [J

line 77: " AceDB[J

line 78: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb[J

line 79: [J

line 80: " Ada (83, 9X, 95)[J

line 81: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada[J

line 82: if has("vms")[J

line 83:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada[J

line 84: else[J

line 85:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada[J

line 86: endif[J

line 87: [J

line 88: " AHDL[J

line 89: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl[J

line 90: [J

line 91: " AIDL[J

line 92: au BufNewFile,BufRead *.aidl^I^I^Isetf aidl[J

line 93: [J

line 94: " AMPL[J

line 95: au BufNewFile,BufRead *.run^I^I^Isetf ampl[J

line 96: [J

line 97: " Ant[J

line 98: au BufNewFile,BufRead build.xml^I^I^Isetf ant[J

line 99: [J

line 100: " Arduino[J

line 101: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino[J

line 102: [J

line 103: " Apache config file[J

line 104: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache[J

line 105: au BufNewFile,BufRead */etc/apache2/sites-*/*.com^I^Isetf apache[J

line 106: [J

line 107: " XA65 MOS6510 cross assembler[J

line 108: au BufNewFile,BufRead *.a65^I^I^Isetf a65[J

line 109: [J

line 110: " Applescript[J

line 111: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript[J

line 112: [J

line 113: " Applix ELF[J

line 114: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif[J

line 116: [J

line 117: " ALSA configuration[J

line 118: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf[J

line 119: [J

line 120: " Arc Macro Language[J

line 121: au BufNewFile,BufRead *.aml^I^I^Isetf aml[J

line 122: [J

line 123: " APT config file[J

line 124: au BufNewFile,BufRead apt.conf^I^I       setf aptconf[J

line 125: au BufNewFile,BufRead */.aptitude/config       setf aptconf[J

line 126: " more generic pattern far down[J

line 127: [J

line 128: " Arch Inventory file[J

line 129: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch[J

line 130: [J

line 131: " ART*Enterprise (formerly ART-IM)[J

line 132: au BufNewFile,BufRead *.art^I^I^Isetf art[J

line 133: [J

line 134: " AsciiDoc[J

line 135: au BufNewFile,BufRead *.asciidoc,*.adoc^I^Isetf asciidoc[J

line 136: [J

line 137: " ASN.1[J

line 138: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn[J

line 139: [J

line 140: " Active Server Pages (with Visual Basic Script)[J

line 141: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif[J

line 147: [J

line 148: " Active Server Pages (with Perl or Visual Basic Script)[J

line 149: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif[J

line 157: [J

line 158: " Grub (must be before pattern *.lst)[J

line 159: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub[J

line 160: [J

line 161: " Maxima, see:[J

line 162: " https://maxima.sourceforge.io/docs/manual/maxima_71.html#file_005ftype_005fmaxima[J

line 163: " Must be before the pattern *.mac.[J

line 164: " *.dem omitted - also used by gnuplot demos[J

line 165: " *.mc omitted - used by dist#ft#McSetf()[J

line 166: au BufNewFile,BufRead *.demo,*.dm{1,2,3,t},*.wxm,maxima-init.mac setf maxima[J

line 167: [J

line 168: " Assembly (all kinds)[J

line 169: " *.lst is not pure assembly, it has two extra columns (address, byte codes)[J

line 170: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall dist#ft#FTasm()[J

line 171: [J

line 172: " Assembly - Macro (VAX)[J

line 173: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm[J

line 174: [J

line 175: " Astro[J

line 176: au BufNewFile,BufRead *.astro^I^I^Isetf astro[J

line 177: [J

line 178: " Atlas[J

line 179: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas[J

line 180: [J

line 181: " Atom is based on XML[J

line 182: au BufNewFile,BufRead *.atom^I^I^Isetf xml[J

line 183: [J

line 184: " Autoit v3[J

line 185: au BufNewFile,BufRead *.au3^I^I^Isetf autoit[J

line 186: [J

line 187: " Autohotkey[J

line 188: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey[J

line 189: [J

line 190: " Automake[J

line 191: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake[J

line 192: [J

line 193: " Autotest .at files are actually m4[J

line 194: au BufNewFile,BufRead *.at^I^I^Isetf m4[J

line 195: [J

line 196: " Avenue[J

line 197: au BufNewFile,BufRead *.ave^I^I^Isetf ave[J

line 198: [J

line 199: " Awk[J

line 200: au BufNewFile,BufRead *.awk,*.gawk^I^Isetf awk[J

line 201: [J

line 202: " B[J

line 203: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b[J

line 204: [J

line 205: " BASIC or Visual Basic[J

line 206: au BufNewFile,BufRead *.bas^I^I^Icall dist#ft#FTbas()[J

line 207: au BufNewFile,BufRead *.bi,*.bm^I^I^Icall dist#ft#FTbas()[J

line 208: [J

line 209: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET[J

line 210: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb[J

line 211: [J

line 212: " IBasic file (similar to QBasic)[J

line 213: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic[J

line 214: [J

line 215: " FreeBasic file (similar to QBasic)[J

line 216: au BufNewFile,BufRead *.fb^I^I^Isetf freebasic[J

line 217: [J

line 218: " Batch file for MSDOS. See dist#ft#FTsys for *.sys[J

line 219: au BufNewFile,BufRead *.bat^I^I^Isetf dosbatch[J

line 220: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.[J

line 221: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif[J

line 223: " ABB RAPID or Batch file for MSDOS.[J

line 224: au BufNewFile,BufRead *.sys\c^I^I^Icall dist#ft#FTsys()[J

line 225: [J

line 226: " Batch file for 4DOS[J

line 227: au BufNewFile,BufRead *.btm^I^I^Icall dist#ft#FTbtm()[J

line 228: [J

line 229: " BC calculator[J

line 230: au BufNewFile,BufRead *.bc^I^I^Isetf bc[J

line 231: [J

line 232: " BDF font[J

line 233: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf[J

line 234: [J

line 235: " Beancount[J

line 236: au BufNewFile,BufRead *.beancount^I^Isetf beancount[J

line 237: [J

line 238: " BibTeX bibliography database file[J

line 239: au BufNewFile,BufRead *.bib^I^I^Isetf bib[J

line 240: [J

line 241: " BibTeX Bibliography Style[J

line 242: au BufNewFile,BufRead *.bst^I^I^Isetf bst[J

line 243: [J

line 244: " Bicep[J

line 245: au BufNewFile,BufRead *.bicep^I^I^Isetf bicep[J

line 246: [J

line 247: " BIND configuration[J

line 248: " sudoedit uses namedXXXX.conf[J

line 249: au BufNewFile,BufRead named*.conf,rndc*.conf,rndc*.key^Isetf named[J

line 250: [J

line 251: " BIND zone[J

line 252: au BufNewFile,BufRead named.root^I^Isetf bindzone[J

line 253: au BufNewFile,BufRead *.db^I^I^Icall dist#ft#BindzoneCheck('')[J

line 254: [J

line 255: " Blank[J

line 256: au BufNewFile,BufRead *.bl^I^I^Isetf blank[J

line 257: [J

line 258: " Bitbake[J

line 259: au BufNewFile,BufRead *.bb,*.bbappend,*.bbclass,*/build/conf/*.conf,*/meta{-*,}/conf/*.conf^Isetf bitbake[J

line 260: [J

line 261: " Blkid cache file[J

line 262: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml[J

line 263: [J

line 264: " BSDL[J

line 265: au BufNewFile,BufRead *.bsd,*.bsdl^I^I^Isetf bsdl[J

line 266: [J

line 267: " Bazel (http://bazel.io)[J

line 268: autocmd BufRead,BufNewFile *.bzl,*.bazel,WORKSPACE^Isetf bzl[J

line 269: if has("fname_case")[J

line 270:   " There is another check for BUILD further below.[J

line 271:   autocmd BufRead,BufNewFile *.BUILD,BUILD^I^Isetf bzl[J

line 272: endif[J

line 273: [J

line 274: " C or lpc[J

line 275: au BufNewFile,BufRead *.c^I^I^Icall dist#ft#FTlpc()[J

line 276: au BufNewFile,BufRead *.lpc,*.ulpc^I^Isetf lpc[J

line 277: [J

line 278: " Calendar[J

line 279: au BufNewFile,BufRead calendar^I^I^Isetf calendar[J

line 280: [J

line 281: " C#[J

line 282: au BufNewFile,BufRead *.cs,*.csx^I^Isetf cs[J

line 283: [J

line 284: " CSDL[J

line 285: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl[J

line 286: [J

line 287: " Cabal[J

line 288: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal[J

line 289: [J

line 290: " Cdrdao TOC[J

line 291: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc[J

line 292: [J

line 293: " Cdrdao config[J

line 294: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf[J

line 295: [J

line 296: " Cfengine[J

line 297: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine[J

line 298: [J

line 299: " ChaiScript[J

line 300: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript[J

line 301: [J

line 302: " Chatito[J

line 303: au BufNewFile,BufRead *.chatito^I^I^Isetf chatito[J

line 304: [J

line 305: " Comshare Dimension Definition Language[J

line 306: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl[J

line 307: [J

line 308: " Conary Recipe[J

line 309: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe[J

line 310: [J

line 311: " Controllable Regex Mutilator[J

line 312: au BufNewFile,BufRead *.crm^I^I^Isetf crm[J

line 313: [J

line 314: " Cyn++[J

line 315: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp[J

line 316: [J

line 317: " Cynlib[J

line 318: " .cc and .cpp files can be C++ or Cynlib.[J

line 319: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif[J

line 321: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif[J

line 323: [J

line 324: " C++[J

line 325: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp[J

line 326: if has("fname_case")[J

line 327:   au BufNewFile,BufRead *.C,*.H setf cpp[J

line 328: endif[J

line 329: [J

line 330: " .h files can be C, Ch C++, ObjC or ObjC++.[J

line 331: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is[J

line 332: " detected automatically.[J

line 333: au BufNewFile,BufRead *.h^I^I^Icall dist#ft#FTheader()[J

line 334: [J

line 335: " Ch (CHscript)[J

line 336: au BufNewFile,BufRead *.chf^I^I^Isetf ch[J

line 337: [J

line 338: " TLH files are C++ headers generated by Visual C++'s #import from typelibs[J

line 339: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp[J

line 340: [J

line 341: " Cascading Style Sheets[J

line 342: au BufNewFile,BufRead *.css^I^I^Isetf css[J

line 343: [J

line 344: " Century Term Command Scripts (*.cmd too)[J

line 345: au BufNewFile,BufRead *.con^I^I^Isetf cterm[J

line 346: [J

line 347: " Changelog[J

line 348: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch,*/debian/changelog^Isetf debchangelog[J

line 350: [J

line 351: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif[J

line 357: [J

line 358: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif[J

line 362: [J

line 363: " CHILL[J

line 364: au BufNewFile,BufRead *..ch^I^I^Isetf chill[J

line 365: [J

line 366: " Changes for WEB and CWEB or CHILL[J

line 367: au BufNewFile,BufRead *.ch^I^I^Icall dist#ft#FTchange()[J

line 368: [J

line 369: " ChordPro[J

line 370: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro[J

line 371: [J

line 372: " Clang-format[J

line 373: au BufNewFile,BufRead .clang-format^I^Isetf yaml[J

line 374: [J

line 375: " Clang-tidy[J

line 376: au BufNewFile,BufRead .clang-tidy^I^Isetf yaml[J

line 377: [J

line 378: " Clean[J

line 379: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean[J

line 380: [J

line 381: " Clever[J

line 382: au BufNewFile,BufRead *.eni^I^I^Isetf cl[J

line 383: [J

line 384: " Clever or dtd[J

line 385: au BufNewFile,BufRead *.ent^I^I^Icall dist#ft#FTent()[J

line 386: [J

line 387: " Clipper, FoxPro, ABB RAPID or eviews[J

line 388: au BufNewFile,BufRead *.prg\c^I^I^Icall dist#ft#FTprg()[J

line 389: [J

line 390: " Clojure[J

line 391: au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc^I^Isetf clojure[J

line 392: [J

line 393: " Cmake[J

line 394: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake[J

line 395: [J

line 396: " Cmusrc[J

line 397: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc[J

line 398: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc[J

line 399: [J

line 400: " Cobol[J

line 401: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol[J

line 402: "   cobol or zope form controller python script? (heuristic)[J

line 403: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif[J

line 409: [J

line 410: " Coco/R[J

line 411: au BufNewFile,BufRead *.atg^I^I^Isetf coco[J

line 412: [J

line 413: " Cold Fusion[J

line 414: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf[J

line 415: [J

line 416: " Configure scripts[J

line 417: au BufNewFile,BufRead configure.in,configure.ac setf config[J

line 418: [J

line 419: " Cooklang[J

line 420: au BufNewFile,BufRead *.cook^I^I^Isetf cook[J

line 421: [J

line 422: " Clinical Quality Language (CQL)[J

line 423: " .cql is also mentioned as the 'XDCC Catcher queue list' file extension.[J

line 424: " If support for XDCC Catcher is needed in the future, the contents of the file[J

line 425: " needs to be inspected.[J

line 426: au BufNewFile,BufRead *.cql^I^I^Isetf cqlang[J

line 427: [J

line 428: " CSV Files[J

line 429: au BufNewFile,BufRead *.csv^I^I^Isetf csv[J

line 430: [J

line 431: " CUDA Compute Unified Device Architecture[J

line 432: au BufNewFile,BufRead *.cu,*.cuh^I^Isetf cuda[J

line 433: [J

line 434: " Dockerfile; Podman uses the same syntax with name Containerfile[J

line 435: " Also see Dockerfile.* below.[J

line 436: au BufNewFile,BufRead Containerfile,Dockerfile,dockerfile,*.[dD]ockerfile^Isetf dockerfile[J

line 437: [J

line 438: " WildPackets EtherPeek Decoder[J

line 439: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd[J

line 440: [J

line 441: " Enlightenment configuration files[J

line 442: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c[J

line 443: [J

line 444: " Eterm[J

line 445: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm[J

line 446: [J

line 447: " Elixir or Euphoria[J

line 448: au BufNewFile,BufRead *.ex call dist#ft#ExCheck()[J

line 449: [J

line 450: " Elixir[J

line 451: au BufRead,BufNewFile mix.lock,*.exs setf elixir[J

line 452: au BufRead,BufNewFile *.eex,*.leex setf eelixir[J

line 453: [J

line 454: " Elvish[J

line 455: au BufRead,BufNewFile *.elv setf elvish[J

line 456: [J

line 457: " Euphoria 3 or 4[J

line 458: au BufNewFile,BufRead *.eu,*.ew,*.exu,*.exw  call dist#ft#EuphoriaCheck()[J

line 459: if has("fname_case")[J

line 460:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call dist#ft#EuphoriaCheck()[J

line 461: endif[J

line 462: [J

line 463: " Lynx config files[J

line 464: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx[J

line 465: [J

line 466: " LyRiCs[J

line 467: au BufNewFile,BufRead *.lrc^I^I^Isetf lyrics[J

line 468: [J

line 469: " Modula-3 configuration language (must be before *.cfg and *makefile)[J

line 470: au BufNewFile,BufRead *.quake,cm3.cfg^I^Isetf m3quake[J

line 471: au BufNewFile,BufRead m3makefile,m3overrides^Isetf m3build[J

line 472: [J

line 473: " Quake[J

line 474: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake[J

line 475: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake[J

line 476: [J

line 477: " Quake C[J

line 478: au BufNewFile,BufRead *.qc^I^I^Isetf c[J

line 479: [J

line 480: " Configure files[J

line 481: au BufNewFile,BufRead *.cfg\c^I^I^Icall dist#ft#FTcfg()[J

line 482: [J

line 483: " Cucumber[J

line 484: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber[J

line 485: [J

line 486: " Communicating Sequential Processes[J

line 487: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp[J

line 488: [J

line 489: " CUPL logic description and simulation[J

line 490: au BufNewFile,BufRead *.pld^I^I^Isetf cupl[J

line 491: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim[J

line 492: [J

line 493: " Dart[J

line 494: au BufRead,BufNewfile *.dart,*.drt^I^Isetf dart[J

line 495: [J

line 496: " Debian Control[J

line 497: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol[J

line 498: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif[J

line 502: [J

line 503: " Debian Copyright[J

line 504: au BufNewFile,BufRead */debian/copyright^Isetf debcopyright[J

line 505: au BufNewFile,BufRead copyright  if getline(1) =~ '^Format:'|   setf debcopyright| endif[J

line 509: [J

line 510: " Debian Sources.list[J

line 511: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources[J

line 512: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources[J

line 513: [J

line 514: " Deny hosts[J

line 515: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts[J

line 516: [J

line 517: " dnsmasq(8) configuration files[J

line 518: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq[J

line 519: [J

line 520: " ROCKLinux package description[J

line 521: au BufNewFile,BufRead *.desc^I^I^Isetf desc[J

line 522: [J

line 523: " the D language or dtrace[J

line 524: au BufNewFile,BufRead */dtrace/*.d^I^Isetf dtrace[J

line 525: au BufNewFile,BufRead *.d^I^I^Icall dist#ft#DtraceCheck()[J

line 526: [J

line 527: " Desktop files[J

line 528: au BufNewFile,BufRead *.desktop,*.directory^Isetf desktop[J

line 529: [J

line 530: " Dict config[J

line 531: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf[J

line 532: [J

line 533: " Dictd config[J

line 534: au BufNewFile,BufRead dictd*.conf^I^Isetf dictdconf[J

line 535: [J

line 536: " DEP3 formatted patch files[J

line 537: au BufNewFile,BufRead */debian/patches/*^Icall dist#ft#Dep3patch()[J

line 538: [J

line 539: " Diff files[J

line 540: au BufNewFile,BufRead *.diff,*.rej^I^Isetf diff[J

line 541: au BufNewFile,BufRead *.patch if getline(1) =~# '^From [0-9a-f]\{40,\} Mon Sep 17 00:00:00 2001$' |   setf gitsendemail | else |   setf diff | endif[J

line 547: [J

line 548: " Dircolors[J

line 549: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors[J

line 550: [J

line 551: " Diva (with Skill) or InstallShield[J

line 552: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif[J

line 558: [J

line 559: " DCL (Digital Command Language - vms) or DNS zone file[J

line 560: au BufNewFile,BufRead *.com^I^I^Icall dist#ft#BindzoneCheck('dcl')[J

line 561: [J

line 562: " DOT[J

line 563: au BufNewFile,BufRead *.dot,*.gv^I^Isetf dot[J

line 564: [J

line 565: " Dune[J

line 566: au BufNewFile,BufRead jbuild,dune,dune-project,dune-workspace setf dune[J

line 567: [J

line 568: " Dylan - lid files[J

line 569: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid[J

line 570: [J

line 571: " Dylan - intr files (melange)[J

line 572: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr[J

line 573: [J

line 574: " Dylan[J

line 575: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan[J

line 576: [J

line 577: " Microsoft Module Definition[J

line 578: au BufNewFile,BufRead *.def^I^I^Isetf def[J

line 579: [J

line 580: " Dracula[J

line 581: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula[J

line 582: [J

line 583: " Datascript[J

line 584: au BufNewFile,BufRead *.ds^I^I^Isetf datascript[J

line 585: [J

line 586: " dsl: DSSSL or Structurizr[J

line 587: au BufNewFile,BufRead *.dsl if getline(1) =~ '^\s*<\!' |   setf dsl | else |   setf structurizr | endif[J

line 593: [J

line 594: " DTD (Document Type Definition for XML)[J

line 595: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd[J

line 596: [J

line 597: " DTS/DSTI (device tree files)[J

line 598: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts[J

line 599: [J

line 600: " EDIF (*.edf,*.edif,*.edn,*.edo) or edn[J

line 601: au BufNewFile,BufRead *.ed\(f\|if\|o\)^I^Isetf edif[J

line 602: au BufNewFile,BufRead *.edn if getline(1) =~ '^\s*(\s*edif\>' |   setf edif | else |   setf clojure | endif[J

line 608: [J

line 609: " EditorConfig (close enough to dosini)[J

line 610: au BufNewFile,BufRead .editorconfig^I^Isetf dosini[J

line 611: [J

line 612: " Embedix Component Description[J

line 613: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd[J

line 614: [J

line 615: " Eiffel or Specman or Euphoria[J

line 616: au BufNewFile,BufRead *.e,*.E^I^I^Icall dist#ft#FTe()[J

line 617: [J

line 618: " Elinks configuration[J

line 619: au BufNewFile,BufRead elinks.conf^I^Isetf elinks[J

line 620: [J

line 621: " ERicsson LANGuage; Yaws is erlang too[J

line 622: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang[J

line 623: [J

line 624: " Elm[J

line 625: au BufNewFile,BufRead *.elm^I^I^Isetf elm[J

line 626: [J

line 627: " Elm Filter Rules file[J

line 628: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt[J

line 629: [J

line 630: " ESMTP rc file[J

line 631: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc[J

line 632: [J

line 633: " ESQL-C[J

line 634: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc[J

line 635: [J

line 636: " Esterel[J

line 637: au BufNewFile,BufRead *.strl^I^I^Isetf esterel[J

line 638: [J

line 639: " Essbase script[J

line 640: au BufNewFile,BufRead *.csc^I^I^Isetf csc[J

line 641: [J

line 642: " Exim[J

line 643: au BufNewFile,BufRead exim.conf^I^I^Isetf exim[J

line 644: [J

line 645: " Expect[J

line 646: au BufNewFile,BufRead *.exp^I^I^Isetf expect[J

line 647: [J

line 648: " Exports[J

line 649: au BufNewFile,BufRead exports^I^I^Isetf exports[J

line 650: [J

line 651: " Falcon[J

line 652: au BufNewFile,BufRead *.fal^I^I^Isetf falcon[J

line 653: [J

line 654: " Fantom[J

line 655: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan[J

line 656: [J

line 657: " Factor[J

line 658: au BufNewFile,BufRead *.factor^I^I^Isetf factor[J

line 659: [J

line 660: " Fennel[J

line 661: autocmd BufRead,BufNewFile *.fnl^I^Isetf fennel[J

line 662: [J

line 663: " Fetchmail RC file[J

line 664: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail[J

line 665: [J

line 666: " Fish shell[J

line 667: au BufNewFile,BufRead *.fish^I^I^Isetf fish[J

line 668: [J

line 669: " FlexWiki - disabled, because it has side effects when a .wiki file[J

line 670: " is not actually FlexWiki[J

line 671: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki[J

line 672: [J

line 673: " Focus Executable[J

line 674: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec[J

line 675: [J

line 676: " Focus Master file (but not for auto.master)[J

line 677: au BufNewFile,BufRead auto.master^I^Isetf conf[J

line 678: au BufNewFile,BufRead *.mas,*.master^I^Isetf master[J

line 679: [J

line 680: " Forth[J

line 681: au BufNewFile,BufRead *.ft,*.fth^I^Isetf forth[J

line 682: [J

line 683: " Reva Forth[J

line 684: au BufNewFile,BufRead *.frt^I^I^Isetf reva[J

line 685: [J

line 686: " Fortran[J

line 687: if has("fname_case")[J

line 688:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran[J

line 689: endif[J

line 690: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran[J

line 691: [J

line 692: " Framescript[J

line 693: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript[J

line 694: [J

line 695: " FStab[J

line 696: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab[J

line 697: [J

line 698: " Fusion[J

line 699: au BufRead,BufNewFile *.fusion^I^I^Isetf fusion[J

line 700: [J

line 701: " F# or Forth[J

line 702: au BufNewFile,BufRead *.fs^I^I^Icall dist#ft#FTfs()[J

line 703: [J

line 704: " F#[J

line 705: au BufNewFile,BufRead *.fsi,*.fsx^I^Isetf fsharp[J

line 706: [J

line 707: " GDB command files[J

line 708: au BufNewFile,BufRead .gdbinit,gdbinit,.gdbearlyinit,gdbearlyinit,*.gdb^I^Isetf gdb[J

line 709: [J

line 710: " GDMO[J

line 711: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo[J

line 712: [J

line 713: " GDscript[J

line 714: au BufNewFile,BufRead *.gd^I^I^Isetf gdscript[J

line 715: [J

line 716: " Godot resource[J

line 717: au BufRead,BufNewFile *.tscn,*.tres^I^Isetf gdresource[J

line 718: [J

line 719: " Godot shader[J

line 720: au BufRead,BufNewFile *.gdshader,*.shader^Isetf gdshader[J

line 721: [J

line 722: " Gedcom[J

line 723: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom[J

line 724: [J

line 725: " Gemtext[J

line 726: au BufNewFile,BufRead *.gmi,*.gemini^I^Isetf gemtext[J

line 727: [J

line 728: " Gift (Moodle)[J

line 729: autocmd BufRead,BufNewFile *.gift^I^Isetf gift[J

line 730: [J

line 731: " Git[J

line 732: au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG^Isetf gitcommit[J

line 733: au BufNewFile,BufRead NOTES_EDITMSG,EDIT_DESCRIPTION^I^Isetf gitcommit[J

line 734: au BufNewFile,BufRead *.git/config,.gitconfig,*/etc/gitconfig^Isetf gitconfig[J

line 735: au BufNewFile,BufRead */.config/git/config^I^I^Isetf gitconfig[J

line 736: au BufNewFile,BufRead *.git/config.worktree^I^I^Isetf gitconfig[J

line 737: au BufNewFile,BufRead *.git/worktrees/*/config.worktree^I^Isetf gitconfig[J

line 738: au BufNewFile,BufRead .gitmodules,*.git/modules/*/config^Isetf gitconfig[J

line 739: if !empty($XDG_CONFIG_HOME)[J

line 740:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config^I^Isetf gitconfig[J

line 741:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/attributes^I^Isetf gitattributes[J

line 742:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/ignore^I^Isetf gitignore[J

line 743: endif[J

line 744: au BufNewFile,BufRead .gitattributes,*.git/info/attributes^Isetf gitattributes[J

line 745: au BufNewFile,BufRead */.config/git/attributes^I^I^Isetf gitattributes[J

line 746: au BufNewFile,BufRead */etc/gitattributes^I^I^Isetf gitattributes[J

line 747: au BufNewFile,BufRead .gitignore,*.git/info/exclude^I^Isetf gitignore[J

line 748: au BufNewFile,BufRead */.config/git/ignore^I^I^Isetf gitignore[J

line 749: au BufNewFile,BufRead git-rebase-todo^I^I^I^Isetf gitrebase[J

line 750: au BufRead,BufNewFile .gitsendemail.msg.??????^I^I^Isetf gitsendemail[J

line 751: au BufNewFile,BufRead *.git/* if getline(1) =~# '^\x\{40,\}\>\|^ref: ' |   setf git | endif[J

line 755: [J

line 756: " Gkrellmrc[J

line 757: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc[J

line 758: [J

line 759: " Gleam[J

line 760: au BufNewFile,BufRead *.gleam^I^I^Isetf gleam[J

line 761: [J

line 762: " GLSL[J

line 763: au BufNewFile,BufRead *.glsl^I^I^Isetf glsl[J

line 764: [J

line 765: " GP scripts (2.0 and onward)[J

line 766: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp[J

line 767: [J

line 768: " GPG[J

line 769: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg[J

line 770: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg[J

line 771: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg[J

line 772: if !empty($GNUPGHOME)[J

line 773:   au BufNewFile,BufRead $GNUPGHOME/options^Isetf gpg[J

line 774:   au BufNewFile,BufRead $GNUPGHOME/gpg.conf^Isetf gpg[J

line 775: endif[J

line 776: [J

line 777: " gnash(1) configuration files[J

line 778: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash[J

line 779: [J

line 780: " Gitolite[J

line 781: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite[J

line 782: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl[J

line 783: [J

line 784: " Glimmer-flavored TypeScript and JavaScript[J

line 785: au BufNewFile,BufRead *.gts^I^I^Isetf typescript.glimmer[J

line 786: au BufNewFile,BufRead *.gjs^I^I^Isetf javascript.glimmer[J

line 787: [J

line 788: " Gnuplot scripts[J

line 789: au BufNewFile,BufRead *.gpi,.gnuplot^I^Isetf gnuplot[J

line 790: [J

line 791: " Go (Google)[J

line 792: au BufNewFile,BufRead *.go^I^I^Isetf go[J

line 793: au BufNewFile,BufRead Gopkg.lock^I^Isetf toml[J

line 794: au BufRead,BufNewFile go.work^I^I^Isetf gowork[J

line 795: [J

line 796: " GrADS scripts[J

line 797: au BufNewFile,BufRead *.gs^I^I^Isetf grads[J

line 798: [J

line 799: " GraphQL[J

line 800: au BufNewFile,BufRead *.graphql,*.graphqls,*.gql^I^I^Isetf graphql[J

line 801: [J

line 802: " Gretl[J

line 803: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl[J

line 804: [J

line 805: " Groovy[J

line 806: au BufNewFile,BufRead *.gradle,*.groovy^I^Isetf groovy[J

line 807: [J

line 808: " GNU Server Pages[J

line 809: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp[J

line 810: [J

line 811: " Group file[J

line 812: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group[J

line 813: [J

line 814: " GTK RC[J

line 815: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc[J

line 816: [J

line 817: " GYP[J

line 818: au BufNewFile,BufRead *.gyp,*.gypi^I^Isetf gyp[J

line 819: [J

line 820: " Hack[J

line 821: au BufRead,BufNewFile *.hack,*.hackpartial^I^I^Isetf hack[J

line 822: [J

line 823: " Haml[J

line 824: au BufNewFile,BufRead *.haml^I^I^Isetf haml[J

line 825: [J

line 826: " Hamster Classic | Playground files[J

line 827: au BufNewFile,BufRead *.hsm^I^I^Isetf hamster[J

line 828: [J

line 829: " Handlebars[J

line 830: au BufNewFile,BufRead *.hbs^I^I^Isetf handlebars[J

line 831: [J

line 832: " Hare[J

line 833: au BufNewFile,BufRead *.ha^I^I^Isetf hare[J

line 834: [J

line 835: " Haskell[J

line 836: au BufNewFile,BufRead *.hs,*.hsc,*.hs-boot,*.hsig setf haskell[J

line 837: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell[J

line 838: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell[J

line 839: au BufNewFile,BufRead cabal.project^I^Isetf cabalproject[J

line 840: au BufNewFile,BufRead $HOME/.cabal/config^Isetf cabalconfig[J

line 841: au BufNewFile,BufRead cabal.config^I^Isetf cabalconfig[J

line 842: [J

line 843: " Haste[J

line 844: au BufNewFile,BufRead *.ht^I^I^Isetf haste[J

line 845: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc[J

line 846: [J

line 847: " HCL[J

line 848: au BufRead,BufNewFile *.hcl^I^I^Isetf hcl[J

line 849: [J

line 850: " Hercules[J

line 851: au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum^Isetf hercules[J

line 852: [J

line 853: " HEEx[J

line 854: au BufRead,BufNewFile *.heex^I^I^Isetf heex[J

line 855: [J

line 856: " HEX (Intel)[J

line 857: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex[J

line 858: [J

line 859: " Hjson[J

line 860: au BufNewFile,BufRead *.hjson^I^I^Isetf hjson[J

line 861: [J

line 862: " HLS Playlist (or another form of playlist)[J

line 863: au BufNewFile,BufRead *.m3u,*.m3u8^I^Isetf hlsplaylist[J

line 864: [J

line 865: " Hollywood[J

line 866: au BufRead,BufNewFile *.hws^I^I^Isetf hollywood[J

line 867: [J

line 868: " Hoon[J

line 869: au BufRead,BufNewFile *.hoon^I^I^Isetf hoon[J

line 870: [J

line 871: " Tilde (must be before HTML)[J

line 872: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde[J

line 873: [J

line 874: " HTML (.shtml and .stm for server side)[J

line 875: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call dist#ft#FThtml()[J

line 876: au BufNewFile,BufRead *.cshtml^I^I^Isetf html[J

line 877: [J

line 878: " HTML with Ruby - eRuby[J

line 879: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby[J

line 880: [J

line 881: " HTML with M4[J

line 882: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4[J

line 883: [J

line 884: " Some template.  Used to be HTML Cheetah.[J

line 885: au BufNewFile,BufRead *.tmpl^I^I^Isetf template[J

line 886: [J

line 887: " Host config[J

line 888: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf[J

line 889: [J

line 890: " Hosts access[J

line 891: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess[J

line 892: [J

line 893: " Hyper Builder[J

line 894: au BufNewFile,BufRead *.hb^I^I^Isetf hb[J

line 895: [J

line 896: " Httest[J

line 897: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest[J

line 898: [J

line 899: " i3[J

line 900: au BufNewFile,BufRead */i3/config^I^Isetf i3config[J

line 901: au BufNewFile,BufRead */.i3/config^I^Isetf i3config[J

line 902: [J

line 903: " sway[J

line 904: au BufNewFile,BufRead */sway/config^I^Isetf swayconfig[J

line 905: au BufNewFile,BufRead */.sway/config^I^Isetf swayconfig[J

line 906: [J

line 907: " Icon[J

line 908: au BufNewFile,BufRead *.icn^I^I^Isetf icon[J

line 909: [J

line 910: " IDL (Interface Description Language)[J

line 911: au BufNewFile,BufRead *.idl^I^I^Icall dist#ft#FTidl()[J

line 912: [J

line 913: " Microsoft IDL (Interface Description Language)  Also *.idl[J

line 914: " MOF = WMI (Windows Management Instrumentation) Managed Object Format[J

line 915: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl[J

line 916: [J

line 917: " Icewm menu[J

line 918: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu[J

line 919: [J

line 920: " Indent profile (must come before IDL *.pro!)[J

line 921: au BufNewFile,BufRead .indent.pro^I^Isetf indent[J

line 922: au BufNewFile,BufRead indent.pro^I^Icall dist#ft#ProtoCheck('indent')[J

line 923: [J

line 924: " IDL (Interactive Data Language)[J

line 925: au BufNewFile,BufRead *.pro^I^I^Icall dist#ft#ProtoCheck('idlang')[J

line 926: [J

line 927: " Indent RC[J

line 928: au BufNewFile,BufRead indentrc^I^I^Isetf indent[J

line 929: [J

line 930: " Inform[J

line 931: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform[J

line 932: [J

line 933: " Initng[J

line 934: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng[J

line 935: [J

line 936: " Innovation Data Processing[J

line 937: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c^Isetf upstreamdat[J

line 938: au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c^Isetf upstreamlog[J

line 939: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog[J

line 940: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c^Isetf usserverlog[J

line 941: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c^Isetf usw2kagtlog[J

line 942: [J

line 943: " Ipfilter[J

line 944: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter[J

line 945: [J

line 946: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)[J

line 947: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl[J

line 948: [J

line 949: " .INI file for MSDOS[J

line 950: au BufNewFile,BufRead *.ini^I^I^Isetf dosini[J

line 951: [J

line 952: " SysV Inittab[J

line 953: au BufNewFile,BufRead inittab^I^I^Isetf inittab[J

line 954: [J

line 955: " Inno Setup[J

line 956: au BufNewFile,BufRead *.iss^I^I^Isetf iss[J

line 957: [J

line 958: " J[J

line 959: au BufNewFile,BufRead *.ijs^I^I^Isetf j[J

line 960: [J

line 961: " JAL[J

line 962: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal[J

line 963: [J

line 964: " Jam[J

line 965: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam[J

line 966: [J

line 967: " Java[J

line 968: au BufNewFile,BufRead *.java,*.jav^I^Isetf java[J

line 969: [J

line 970: " JavaCC[J

line 971: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc[J

line 972: [J

line 973: " JavaScript, ECMAScript, ES module script, CommonJS script[J

line 974: au BufNewFile,BufRead *.js,*.jsm,*.javascript,*.es,*.mjs,*.cjs   setf javascript[J

line 975: [J

line 976: " JavaScript with React[J

line 977: au BufNewFile,BufRead *.jsx^I^I^Isetf javascriptreact[J

line 978: [J

line 979: " Java Server Pages[J

line 980: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp[J

line 981: [J

line 982: " Java Properties resource file (note: doesn't catch font.properties.pl)[J

line 983: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties[J

line 984: " Eclipse preference files use Java Properties syntax[J

line 985: au BufNewFile,BufRead org.eclipse.*.prefs^Isetf jproperties[J

line 986: [J

line 987: " Jess[J

line 988: au BufNewFile,BufRead *.clp^I^I^Isetf jess[J

line 989: [J

line 990: " Jgraph[J

line 991: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph[J

line 992: [J

line 993: " Jovial[J

line 994: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial[J

line 995: [J

line 996: " JSON[J

line 997: au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest^Isetf json[J

line 998: [J

line 999: " JSON5[J

line 1000: au BufNewFile,BufRead *.json5^I^I^Isetf json5[J

line 1001: [J

line 1002: " JSON Patch (RFC 6902)[J

line 1003: au BufNewFile,BufRead *.json-patch^I^I^Isetf json[J

line 1004: [J

line 1005: " Jupyter Notebook is also json[J

line 1006: au BufNewFile,BufRead *.ipynb^I^I^I^Isetf json[J

line 1007: [J

line 1008: " Other files that look like json[J

line 1009: au BufNewFile,BufRead .babelrc,.eslintrc,.prettierrc,.firebaserc  setf json[J

line 1010: [J

line 1011: " JSONC[J

line 1012: au BufNewFile,BufRead *.jsonc^I^I^Isetf jsonc[J

line 1013: [J

line 1014: " Jsonnet[J

line 1015: au BufNewFile,BufRead *.jsonnet,*.libsonnet^Isetf jsonnet[J

line 1016: [J

line 1017: " Julia[J

line 1018: au BufNewFile,BufRead *.jl^I^I^Isetf julia[J

line 1019: [J

line 1020: " Kixtart[J

line 1021: au BufNewFile,BufRead *.kix^I^I^Isetf kix[J

line 1022: [J

line 1023: " Kuka Robot Language[J

line 1024: au BufNewFile,BufRead *.src\c^I^I^Icall dist#ft#FTsrc()[J

line 1025: au BufNewFile,BufRead *.dat\c^I^I^Icall dist#ft#FTdat()[J

line 1026: au BufNewFile,BufRead *.sub\c^I^I^Isetf krl[J

line 1027: [J

line 1028: " Kimwitu[++][J

line 1029: au BufNewFile,BufRead *.k^I^I^Isetf kwt[J

line 1030: [J

line 1031: " Kivy[J

line 1032: au BufNewFile,BufRead *.kv^I^I^Isetf kivy[J

line 1033: [J

line 1034: " Kotlin[J

line 1035: au BufNewFile,BufRead *.kt,*.ktm,*.kts^I^Isetf kotlin[J

line 1036: [J

line 1037: " KDE script[J

line 1038: au BufNewFile,BufRead *.ks^I^I^Isetf kscript[J

line 1039: [J

line 1040: " Kconfig[J

line 1041: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig[J

line 1042: [J

line 1043: " Lace (ISE)[J

line 1044: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace[J

line 1045: [J

line 1046: " Larch Shared Language[J

line 1047: au BufNewFile,BufRead .lsl^I^I^Icall dist#ft#FTlsl()[J

line 1048: [J

line 1049: " Latexmkrc[J

line 1050: au BufNewFile,BufRead .latexmkrc,latexmkrc^Isetf perl[J

line 1051: [J

line 1052: " Latte[J

line 1053: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte[J

line 1054: [J

line 1055: " Limits[J

line 1056: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits[J

line 1057: [J

line 1058: " LambdaProlog or SML (see dist#ft#FTmod for *.mod)[J

line 1059: au BufNewFile,BufRead *.sig^I^I^Icall dist#ft#FTsig()[J

line 1060: [J

line 1061: " LDAP LDIF[J

line 1062: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif[J

line 1063: [J

line 1064: " Ld loader[J

line 1065: au BufNewFile,BufRead *.ld^I^I^Isetf ld[J

line 1066: [J

line 1067: " Ledger[J

line 1068: au BufRead,BufNewFile *.ldg,*.ledger,*.journal^I^I^Isetf ledger[J

line 1069: [J

line 1070: " Less[J

line 1071: au BufNewFile,BufRead *.less^I^I^Isetf less[J

line 1072: [J

line 1073: " Lex[J

line 1074: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex[J

line 1075: [J

line 1076: " Libao[J

line 1077: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao[J

line 1078: [J

line 1079: " Libsensors[J

line 1080: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors[J

line 1081: [J

line 1082: " LFTP[J

line 1083: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp[J

line 1084: [J

line 1085: " Lifelines (or Lex for C++!)[J

line 1086: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines[J

line 1087: [J

line 1088: " Lilo: Linux loader[J

line 1089: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo[J

line 1090: [J

line 1091: " Lilypond[J

line 1092: au BufNewFile,BufRead *.ly,*.ily^I^Isetf lilypond[J

line 1093: [J

line 1094: " Lisp (*.el = ELisp, *.cl = Common Lisp)[J

line 1095: " *.jl was removed, it's also used for Julia, better skip than guess wrong.[J

line 1096: if has("fname_case")[J

line 1097:   au BufNewFile,BufRead *.lsp,*.lisp,*.asd,*.el,*.cl,*.L,.emacs,.sawfishrc setf lisp[J

line 1098: else[J

line 1099:   au BufNewFile,BufRead *.lsp,*.lisp,*.asd,*.el,*.cl,.emacs,.sawfishrc setf lisp[J

line 1100: endif[J

line 1101: [J

line 1102: " SBCL implementation of Common Lisp[J

line 1103: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp[J

line 1104: [J

line 1105: " Liquid[J

line 1106: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid[J

line 1107: [J

line 1108: " Lite[J

line 1109: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite[J

line 1110: [J

line 1111: " LiteStep RC files[J

line 1112: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep[J

line 1113: [J

line 1114: " Login access[J

line 1115: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess[J

line 1116: [J

line 1117: " Login defs[J

line 1118: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs[J

line 1119: [J

line 1120: " Logtalk[J

line 1121: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk[J

line 1122: [J

line 1123: " LOTOS[J

line 1124: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos[J

line 1125: [J

line 1126: " Lout (also: *.lt)[J

line 1127: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout[J

line 1128: [J

line 1129: " Lua[J

line 1130: au BufNewFile,BufRead *.lua^I^I^Isetf lua[J

line 1131: [J

line 1132: " Luacheck[J

line 1133: au BufNewFile,BufRead .luacheckrc^I^Isetf lua[J

line 1134: [J

line 1135: " Luarocks[J

line 1136: au BufNewFile,BufRead *.rockspec^I^Isetf lua[J

line 1137: [J

line 1138: " Linden Scripting Language (Second Life)[J

line 1139: au BufNewFile,BufRead *.lsl^I^I^Icall dist#ft#FTlsl()[J

line 1140: [J

line 1141: " Lynx style file (or LotusScript!)[J

line 1142: au BufNewFile,BufRead *.lss^I^I^Isetf lss[J

line 1143: [J

line 1144: " M4[J

line 1145: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif[J

line 1147: [J

line 1148: " MaGic Point[J

line 1149: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp[J

line 1150: [J

line 1151: " Mail (for Elm, trn, mutt, muttng, rn, slrn, neomutt)[J

line 1152: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail[J

line 1153: [J

line 1154: " Mail aliases[J

line 1155: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases[J

line 1156: [J

line 1157: " Mailcap configuration file[J

line 1158: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap[J

line 1159: [J

line 1160: " Makefile[J

line 1161: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make[J

line 1162: [J

line 1163: " MakeIndex[J

line 1164: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist[J

line 1165: [J

line 1166: " Mallard[J

line 1167: au BufNewFile,BufRead *.page^I^I^Isetf mallard[J

line 1168: [J

line 1169: " Manpage[J

line 1170: au BufNewFile,BufRead *.man^I^I^Isetf man[J

line 1171: [J

line 1172: " Man config[J

line 1173: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf[J

line 1174: [J

line 1175: " Maple V[J

line 1176: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple[J

line 1177: [J

line 1178: " Map (UMN mapserver config file)[J

line 1179: au BufNewFile,BufRead *.map^I^I^Isetf map[J

line 1180: [J

line 1181: " Markdown[J

line 1182: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown[J

line 1183: [J

line 1184: " Mason[J

line 1185: au BufNewFile,BufRead *.mason,*.mhtml,*.comp^Isetf mason[J

line 1186: [J

line 1187: " Mathematica, Matlab, Murphi, Objective C or Octave[J

line 1188: au BufNewFile,BufRead *.m^I^I^Icall dist#ft#FTm()[J

line 1189: [J

line 1190: " Mathematica notebook[J

line 1191: au BufNewFile,BufRead *.nb^I^I^Isetf mma[J

line 1192: [J

line 1193: " Maya Extension Language[J

line 1194: au BufNewFile,BufRead *.mel^I^I^Isetf mel[J

line 1195: [J

line 1196: " Mercurial (hg) commit file[J

line 1197: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit[J

line 1198: [J

line 1199: " Mercurial config (looks like generic config file)[J

line 1200: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg[J

line 1201: [J

line 1202: " Mermaid[J

line 1203: au BufNewFile,BufRead *.mmd,*.mmdc,*.mermaid^Isetf mermaid[J

line 1204: [J

line 1205: " Meson Build system config[J

line 1206: au BufNewFile,BufRead meson.build,meson_options.txt setf meson[J

line 1207: au BufNewFile,BufRead *.wrap^I^I^Isetf dosini[J

line 1208: [J

line 1209: " Messages (logs mostly)[J

line 1210: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages[J

line 1211: [J

line 1212: " Metafont[J

line 1213: au BufNewFile,BufRead *.mf^I^I^Isetf mf[J

line 1214: [J

line 1215: " MetaPost[J

line 1216: au BufNewFile,BufRead *.mp^I^I^Isetf mp[J

line 1217: au BufNewFile,BufRead *.mpxl,*.mpiv,*.mpvi^Ilet b:mp_metafun = 1 | setf mp[J

line 1218: [J

line 1219: " MGL[J

line 1220: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl[J

line 1221: [J

line 1222: " MIX - Knuth assembly[J

line 1223: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix[J

line 1224: [J

line 1225: " MMIX or VMS makefile[J

line 1226: au BufNewFile,BufRead *.mms^I^I^Icall dist#ft#FTmms()[J

line 1227: [J

line 1228: " Symbian meta-makefile definition (MMP)[J

line 1229: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp[J

line 1230: [J

line 1231: " ABB Rapid, Modula-2, Modsim III or LambdaProlog[J

line 1232: au BufNewFile,BufRead *.mod\c^I^I^Icall dist#ft#FTmod()[J

line 1233: [J

line 1234: " Modula-2  (.md removed in favor of Markdown, see dist#ft#FTmod for *.MOD)[J

line 1235: au BufNewFile,BufRead *.m2,*.DEF,*.mi^I^Isetf modula2[J

line 1236: [J

line 1237: " Modula-3 (.m3, .i3, .mg, .ig)[J

line 1238: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3[J

line 1239: [J

line 1240: " Larch/Modula-3[J

line 1241: au BufNewFile,BufRead *.lm3^I^I^Isetf modula3[J

line 1242: [J

line 1243: " Monk[J

line 1244: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk[J

line 1245: [J

line 1246: " MOO[J

line 1247: au BufNewFile,BufRead *.moo^I^I^Isetf moo[J

line 1248: [J

line 1249: " Moonscript[J

line 1250: au BufNewFile,BufRead *.moon^I^I^Isetf moonscript[J

line 1251: [J

line 1252: " Modconf[J

line 1253: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf[J

line 1254: [J

line 1255: " MPD is based on XML[J

line 1256: au BufNewFile,BufRead *.mpd^I^I^Isetf xml[J

line 1257: [J

line 1258: " Mplayer config[J

line 1259: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf[J

line 1260: [J

line 1261: " Motorola S record[J

line 1262: au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec^Isetf srec[J

line 1263: [J

line 1264: " Mrxvtrc[J

line 1265: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc[J

line 1266: [J

line 1267: " Msql[J

line 1268: au BufNewFile,BufRead *.msql^I^I^Isetf msql[J

line 1269: [J

line 1270: " Mysql[J

line 1271: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql[J

line 1272: [J

line 1273: " Tcl Shell RC file[J

line 1274: au BufNewFile,BufRead tclsh.rc^I^I^Isetf tcl[J

line 1275: [J

line 1276: " M$ Resource files[J

line 1277: " /etc/Muttrc.d/file.rc is muttrc[J

line 1278: au BufNewFile,BufRead *.rc,*.rch if expand("<afile>") !~ "/etc/Muttrc.d/" |   setf rc | endif[J

line 1282: [J

line 1283: " MuPAD source[J

line 1284: au BufRead,BufNewFile *.mu^I^I^Isetf mupad[J

line 1285: [J

line 1286: " Mush[J

line 1287: au BufNewFile,BufRead *.mush^I^I^Isetf mush[J

line 1288: [J

line 1289: " Mutt setup file (also for Muttng)[J

line 1290: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc[J

line 1291: [J

line 1292: " N1QL[J

line 1293: au BufRead,BufNewfile *.n1ql,*.nql^I^Isetf n1ql[J

line 1294: [J

line 1295: " Nano[J

line 1296: au BufNewFile,BufRead */etc/nanorc,*.nanorc^Isetf nanorc[J

line 1297: [J

line 1298: " Nastran input/DMAP[J

line 1299: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran[J

line 1300: [J

line 1301: " Natural[J

line 1302: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural[J

line 1303: [J

line 1304: " Noemutt setup file[J

line 1305: au BufNewFile,BufRead Neomuttrc^I^I^Isetf neomuttrc[J

line 1306: [J

line 1307: " Netrc[J

line 1308: au BufNewFile,BufRead .netrc^I^I^Isetf netrc[J

line 1309: [J

line 1310: " Nginx[J

line 1311: au BufNewFile,BufRead *.nginx,nginx*.conf,*nginx.conf,*/etc/nginx/*,*/usr/local/nginx/conf/*,*/nginx/*.conf^I^I^Isetf nginx[J

line 1312: [J

line 1313: " Nim file[J

line 1314: au BufNewFile,BufRead *.nim,*.nims,*.nimble^Isetf nim[J

line 1315: [J

line 1316: " Ninja file[J

line 1317: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja[J

line 1318: [J

line 1319: " Nix[J

line 1320: au BufRead,BufNewFile *.nix^I^I^Isetf nix[J

line 1321: [J

line 1322: " NPM RC file[J

line 1323: au BufNewFile,BufRead npmrc,.npmrc^I^Isetf dosini[J

line 1324: [J

line 1325: " Novell netware batch files[J

line 1326: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf[J

line 1327: [J

line 1328: " Nroff/Troff (*.ms and *.t are checked below)[J

line 1329: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif[J

line 1333: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff[J

line 1334: au BufNewFile,BufRead *.[1-9]^I^I^Icall dist#ft#FTnroff()[J

line 1335: [J

line 1336: " Nroff or Objective C++[J

line 1337: au BufNewFile,BufRead *.mm^I^I^Icall dist#ft#FTmm()[J

line 1338: [J

line 1339: " Not Quite C[J

line 1340: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc[J

line 1341: [J

line 1342: " NSE - Nmap Script Engine - uses Lua syntax[J

line 1343: au BufNewFile,BufRead *.nse^I^I^Isetf lua[J

line 1344: [J

line 1345: " NSIS[J

line 1346: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis[J

line 1347: [J

line 1348: " Oblivion Language and Oblivion Script Extender[J

line 1349: au BufNewFile,BufRead *.obl,*.obse,*.oblivion,*.obscript  setf obse[J

line 1350: [J

line 1351: " OCaml[J

line 1352: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit,*.mlt,*.mlp,*.mlip,*.mli.cppo,*.ml.cppo setf ocaml[J

line 1353: [J

line 1354: " Occam[J

line 1355: au BufNewFile,BufRead *.occ^I^I^Isetf occam[J

line 1356: [J

line 1357: " Octave[J

line 1358: au BufNewFile,BufRead octave.conf,.octaverc,octaverc^Isetf octave[J

line 1359: [J

line 1360: " Omnimark[J

line 1361: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark[J

line 1362: [J

line 1363: " OPAM[J

line 1364: au BufNewFile,BufRead opam,*.opam,*.opam.template setf opam[J

line 1365: [J

line 1366: " OpenFOAM[J

line 1367: au BufNewFile,BufRead [a-zA-Z0-9]*Dict\(.*\)\=,[a-zA-Z]*Properties\(.*\)\=,*Transport\(.*\),fvSchemes,fvSolution,fvConstrains,fvModels,*/constant/g,*/0\(\.orig\)\=/* call dist#ft#FTfoam()[J

line 1368: [J

line 1369: " OpenROAD[J

line 1370: au BufNewFile,BufRead *.or^I^I^I^Isetf openroad[J

line 1371: [J

line 1372: " OPL[J

line 1373: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^I^Isetf opl[J

line 1374: [J

line 1375: " OpenSCAD[J

line 1376: au BufNewFile,BufRead *.scad^I^I^I^Isetf openscad[J

line 1377: [J

line 1378: " Oracle config file[J

line 1379: au BufNewFile,BufRead *.ora^I^I^I^Isetf ora[J

line 1380: [J

line 1381: " Org[J

line 1382: au BufNewFile,BufRead *.org,*.org_archive^I^Isetf org[J

line 1383: [J

line 1384: " Packet filter conf[J

line 1385: au BufNewFile,BufRead pf.conf^I^I^I^Isetf pf[J

line 1386: [J

line 1387: " ini style config files, using # comments[J

line 1388: au BufNewFile,BufRead */etc/pacman.conf,mpv.conf^Isetf confini[J

line 1389: au BufNewFile,BufRead */.aws/config,*/.aws/credentials^Isetf confini[J

line 1390: [J

line 1391: " Pacman hooks[J

line 1392: au BufNewFile,BufRead *.hook if getline(1) == '[Trigger]' |   setf conf | endif[J

line 1396: [J

line 1397: " Pam conf[J

line 1398: au BufNewFile,BufRead */etc/pam.conf^I^I^Isetf pamconf[J

line 1399: [J

line 1400: " Pam environment[J

line 1401: au BufNewFile,BufRead pam_env.conf,.pam_environment^Isetf pamenv[J

line 1402: [J

line 1403: " PApp[J

line 1404: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^I^Isetf papp[J

line 1405: [J

line 1406: " Password file[J

line 1407: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd[J

line 1408: [J

line 1409: " Pascal (also *.p, *.pp, *.inc)[J

line 1410: au BufNewFile,BufRead *.pas^I^I^I^Isetf pascal[J

line 1411: [J

line 1412: " Pascal or Puppet manifest[J

line 1413: au BufNewFile,BufRead *.pp^I^I^I^Icall dist#ft#FTpp()[J

line 1414: [J

line 1415: " Delphi or Lazarus program file[J

line 1416: au BufNewFile,BufRead *.dpr,*.lpr^I^I^Isetf pascal[J

line 1417: [J

line 1418: " Free Pascal makefile definition file[J

line 1419: au BufNewFile,BufRead *.fpc^I^I^I^Isetf fpcmake[J

line 1420: [J

line 1421: " Path of Exile item filter[J

line 1422: au BufNewFile,BufRead *.filter^I^I^I^Isetf poefilter[J

line 1423: [J

line 1424: " PDF[J

line 1425: au BufNewFile,BufRead *.pdf^I^I^I^Isetf pdf[J

line 1426: [J

line 1427: " PCMK - HAE - crm configure edit[J

line 1428: au BufNewFile,BufRead *.pcmk^I^I^I^Isetf pcmk[J

line 1429: [J

line 1430: " Perl[J

line 1431: if has("fname_case")[J

line 1432:   au BufNewFile,BufRead *.pl,*.PL^I^I^Icall dist#ft#FTpl()[J

line 1433: else[J

line 1434:   au BufNewFile,BufRead *.pl^I^I^I^Icall dist#ft#FTpl()[J

line 1435: endif[J

line 1436: au BufNewFile,BufRead *.plx,*.al,*.psgi^I^I^Isetf perl[J

line 1437: [J

line 1438: " Perl, XPM or XPM2[J

line 1439: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif[J

line 1447: [J

line 1448: " Perl POD[J

line 1449: au BufNewFile,BufRead *.pod^I^I^Isetf pod[J

line 1450: [J

line 1451: " Php, php3, php4, etc.[J

line 1452: " Also Phtml (was used for PHP 2 in the past).[J

line 1453: " Also .ctp for Cake template file.[J

line 1454: " Also .phpt for php tests.[J

line 1455: " Also .theme for Drupal theme files.[J

line 1456: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp,*.phpt,*.theme^Isetf php[J

line 1457: [J

line 1458: " PHP config[J

line 1459: au BufNewFile,BufRead php.ini-*^I^I^Isetf dosini[J

line 1460: [J

line 1461: " Pike and Cmod[J

line 1462: au BufNewFile,BufRead *.pike,*.pmod^I^Isetf pike[J

line 1463: au BufNewFile,BufRead *.cmod^I^I^Isetf cmod[J

line 1464: [J

line 1465: " Pinfo config[J

line 1466: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo[J

line 1467: [J

line 1468: " Palm Resource compiler[J

line 1469: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc[J

line 1470: [J

line 1471: " Pine config[J

line 1472: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine[J

line 1473: [J

line 1474: " Pipenv Pipfiles[J

line 1475: au BufNewFile,BufRead Pipfile^I^I^Isetf toml[J

line 1476: au BufNewFile,BufRead Pipfile.lock^I^Isetf json[J

line 1477: [J

line 1478: " PL/1, PL/I[J

line 1479: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli[J

line 1480: [J

line 1481: " PL/M (also: *.inp)[J

line 1482: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm[J

line 1483: [J

line 1484: " PL/SQL[J

line 1485: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql[J

line 1486: [J

line 1487: " PLP[J

line 1488: au BufNewFile,BufRead *.plp^I^I^Isetf plp[J

line 1489: [J

line 1490: " PO and PO template (GNU gettext)[J

line 1491: au BufNewFile,BufRead *.po,*.pot^I^Isetf po[J

line 1492: [J

line 1493: " Postfix main config[J

line 1494: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain[J

line 1495: [J

line 1496: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)[J

line 1497: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr[J

line 1498: [J

line 1499: " PostScript Printer Description[J

line 1500: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd[J

line 1501: [J

line 1502: " Povray[J

line 1503: au BufNewFile,BufRead *.pov^I^I^Isetf pov[J

line 1504: [J

line 1505: " Povray configuration[J

line 1506: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini[J

line 1507: [J

line 1508: " Povray, Pascal, PHP or assembly[J

line 1509: au BufNewFile,BufRead *.inc^I^I^Icall dist#ft#FTinc()[J

line 1510: [J

line 1511: " PowerShell[J

line 1512: au BufNewFile,BufRead^I*.ps1,*.psd1,*.psm1,*.pssc^Isetf ps1[J

line 1513: au BufNewFile,BufRead^I*.ps1xml^I^I^Isetf ps1xml[J

line 1514: au BufNewFile,BufRead^I*.cdxml,*.psc1^I^I^Isetf xml[J

line 1515: [J

line 1516: " Printcap and Termcap[J

line 1517: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap[J

line 1519: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap[J

line 1521: [J

line 1522: " Prisma[J

line 1523: au BufRead,BufNewFile *.prisma^I^I^Isetf prisma[J

line 1524: [J

line 1525: " PCCTS / ANTLR[J

line 1526: "au BufNewFile,BufRead *.g^I^I^Isetf antlr[J

line 1527: au BufNewFile,BufRead *.g^I^I^Isetf pccts[J

line 1528: [J

line 1529: " PPWizard[J

line 1530: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz[J

line 1531: [J

line 1532: " Pug[J

line 1533: au BufRead,BufNewFile *.pug^I^I^Isetf pug[J

line 1534: [J

line 1535: " Puppet[J

line 1536: au BufNewFile,BufRead Puppetfile^I^Isetf ruby[J

line 1537: [J

line 1538: " Embedded Puppet[J

line 1539: au BufNewFile,BufRead *.epp^I^I^Isetf epuppet[J

line 1540: [J

line 1541: " Obj 3D file format[J

line 1542: " TODO: is there a way to avoid MS-Windows Object files?[J

line 1543: au BufNewFile,BufRead *.obj^I^I^Isetf obj[J

line 1544: [J

line 1545: " Oracle Pro*C/C++[J

line 1546: au BufNewFile,BufRead *.pc^I^I^Isetf proc[J

line 1547: [J

line 1548: " Privoxy actions file[J

line 1549: au BufNewFile,BufRead *.action^I^I^Isetf privoxy[J

line 1550: [J

line 1551: " Procmail[J

line 1552: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail[J

line 1553: [J

line 1554: " Progress or CWEB[J

line 1555: au BufNewFile,BufRead *.w^I^I^Icall dist#ft#FTprogress_cweb()[J

line 1556: [J

line 1557: " Progress or assembly[J

line 1558: au BufNewFile,BufRead *.i^I^I^Icall dist#ft#FTprogress_asm()[J

line 1559: [J

line 1560: " Progress or Pascal[J

line 1561: au BufNewFile,BufRead *.p^I^I^Icall dist#ft#FTprogress_pascal()[J

line 1562: [J

line 1563: " Software Distributor Product Specification File (POSIX 1387.2-1995)[J

line 1564: au BufNewFile,BufRead *.psf^I^I^Isetf psf[J

line 1565: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif[J

line 1569: [J

line 1570: " Prolog[J

line 1571: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog[J

line 1572: [J

line 1573: " Promela[J

line 1574: au BufNewFile,BufRead *.pml^I^I^Isetf promela[J

line 1575: [J

line 1576: " Property Specification Language (PSL)[J

line 1577: au BufNewFile,BufRead *.psl^I^I^Isetf psl[J

line 1578: [J

line 1579: " Google protocol buffers[J

line 1580: au BufNewFile,BufRead *.proto^I^I^Isetf proto[J

line 1581: au BufNewFile,BufRead *.pbtxt^I^I^Isetf pbtxt[J

line 1582: [J

line 1583: " Poke[J

line 1584: au BufNewFile,BufRead *.pk^I^I^Isetf poke[J

line 1585: [J

line 1586: " Protocols[J

line 1587: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols[J

line 1588: [J

line 1589: " Pyret[J

line 1590: au BufNewFile,BufRead *.arr^I^I^Isetf pyret[J

line 1591: [J

line 1592: " Pyrex[J

line 1593: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex[J

line 1594: [J

line 1595: " Python, Python Shell Startup and Python Stub Files[J

line 1596: " Quixote (Python-based web framework)[J

line 1597: au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc  setf python[J

line 1598: au BufNewFile,BufRead *.ptl,*.pyi,SConstruct^I^I   setf python[J

line 1599: [J

line 1600: " QL[J

line 1601: au BufRead,BufNewFile *.ql,*.qll^I^Isetf ql[J

line 1602: [J

line 1603: " Quarto[J

line 1604: au BufRead,BufNewFile *.qmd     setf quarto[J

line 1605: [J

line 1606: " Radiance[J

line 1607: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance[J

line 1608: [J

line 1609: " Raku (formerly Perl6)[J

line 1610: au BufNewFile,BufRead *.pm6,*.p6,*.t6,*.pod6,*.raku,*.rakumod,*.rakudoc,*.rakutest  setf raku[J

line 1611: [J

line 1612: " Ratpoison config/command files[J

line 1613: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison[J

line 1614: [J

line 1615: " RCS file[J

line 1616: au BufNewFile,BufRead *\,v^I^I^Isetf rcs[J

line 1617: [J

line 1618: " Readline[J

line 1619: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline[J

line 1620: [J

line 1621: " Registry for MS-Windows[J

line 1622: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif[J

line 1624: [J

line 1625: " Renderman Interface Bytestream[J

line 1626: au BufNewFile,BufRead *.rib^I^I^Isetf rib[J

line 1627: [J

line 1628: " Rego Policy Language[J

line 1629: au BufNewFile,BufRead *.rego^I^I^Isetf rego[J

line 1630: [J

line 1631: " Rexx[J

line 1632: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx[J

line 1633: [J

line 1634: " R Help file[J

line 1635: if has("fname_case")[J

line 1636:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp[J

line 1637: else[J

line 1638:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp[J

line 1639: endif[J

line 1640: [J

line 1641: " R noweb file[J

line 1642: if has("fname_case")[J

line 1643:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb[J

line 1644: else[J

line 1645:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb[J

line 1646: endif[J

line 1647: [J

line 1648: " R Markdown file[J

line 1649: if has("fname_case")[J

line 1650:   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd^I^Isetf rmd[J

line 1651: else[J

line 1652:   au BufNewFile,BufRead *.rmd,*.smd^I^I^Isetf rmd[J

line 1653: endif[J

line 1654: [J

line 1655: " R profile file[J

line 1656: au BufNewFile,BufRead .Rprofile,Rprofile,Rprofile.site^Isetf r[J

line 1657: [J

line 1658: " RSS looks like XML[J

line 1659: au BufNewFile,BufRead *.rss^I^I^I^Isetf xml[J

line 1660: [J

line 1661: " R reStructuredText file[J

line 1662: if has("fname_case")[J

line 1663:   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst^Isetf rrst[J

line 1664: else[J

line 1665:   au BufNewFile,BufRead *.rrst,*.srst^I^I^Isetf rrst[J

line 1666: endif[J

line 1667: [J

line 1668: " Rexx, Rebol or R[J

line 1669: au BufNewFile,BufRead *.r,*.R^I^I^I^Icall dist#ft#FTr()[J

line 1670: [J

line 1671: " Remind[J

line 1672: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind[J

line 1673: [J

line 1674: " ReScript[J

line 1675: au BufNewFile,BufRead *.res,*.resi^I^I^Isetf rescript[J

line 1676: [J

line 1677: " Resolv.conf[J

line 1678: au BufNewFile,BufRead resolv.conf^I^Isetf resolv[J

line 1679: [J

line 1680: " Relax NG Compact[J

line 1681: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc[J

line 1682: [J

line 1683: " Relax NG XML[J

line 1684: au BufNewFile,BufRead *.rng^I^I^Isetf rng[J

line 1685: [J

line 1686: " RPL/2[J

line 1687: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl[J

line 1688: [J

line 1689: " Robot Framework[J

line 1690: au BufNewFile,BufRead *.robot,*.resource^Isetf robot[J

line 1691: [J

line 1692: " Robots.txt[J

line 1693: au BufNewFile,BufRead robots.txt^I^Isetf robots[J

line 1694: [J

line 1695: " Rpcgen[J

line 1696: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen[J

line 1697: [J

line 1698: " MikroTik RouterOS script[J

line 1699: au BufRead,BufNewFile *.rsc^I^I^Isetf routeros[J

line 1700: [J

line 1701: " reStructuredText Documentation Format[J

line 1702: au BufNewFile,BufRead *.rst^I^I^Isetf rst[J

line 1703: [J

line 1704: " RTF[J

line 1705: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf[J

line 1706: [J

line 1707: " Interactive Ruby shell[J

line 1708: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby[J

line 1709: [J

line 1710: " Ruby[J

line 1711: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby[J

line 1712: [J

line 1713: " RubyGems[J

line 1714: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby[J

line 1715: [J

line 1716: " RBS (Ruby Signature)[J

line 1717: au BufNewFile,BufRead *.rbs^I^I^Isetf rbs[J

line 1718: [J

line 1719: " Rackup[J

line 1720: au BufNewFile,BufRead *.ru^I^I^Isetf ruby[J

line 1721: [J

line 1722: " Bundler[J

line 1723: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby[J

line 1724: [J

line 1725: " Ruby on Rails[J

line 1726: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby[J

line 1727: [J

line 1728: " Rantfile and Rakefile is like Ruby[J

line 1729: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby[J

line 1730: [J

line 1731: " Rust[J

line 1732: au BufNewFile,BufRead *.rs^I^I^Isetf rust[J

line 1733: au BufNewFile,BufRead Cargo.lock,*/.cargo/config,*/.cargo/credentials^Isetf toml[J

line 1734: [J

line 1735: " S-lang (or shader language, or SmallLisp)[J

line 1736: au BufNewFile,BufRead *.sl^I^I^Isetf slang[J

line 1737: [J

line 1738: " Samba config[J

line 1739: au BufNewFile,BufRead smb.conf^I^I^Isetf samba[J

line 1740: [J

line 1741: " SAS script[J

line 1742: au BufNewFile,BufRead *.sas^I^I^Isetf sas[J

line 1743: [J

line 1744: " Sass[J

line 1745: au BufNewFile,BufRead *.sass^I^I^Isetf sass[J

line 1746: [J

line 1747: " Sather[J

line 1748: au BufNewFile,BufRead *.sa^I^I^Isetf sather[J

line 1749: [J

line 1750: " Scala[J

line 1751: au BufNewFile,BufRead *.scala^I^I^Isetf scala[J

line 1752: [J

line 1753: " SBT - Scala Build Tool[J

line 1754: au BufNewFile,BufRead *.sbt^I^I^Isetf sbt[J

line 1755: [J

line 1756: " SuperCollider[J

line 1757: au BufNewFile,BufRead *.sc^I^I^Icall dist#ft#FTsc()[J

line 1758: [J

line 1759: au BufNewFile,BufRead *.quark^I^I^Isetf supercollider[J

line 1760: [J

line 1761: " scdoc[J

line 1762: au BufNewFile,BufRead *.scd^I^I^Icall dist#ft#FTscd()[J

line 1763: [J

line 1764: " Scilab[J

line 1765: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab[J

line 1766: [J

line 1767: [J

line 1768: " SCSS[J

line 1769: au BufNewFile,BufRead *.scss^I^I^Isetf scss[J

line 1770: [J

line 1771: " SD: Streaming Descriptors[J

line 1772: au BufNewFile,BufRead *.sd^I^I^Isetf sd[J

line 1773: [J

line 1774: " SDL[J

line 1775: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl[J

line 1776: [J

line 1777: " sed[J

line 1778: au BufNewFile,BufRead *.sed^I^I^Isetf sed[J

line 1779: [J

line 1780: " SubRip[J

line 1781: au BufNewFile,BufRead *.srt^I^I^Isetf srt[J

line 1782: [J

line 1783: " SubStation Alpha[J

line 1784: au BufNewFile,BufRead *.ass,*.ssa^I^Isetf ssa[J

line 1785: [J

line 1786: " svelte[J

line 1787: au BufNewFile,BufRead *.svelte^I^I^Isetf svelte[J

line 1788: [J

line 1789: " Sieve (RFC 3028, 5228)[J

line 1790: au BufNewFile,BufRead *.siv,*.sieve^I^Isetf sieve[J

line 1791: [J

line 1792: " Sendmail[J

line 1793: au BufNewFile,BufRead sendmail.cf^I^Isetf sm[J

line 1794: [J

line 1795: " Sendmail .mc files are actually m4.  Could also be MS Message text file or[J

line 1796: " Maxima.[J

line 1797: au BufNewFile,BufRead *.mc^I^I^Icall dist#ft#McSetf()[J

line 1798: [J

line 1799: " Services[J

line 1800: au BufNewFile,BufRead */etc/services^I^Isetf services[J

line 1801: [J

line 1802: " Service Location config[J

line 1803: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf[J

line 1804: [J

line 1805: " Service Location registration[J

line 1806: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg[J

line 1807: [J

line 1808: " Service Location SPI[J

line 1809: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi[J

line 1810: [J

line 1811: " Setserial config[J

line 1812: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial[J

line 1813: [J

line 1814: " SGML[J

line 1815: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif[J

line 1825: [J

line 1826: " SGMLDECL[J

line 1827: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif[J

line 1831: [J

line 1832: " SGML catalog file[J

line 1833: au BufNewFile,BufRead catalog^I^I^Isetf catalog[J

line 1834: [J

line 1835: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.[J

line 1836: " Gentoo ebuilds, Arch Linux PKGBUILDs and Alpine Linux APKBUILDs are actually[J

line 1837: " bash scripts.[J

line 1838: " NOTE: Patterns ending in a star are further down, these have lower priority.[J

line 1839: au BufNewFile,BufRead .bashrc,bashrc,bash.bashrc,.bash[_-]profile,.bash[_-]logout,.bash[_-]aliases,bash-fc[-.],*.ebuild,*.bash,*.eclass,PKGBUILD,APKBUILD call dist#ft#SetFileTypeSH("bash")[J

line 1840: au BufNewFile,BufRead .kshrc,*.ksh call dist#ft#SetFileTypeSH("ksh")[J

line 1841: au BufNewFile,BufRead */etc/profile,.profile,*.sh,*.env call dist#ft#SetFileTypeSH(getline(1))[J

line 1842: [J

line 1843: " Shell script (Arch Linux) or PHP file (Drupal)[J

line 1844: au BufNewFile,BufRead *.install if getline(1) =~ '<?php' |   setf php | else |   call dist#ft#SetFileTypeSH("bash") | endif[J

line 1850: [J

line 1851: " tcsh scripts (patterns ending in a star further below)[J

line 1852: au BufNewFile,BufRead .tcshrc,*.tcsh,tcsh.tcshrc,tcsh.login^Icall dist#ft#SetFileTypeShell("tcsh")[J

line 1853: [J

line 1854: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)[J

line 1855: " (patterns ending in a start further below)[J

line 1856: au BufNewFile,BufRead .login,.cshrc,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call dist#ft#CSH()[J

line 1857: [J

line 1858: " Zig and Zir (Zig Intermediate Representation)[J

line 1859: au BufNewFile,BufRead *.zig^I^I^Isetf zig[J

line 1860: au BufNewFile,BufRead *.zir^I^I^Isetf zir[J

line 1861: [J

line 1862: " Z-Shell script (patterns ending in a star further below)[J

line 1863: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh[J

line 1864: au BufNewFile,BufRead .zshrc,.zshenv,.zlogin,.zlogout,.zcompdump setf zsh[J

line 1865: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh[J

line 1866: [J

line 1867: " Scheme[J

line 1868: au BufNewFile,BufRead *.scm,*.ss,*.sld,*.rkt,*.rktd,*.rktl^Isetf scheme[J

line 1869: [J

line 1870: " Screen RC[J

line 1871: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen[J

line 1872: [J

line 1873: " Sexplib[J

line 1874: au BufNewFile,BufRead *.sexp setf sexplib[J

line 1875: [J

line 1876: " Simula[J

line 1877: au BufNewFile,BufRead *.sim^I^I^Isetf simula[J

line 1878: [J

line 1879: " SINDA[J

line 1880: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda[J

line 1881: [J

line 1882: " SiSU[J

line 1883: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu[J

line 1884: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu[J

line 1885: [J

line 1886: " SKILL[J

line 1887: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill[J

line 1888: [J

line 1889: " SLRN[J

line 1890: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc[J

line 1891: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc[J

line 1892: [J

line 1893: " Smalltalk[J

line 1894: au BufNewFile,BufRead *.st^I^I^Isetf st[J

line 1895: [J

line 1896: " Smalltalk (and Rexx, TeX, and Visual Basic)[J

line 1897: au BufNewFile,BufRead *.cls^I^I^Icall dist#ft#FTcls()[J

line 1898: [J

line 1899: " Smarty templates[J

line 1900: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty[J

line 1901: [J

line 1902: " SMIL or XML[J

line 1903: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif[J

line 1909: [J

line 1910: " SMIL or SNMP MIB file[J

line 1911: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif[J

line 1917: [J

line 1918: " SMITH[J

line 1919: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith[J

line 1920: [J

line 1921: " Snobol4 and spitbol[J

line 1922: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4[J

line 1923: [J

line 1924: " SNMP MIB files[J

line 1925: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib[J

line 1926: [J

line 1927: " Snort Configuration[J

line 1928: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog[J

line 1929: au BufNewFile,BufRead *.rules^I^I^Icall dist#ft#FTRules()[J

line 1930: [J

line 1931: " Solidity[J

line 1932: au BufRead,BufNewFile *.sol^I^I^Isetf solidity[J

line 1933: [J

line 1934: " SPARQL queries[J

line 1935: au BufNewFile,BufRead *.rq,*.sparql^I^Isetf sparql[J

line 1936: [J

line 1937: " Spec (Linux RPM)[J

line 1938: au BufNewFile,BufRead *.spec^I^I^Isetf spec[J

line 1939: [J

line 1940: " Speedup (AspenTech plant simulator)[J

line 1941: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup[J

line 1942: [J

line 1943: " Slice[J

line 1944: au BufNewFile,BufRead *.ice^I^I^Isetf slice[J

line 1945: [J

line 1946: " Microsoft Visual Studio Solution[J

line 1947: au BufNewFile,BufRead *.sln^I^I^Isetf solution[J

line 1948: au BufNewFile,BufRead *.slnf^I^I^Isetf json[J

line 1949: [J

line 1950: " Spice[J

line 1951: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice[J

line 1952: [J

line 1953: " Spyce[J

line 1954: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce[J

line 1955: [J

line 1956: " Squid[J

line 1957: au BufNewFile,BufRead squid.conf^I^Isetf squid[J

line 1958: [J

line 1959: " SQL for Oracle Designer[J

line 1960: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql[J

line 1961: [J

line 1962: " SQL[J

line 1963: au BufNewFile,BufRead *.sql^I^I^Icall dist#ft#SQL()[J

line 1964: [J

line 1965: " SQLJ[J

line 1966: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj[J

line 1967: [J

line 1968: " SQR[J

line 1969: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr[J

line 1970: [J

line 1971: " Squirrel[J

line 1972: au BufNewFile,BufRead *.nut^I^I^Isetf squirrel[J

line 1973: [J

line 1974: " OpenSSH configuration[J

line 1975: au BufNewFile,BufRead ssh_config,*/.ssh/config,*/.ssh/*.conf^Isetf sshconfig[J

line 1976: au BufNewFile,BufRead */etc/ssh/ssh_config.d/*.conf^I^Isetf sshconfig[J

line 1977: [J

line 1978: " OpenSSH server configuration[J

line 1979: au BufNewFile,BufRead sshd_config^I^I^Isetf sshdconfig[J

line 1980: au BufNewFile,BufRead */etc/ssh/sshd_config.d/*.conf^Isetf sshdconfig[J

line 1981: [J

line 1982: " OpenVPN configuration[J

line 1983: au BufNewFile,BufRead *.ovpn^I^I^Isetf openvpn[J

line 1984: au BufNewFile,BufRead */openvpn/*/*.conf^Isetf openvpn[J

line 1985: [J

line 1986: " Stata[J

line 1987: au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata^Isetf stata[J

line 1988: " Also *.class, but not when it's a Java bytecode file[J

line 1989: au BufNewFile,BufRead *.class if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif[J

line 1991: [J

line 1992: " SMCL[J

line 1993: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl[J

line 1994: [J

line 1995: " Stored Procedures[J

line 1996: au BufNewFile,BufRead *.stp^I^I^Isetf stp[J

line 1997: [J

line 1998: " Standard ML[J

line 1999: au BufNewFile,BufRead *.sml^I^I^Isetf sml[J

line 2000: [J

line 2001: " Sratus VOS command macro[J

line 2002: au BufNewFile,BufRead *.cm^I^I^Isetf voscm[J

line 2003: [J

line 2004: " Swift[J

line 2005: au BufNewFile,BufRead *.swift^I^I^Isetf swift[J

line 2006: au BufNewFile,BufRead *.swift.gyb^I^Isetf swiftgyb[J

line 2007: [J

line 2008: " Swift Intermediate Language or SILE[J

line 2009: au BufNewFile,BufRead *.sil^I^I^Icall dist#ft#FTsil()[J

line 2010: [J

line 2011: " Sysctl[J

line 2012: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl[J

line 2013: [J

line 2014: " Systemd unit files[J

line 2015: au BufNewFile,BufRead */systemd/*.{automount,dnssd,link,mount,netdev,network,nspawn,path,service,slice,socket,swap,target,timer}^Isetf systemd[J

line 2016: " Systemd overrides[J

line 2017: au BufNewFile,BufRead */etc/systemd/*.conf.d/*.conf^Isetf systemd[J

line 2018: au BufNewFile,BufRead */etc/systemd/system/*.d/*.conf^Isetf systemd[J

line 2019: au BufNewFile,BufRead */.config/systemd/user/*.d/*.conf^Isetf systemd[J

line 2020: " Systemd temp files[J

line 2021: au BufNewFile,BufRead */etc/systemd/system/*.d/.#*^Isetf systemd[J

line 2022: au BufNewFile,BufRead */etc/systemd/system/.#*^I^Isetf systemd[J

line 2023: au BufNewFile,BufRead */.config/systemd/user/*.d/.#*^Isetf systemd[J

line 2024: au BufNewFile,BufRead */.config/systemd/user/.#*^Isetf systemd[J

line 2025: [J

line 2026: " Synopsys Design Constraints[J

line 2027: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc[J

line 2028: [J

line 2029: " Sudoers[J

line 2030: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers[J

line 2031: [J

line 2032: " SVG (Scalable Vector Graphics)[J

line 2033: au BufNewFile,BufRead *.svg^I^I^Isetf svg[J

line 2034: [J

line 2035: " Surface[J

line 2036: au BufRead,BufNewFile *.sface^I^I^Isetf surface[J

line 2037: [J

line 2038: " Tads (or Nroff or Perl test file)[J

line 2039: au BufNewFile,BufRead *.t if !dist#ft#FTnroff() && !dist#ft#FTperl() | setf tads | endif[J

line 2041: [J

line 2042: " Tags[J

line 2043: au BufNewFile,BufRead tags^I^I^Isetf tags[J

line 2044: [J

line 2045: " TAK[J

line 2046: au BufNewFile,BufRead *.tak^I^I^Isetf tak[J

line 2047: [J

line 2048: " Task[J

line 2049: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata[J

line 2050: au BufRead,BufNewFile *.task^I^I^Isetf taskedit[J

line 2051: [J

line 2052: " Tcl (JACL too)[J

line 2053: au BufNewFile,BufRead *.tcl,*.tm,*.tk,*.itcl,*.itk,*.jacl,.tclshrc,.wishrc^Isetf tcl[J

line 2054: [J

line 2055: " Teal[J

line 2056: au BufRead,BufNewFile *.tl^I^I^Isetf teal[J

line 2057: [J

line 2058: " TealInfo[J

line 2059: au BufNewFile,BufRead *.tli^I^I^Isetf tli[J

line 2060: [J

line 2061: " Telix Salt[J

line 2062: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt[J

line 2063: [J

line 2064: " Tera Term Language or Turtle[J

line 2065: au BufRead,BufNewFile *.ttl if getline(1) =~ '^@\?\(prefix\|base\)' |   setf turtle | else |   setf teraterm | endif[J

line 2071: [J

line 2072: " Terminfo[J

line 2073: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo[J

line 2074: [J

line 2075: " Terraform variables[J

line 2076: au BufRead,BufNewFile *.tfvars^I^I^Isetf terraform-vars[J

line 2077: [J

line 2078: " TeX[J

line 2079: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex[J

line 2080: au BufNewFile,BufRead *.tex^I^I^Icall dist#ft#FTtex()[J

line 2081: [J

line 2082: " ConTeXt[J

line 2083: au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi,*.mkxl,*.mklx   setf context[J

line 2084: [J

line 2085: " Texinfo[J

line 2086: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo[J

line 2087: [J

line 2088: " TeX configuration[J

line 2089: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf[J

line 2090: [J

line 2091: " Tidy config[J

line 2092: au BufNewFile,BufRead .tidyrc,tidyrc,tidy.conf^Isetf tidy[J

line 2093: [J

line 2094: " TF mud client[J

line 2095: au BufNewFile,BufRead .tfrc,tfrc^I^Isetf tf[J

line 2096: [J

line 2097: " TF mud client or terraform[J

line 2098: au BufNewFile,BufRead *.tf^I^I^Icall dist#ft#FTtf()[J

line 2099: [J

line 2100: " TLA+[J

line 2101: au BufNewFile,BufRead *.tla^I^I^Isetf tla[J

line 2102: [J

line 2103: " tmux configuration[J

line 2104: au BufNewFile,BufRead {.,}tmux*.conf^I^Isetf tmux[J

line 2105: [J

line 2106: " TOML[J

line 2107: au BufNewFile,BufRead *.toml^I^I^Isetf toml[J

line 2108: [J

line 2109: " TPP - Text Presentation Program[J

line 2110: au BufNewFile,BufRead *.tpp^I^I^Isetf tpp[J

line 2111: [J

line 2112: " Treetop[J

line 2113: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop[J

line 2114: [J

line 2115: " Trustees[J

line 2116: au BufNewFile,BufRead trustees.conf^I^Isetf trustees[J

line 2117: [J

line 2118: " TSS - Geometry[J

line 2119: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm[J

line 2120: [J

line 2121: " TSS - Optics[J

line 2122: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop[J

line 2123: [J

line 2124: " TSS - Command Line (temporary)[J

line 2125: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl[J

line 2126: [J

line 2127: " TSV Files[J

line 2128: au BufNewFile,BufRead *.tsv^I^I^Isetf tsv[J

line 2129: [J

line 2130: " TWIG files[J

line 2131: au BufNewFile,BufReadPost *.twig^I^Isetf twig[J

line 2132: [J

line 2133: " TypeScript or Qt translation file (which is XML)[J

line 2134: au BufNewFile,BufReadPost *.ts if getline(1) =~ '<?xml' |   setf xml | else |   setf typescript | endif[J

line 2140: [J

line 2141: " TypeScript module and common[J

line 2142: au BufNewFile,BufRead *.mts,*.cts^I^Isetf typescript[J

line 2143: [J

line 2144: " TypeScript with React[J

line 2145: au BufNewFile,BufRead *.tsx^I^I^Isetf typescriptreact[J

line 2146: [J

line 2147: " Motif UIT/UIL files[J

line 2148: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil[J

line 2149: [J

line 2150: " Udev conf[J

line 2151: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf[J

line 2152: [J

line 2153: " Udev permissions[J

line 2154: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm[J

line 2155: "[J

line 2156: " Udev symlinks config[J

line 2157: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh[J

line 2158: [J

line 2159: " UnrealScript[J

line 2160: au BufNewFile,BufRead *.uc^I^I^Isetf uc[J

line 2161: [J

line 2162: " Updatedb[J

line 2163: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb[J

line 2164: [J

line 2165: " Upstart (init(8)) config files[J

line 2166: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart[J

line 2167: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart[J

line 2168: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart[J

line 2169: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override^I       setf upstart[J

line 2170: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart[J

line 2171: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart[J

line 2172: [J

line 2173: " Vala[J

line 2174: au BufNewFile,BufRead *.vala^I^I^Isetf vala[J

line 2175: [J

line 2176: " VDF[J

line 2177: au BufNewFile,BufRead *.vdf^I^I^Isetf vdf[J

line 2178: [J

line 2179: " VDM[J

line 2180: au BufRead,BufNewFile *.vdmpp,*.vpp^I^Isetf vdmpp[J

line 2181: au BufRead,BufNewFile *.vdmrt^I^I^Isetf vdmrt[J

line 2182: au BufRead,BufNewFile *.vdmsl,*.vdm^I^Isetf vdmsl[J

line 2183: [J

line 2184: " Vera[J

line 2185: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera[J

line 2186: [J

line 2187: " Vagrant (uses Ruby syntax)[J

line 2188: au BufNewFile,BufRead Vagrantfile^I^Isetf ruby[J

line 2189: [J

line 2190: " Verilog HDL[J

line 2191: au BufNewFile,BufRead *.v^I^I^Isetf verilog[J

line 2192: [J

line 2193: " Verilog-AMS HDL[J

line 2194: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams[J

line 2195: [J

line 2196: " SystemVerilog[J

line 2197: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog[J

line 2198: [J

line 2199: " VHS tape[J

line 2200: " .tape is also used by TapeCalc, which we do not support ATM.  If TapeCalc[J

line 2201: " support is needed the contents of the file needs to be inspected.[J

line 2202: au BufNewFile,BufRead *.tape^I^I^Isetf vhs[J

line 2203: [J

line 2204: " VHDL[J

line 2205: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst,*.vho  setf vhdl[J

line 2206: [J

line 2207: " Vim script[J

line 2208: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim[J

line 2209: [J

line 2210: " Viminfo file[J

line 2211: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo[J

line 2212: [J

line 2213: " Virata Config Script File or Drupal module[J

line 2214: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif[J

line 2220: [J

line 2221: " Visual Basic (also uses *.bas) or FORM[J

line 2222: au BufNewFile,BufRead *.frm^I^I^Icall dist#ft#FTfrm()[J

line 2223: [J

line 2224: " SaxBasic is close to Visual Basic[J

line 2225: au BufNewFile,BufRead *.sba^I^I^Isetf vb[J

line 2226: [J

line 2227: " Vgrindefs file[J

line 2228: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs[J

line 2229: [J

line 2230: " VRML V1.0c[J

line 2231: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml[J

line 2232: [J

line 2233: " Vroom (vim testing and executable documentation)[J

line 2234: au BufNewFile,BufRead *.vroom^I^I^Isetf vroom[J

line 2235: [J

line 2236: " Vue.js Single File Component[J

line 2237: au BufNewFile,BufRead *.vue^I^I^Isetf vue[J

line 2238: [J

line 2239: " WebAssembly[J

line 2240: au BufNewFile,BufRead *.wast,*.wat^I^Isetf wast[J

line 2241: [J

line 2242: " Webmacro[J

line 2243: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro[J

line 2244: [J

line 2245: " Wget config[J

line 2246: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget[J

line 2247: [J

line 2248: " Wget2 config[J

line 2249: au BufNewFile,BufRead .wget2rc,wget2rc^I^Isetf wget2[J

line 2250: [J

line 2251: " Website MetaLanguage[J

line 2252: au BufNewFile,BufRead *.wml^I^I^Isetf wml[J

line 2253: [J

line 2254: " Winbatch[J

line 2255: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch[J

line 2256: [J

line 2257: " WSML[J

line 2258: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml[J

line 2259: [J

line 2260: " WPL[J

line 2261: au BufNewFile,BufRead *.wpl^I^I^Isetf xml[J

line 2262: [J

line 2263: " WvDial[J

line 2264: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial[J

line 2265: [J

line 2266: " CVS RC file[J

line 2267: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc[J

line 2268: [J

line 2269: " CVS commit file[J

line 2270: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs[J

line 2271: [J

line 2272: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment[J

line 2273: " lines in a WEB file).[J

line 2274: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif[J

line 2280: [J

line 2281: " Windows Scripting Host and Windows Script Component[J

line 2282: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh[J

line 2283: [J

line 2284: " XHTML[J

line 2285: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml[J

line 2286: [J

line 2287: " X Pixmap (dynamically sets colors, this used to trigger on BufEnter to make[J

line 2288: " it work better, but that breaks setting 'filetype' manually)[J

line 2289: au BufNewFile,BufRead *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif[J

line 2295: au BufNewFile,BufRead *.xpm2^I^I^Isetf xpm2[J

line 2296: [J

line 2297: " XFree86 config[J

line 2298: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf[J

line 2303: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf[J

line 2306: [J

line 2307: " Xorg config[J

line 2308: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf[J

line 2309: [J

line 2310: " Xinetd conf[J

line 2311: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd[J

line 2312: [J

line 2313: " XS Perl extension interface language[J

line 2314: au BufNewFile,BufRead *.xs^I^I^Isetf xs[J

line 2315: [J

line 2316: " X resources file[J

line 2317: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults[J

line 2318: [J

line 2319: " Xmath[J

line 2320: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath[J

line 2321: au BufNewFile,BufRead *.ms if !dist#ft#FTnroff() | setf xmath | endif[J

line 2323: [J

line 2324: " XML  specific variants: docbk and xbl[J

line 2325: au BufNewFile,BufRead *.xml^I^I^Icall dist#ft#FTxml()[J

line 2326: [J

line 2327: " XMI (holding UML models) is also XML[J

line 2328: au BufNewFile,BufRead *.xmi^I^I^Isetf xml[J

line 2329: [J

line 2330: " CSPROJ files are Visual Studio.NET's XML-based C# project config files[J

line 2331: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml[J

line 2332: [J

line 2333: " FSPROJ files are Visual Studio.NET's XML-based F# project config files[J

line 2334: au BufNewFile,BufRead *.fsproj,*.fsproj.user^Isetf xml[J

line 2335: [J

line 2336: " VBPROJ files are Visual Studio.NET's XML-based Visual Basic project config files[J

line 2337: au BufNewFile,BufRead *.vbproj,*.vbproj.user^Isetf xml[J

line 2338: [J

line 2339: " Qt Linguist translation source and Qt User Interface Files are XML[J

line 2340: " However, for .ts TypeScript is more common.[J

line 2341: au BufNewFile,BufRead *.ui^I^I^Isetf xml[J

line 2342: [J

line 2343: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)[J

line 2344: au BufNewFile,BufRead *.tpm^I^I^Isetf xml[J

line 2345: [J

line 2346: " Xdg menus[J

line 2347: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml[J

line 2348: [J

line 2349: " ATI graphics driver configuration[J

line 2350: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml[J

line 2351: [J

line 2352: " Web Services Description Language (WSDL)[J

line 2353: au BufNewFile,BufRead *.wsdl^I^I^Isetf xml[J

line 2354: [J

line 2355: " Workflow Description Language (WDL)[J

line 2356: au BufNewFile,BufRead *.wdl^I^I^Isetf wdl[J

line 2357: [J

line 2358: " XLIFF (XML Localisation Interchange File Format) is also XML[J

line 2359: au BufNewFile,BufRead *.xlf^I^I^Isetf xml[J

line 2360: au BufNewFile,BufRead *.xliff^I^I^Isetf xml[J

line 2361: [J

line 2362: " XML User Interface Language[J

line 2363: au BufNewFile,BufRead *.xul^I^I^Isetf xml[J

line 2364: [J

line 2365: " X11 xmodmap (also see below)[J

line 2366: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap[J

line 2367: [J

line 2368: " Xquery[J

line 2369: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery[J

line 2370: [J

line 2371: " XSD[J

line 2372: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd[J

line 2373: [J

line 2374: " Xslt[J

line 2375: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt[J

line 2376: [J

line 2377: " Yacc[J

line 2378: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc[J

line 2379: [J

line 2380: " Yacc or racc[J

line 2381: au BufNewFile,BufRead *.y^I^I^Icall dist#ft#FTy()[J

line 2382: [J

line 2383: " Yaml[J

line 2384: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml[J

line 2385: [J

line 2386: " Raml[J

line 2387: au BufNewFile,BufRead *.raml^I^I^Isetf raml[J

line 2388: [J

line 2389: " yum conf (close enough to dosini)[J

line 2390: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini[J

line 2391: [J

line 2392: " YANG[J

line 2393: au BufRead,BufNewFile *.yang^I^I^Isetf yang[J

line 2394: [J

line 2395: " Zimbu[J

line 2396: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu[J

line 2397: " Zimbu Templates[J

line 2398: au BufNewFile,BufRead *.zut^I^I^Isetf zimbutempl[J

line 2399: [J

line 2400: " Zope[J

line 2401: "   dtml (zope dynamic template markup language), pt (zope page template),[J

line 2402: "   cpt (zope form controller page template)[J

line 2403: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall dist#ft#FThtml()[J

line 2404: "   zsql (zope sql method)[J

line 2405: au BufNewFile,BufRead *.zsql^I^I^Icall dist#ft#SQL()[J

line 2406: [J

line 2407: " Z80 assembler asz80[J

line 2408: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a[J

line 2409: [J

line 2410: augroup END[J

line 2411: [J

line 2412: [J

line 2413: " Source the user-specified filetype file, for backwards compatibility with[J

line 2414: " Vim 5.x.[J

line 2415: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))[J

line 2416:   execute "source " . myfiletypefile[J

line 2417: endif[J

line 2418: [J

line 2419: [J

line 2420: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used[J

line 2421: " when there are no matching file name extensions.[J

line 2422: " Don't do this for compressed files.[J

line 2423: augroup filetypedetect[J

line 2424: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif[J

line 2427: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif[J

line 2428: [J

line 2429: [J

line 2430: " Plain text files, needs to be far down to not override others.  This avoids[J

line 2431: " the "conf" type being used if there is a line starting with '#'.[J

line 2432: " But before patterns matching everything in a directory.[J

line 2433: au BufNewFile,BufRead *.text,README,LICENSE,COPYING,AUTHORS^Isetf text[J

line 2434: [J

line 2435: [J

line 2436: " Extra checks for when no filetype has been detected now.  Mostly used for[J

line 2437: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim[J

line 2438: " script file.[J

line 2439: " Most of these should call s:StarSetf() to avoid names ending in .gz and the[J

line 2440: " like are used.[J

line 2441: [J

line 2442: " More Apache style config files[J

line 2443: au BufNewFile,BufRead */etc/proftpd/*.conf*,*/etc/proftpd/conf.*/*^Icall s:StarSetf('apachestyle')[J

line 2444: au BufNewFile,BufRead proftpd.conf*^I^I^I^I^Icall s:StarSetf('apachestyle')[J

line 2445: [J

line 2446: " More Apache config files[J

line 2447: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')[J

line 2448: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.*/*,*/etc/httpd/mods-*/*,*/etc/httpd/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')[J

line 2449: [J

line 2450: " APT config file[J

line 2451: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} call s:StarSetf('aptconf')[J

line 2452: [J

line 2453: " Asterisk config file[J

line 2454: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')[J

line 2455: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')[J

line 2456: [J

line 2457: " Bazaar version control[J

line 2458: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr[J

line 2459: [J

line 2460: " Bazel build file[J

line 2461: if !has("fname_case")[J

line 2462:   au BufNewFile,BufRead *.BUILD,BUILD^I^Isetf bzl[J

line 2463: endif[J

line 2464: [J

line 2465: " BIND zone[J

line 2466: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')[J

line 2467: [J

line 2468: au BufNewFile,BufRead cabal.project.*^I^Icall s:StarSetf('cabalproject')[J

line 2469: [J

line 2470: " Calendar[J

line 2471: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')[J

line 2474: [J

line 2475: " Changelog[J

line 2476: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif[J

line 2482: [J

line 2483: " Crontab[J

line 2484: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')[J

line 2485: [J

line 2486: " dnsmasq(8) configuration[J

line 2487: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')[J

line 2488: [J

line 2489: " Dockerfile[J

line 2490: au BufNewFile,BufRead Dockerfile.*,Containerfile.*^Icall s:StarSetf('dockerfile')[J

line 2491: [J

line 2492: " Dracula[J

line 2493: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')[J

line 2494: [J

line 2495: " Fvwm[J

line 2496: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')[J

line 2497: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')[J

line 2499: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif[J

line 2505: [J

line 2506: " Gedcom[J

line 2507: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')[J

line 2508: [J

line 2509: " Git[J

line 2510: au BufNewFile,BufRead */.gitconfig.d/*,*/etc/gitconfig.d/*^Icall s:StarSetf('gitconfig')[J

line 2511: [J

line 2512: " Gitolite[J

line 2513: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')[J

line 2514: [J

line 2515: " GTK RC[J

line 2516: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')[J

line 2517: [J

line 2518: " Jam[J

line 2519: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')[J

line 2520: [J

line 2521: " Jargon[J

line 2522: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif[J

line 2526: [J

line 2527: " Java Properties resource file (note: doesn't catch font.properties.pl)[J

line 2528: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')[J

line 2529: [J

line 2530: " Kconfig[J

line 2531: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')[J

line 2532: [J

line 2533: " Lilo: Linux loader[J

line 2534: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')[J

line 2535: [J

line 2536: " Libsensors[J

line 2537: au BufNewFile,BufRead */etc/sensors.d/[^.]*^Icall s:StarSetf('sensors')[J

line 2538: [J

line 2539: " Logcheck[J

line 2540: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')[J

line 2541: [J

line 2542: " Makefile[J

line 2543: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')[J

line 2544: [J

line 2545: " Ruby Makefile[J

line 2546: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')[J

line 2547: [J

line 2548: " Mail (also matches muttrc.vim, so this is below the other checks)[J

line 2549: au BufNewFile,BufRead {neo,}mutt[[:alnum:]._-]\\\{6\}^Isetf mail[J

line 2550: [J

line 2551: au BufNewFile,BufRead reportbug-*^I^Icall s:StarSetf('mail')[J

line 2552: [J

line 2553: " Modconf[J

line 2554: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif[J

line 2558: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')[J

line 2559: [J

line 2560: " Mutt setup files (must be before catch *.rc)[J

line 2561: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')[J

line 2562: [J

line 2563: " Mutt setup file[J

line 2564: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')[J

line 2565: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')[J

line 2566: [J

line 2567: " Neomutt setup file[J

line 2568: au BufNewFile,BufRead .neomuttrc*,*/.neomutt/neomuttrc*^Icall s:StarSetf('neomuttrc')[J

line 2569: au BufNewFile,BufRead neomuttrc*,Neomuttrc*^I^Icall s:StarSetf('neomuttrc')[J

line 2570: [J

line 2571: " Nroff macros[J

line 2572: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')[J

line 2573: [J

line 2574: " OpenBSD hostname.if[J

line 2575: au BufNewFile,BufRead */etc/hostname.*^I^Icall s:StarSetf('config')[J

line 2576: [J

line 2577: " Pam conf[J

line 2578: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')[J

line 2579: [J

line 2580: " Printcap and Termcap[J

line 2581: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif[J

line 2585: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif[J

line 2589: [J

line 2590: " ReDIF[J

line 2591: " Only used when the .rdf file was not detected to be XML.[J

line 2592: au BufRead,BufNewFile *.rdf^I^I^Icall dist#ft#Redif()[J

line 2593: [J

line 2594: " Remind[J

line 2595: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')[J

line 2596: [J

line 2597: " SGML catalog file[J

line 2598: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')[J

line 2599: [J

line 2600: " avoid doc files being recognized a shell files[J

line 2601: au BufNewFile,BufRead */doc/{,.}bash[_-]completion{,.d,.sh}{,/*} setf text[J

line 2602: [J

line 2603: " Shell scripts ending in a star[J

line 2604: au BufNewFile,BufRead .bashrc*,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,bash-fc[-.]*,PKGBUILD*,APKBUILD*,*/{,.}bash[_-]completion{,.d,.sh}{,/*} call dist#ft#SetFileTypeSH("bash")[J

line 2605: au BufNewFile,BufRead .kshrc* call dist#ft#SetFileTypeSH("ksh")[J

line 2606: au BufNewFile,BufRead .profile* call dist#ft#SetFileTypeSH(getline(1))[J

line 2607: [J

line 2608: " Sudoers[J

line 2609: au BufNewFile,BufRead */etc/sudoers.d/*^I^Icall s:StarSetf('sudoers')[J

line 2610: [J

line 2611: " tcsh scripts ending in a star[J

line 2612: au BufNewFile,BufRead .tcshrc*^Icall dist#ft#SetFileTypeShell("tcsh")[J

line 2613: [J

line 2614: " csh scripts ending in a star[J

line 2615: au BufNewFile,BufRead .login*,.cshrc*  call dist#ft#CSH()[J

line 2616: [J

line 2617: " tmux configuration with arbitrary extension[J

line 2618: au BufNewFile,BufRead {.,}tmux*.conf*^I^Isetf tmux[J

line 2619: [J

line 2620: " VHDL[J

line 2621: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')[J

line 2622: [J

line 2623: " Vim script[J

line 2624: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')[J

line 2625: [J

line 2626: " Subversion commit file[J

line 2627: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn[J

line 2628: [J

line 2629: " X resources file[J

line 2630: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')[J

line 2631: [J

line 2632: " XFree86 config[J

line 2633: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')[J

line 2635: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')[J

line 2640: [J

line 2641: " X11 xmodmap[J

line 2642: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')[J

line 2643: [J

line 2644: " Xinetd conf[J

line 2645: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')[J

line 2646: [J

line 2647: " yum conf (close enough to dosini)[J

line 2648: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')[J

line 2649: [J

line 2650: " Z-Shell script ending in a star[J

line 2651: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')[J

line 2652: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')[J

line 2653: [J

line 2654: [J

line 2655: " Help files match *.txt but should have a last line that is a modeline.[J

line 2656: au BufNewFile,BufRead *.txt  if getline('$') !~ 'vim:.*ft=help'|   setf text| endif[J

line 2660: [J

line 2661: " Blueprint markup files[J

line 2662: au BufNewFile,BufRead *.blp^I^I^Isetf blueprint[J

line 2663: [J

line 2664: " Use the filetype detect plugins.  They may overrule any of the previously[J

line 2665: " detected filetypes.[J

line 2666: runtime! ftdetect/*.vim[J

Searching for "ftdetect/*.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/ftdetect/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/ftdetect/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/ftdetect/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/ftdetect/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/ftdetect/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/ftdetect/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/ftdetect/*.vim"[J
Searching for "/usr/local/share/vim/vimfiles/ftdetect/*.vim"[J
Searching for "/usr/local/share/vim/vim90/ftdetect/*.vim"[J
Searching for "/usr/local/share/vim/vimfiles/after/ftdetect/*.vim"[J
Searching for "/Users/tsen/.vim/after/ftdetect/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/ftdetect/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/after/ftdetect/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/after/ftdetect/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after/ftdetect/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/after/ftdetect/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/after/ftdetect/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/after/ftdetect/*.vim"[J
not found in 'runtimepath': "ftdetect/*.vim"[J
line 2667: [J

line 2668: " NOTE: The above command could have ended the filetypedetect autocmd group[J

line 2669: " and started another one. Let's make sure it has ended to get to a consistent[J

line 2670: " state.[J

line 2671: augroup END[J

line 2672: [J

line 2673: " Generic configuration file. Use FALLBACK, it's just guessing![J

line 2674: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf FALLBACK conf | endif[J

line 2680: [J

line 2681: [J

line 2682: " If the GUI is already running, may still need to install the Syntax menu.[J

line 2683: " Don't do it when the 'M' flag is included in 'guioptions'.[J

line 2684: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"[J

line 2686:   source <sfile>:p:h/menu.vim[J

line 2687: endif[J

line 2688: [J

line 2689: " Function called for testing all functions defined here.  These are[J

line 2690: " script-local, thus need to be executed here.[J

line 2691: " Returns a string with error messages (hopefully empty).[J

line 2692: func TestFiletypeFuncs(testlist)[J

line 2703: [J

line 2704: " Restore 'cpoptions'[J

line 2705: let &cpo = s:cpo_save[J

line 2706: unlet s:cpo_save[J

finished sourcing /usr/local/share/vim/vim90/filetype.vim[J
continuing in /Users/tsen/.vim/vimrc[J
Searching for "/usr/local/share/vim/vimfiles/after/filetype.vim"[J
Searching for "/Users/tsen/.vim/after/filetype.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/filetype.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/after/filetype.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/after/filetype.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after/filetype.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/after/filetype.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/after/filetype.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/after/filetype.vim"[J
Searching for "ftplugin.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/ftplugin.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/ftplugin.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/ftplugin.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/ftplugin.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/ftplugin.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/ftplugin.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/ftplugin.vim"[J
Searching for "/usr/local/share/vim/vimfiles/ftplugin.vim"[J
Searching for "/usr/local/share/vim/vim90/ftplugin.vim"[J
chdir(/usr/local/share/vim/vim90)[J
fchdir() to previous dir[J
line 29: sourcing "/usr/local/share/vim/vim90/ftplugin.vim"[J
line 1: vim9script noclear[J

line 2: [J

line 3: # Vim support file to switch on loading plugins for file types[J

line 4: #[J

line 5: # Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 6: # Last change:^I2022 Feb 11[J

line 7: [J

line 8: if exists("g:did_load_ftplugin")[J

line 9:   finish[J

line 10: endif[J

line 11: g:did_load_ftplugin = 1[J

line 13: augroup filetypeplugin[J

line 14:   au FileType * call LoadFTPlugin()[J

line 15: augroup END[J

line 16: [J

line 17: if exists('*LoadFTPlugin')[J

line 19:   finish[J

line 20: endif[J

line 21: [J

line 22: def LoadFTPlugin()[J

finished sourcing /usr/local/share/vim/vim90/ftplugin.vim[J
continuing in /Users/tsen/.vim/vimrc[J
Searching for "/usr/local/share/vim/vimfiles/after/ftplugin.vim"[J
Searching for "/Users/tsen/.vim/after/ftplugin.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/ftplugin.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/after/ftplugin.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/after/ftplugin.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after/ftplugin.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/after/ftplugin.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/after/ftplugin.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/after/ftplugin.vim"[J
Searching for "indent.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/indent.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/indent.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/indent.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/indent.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/indent.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/indent.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/indent.vim"[J
Searching for "/usr/local/share/vim/vimfiles/indent.vim"[J
Searching for "/usr/local/share/vim/vim90/indent.vim"[J
chdir(/usr/local/share/vim/vim90)[J
fchdir() to previous dir[J
line 29: sourcing "/usr/local/share/vim/vim90/indent.vim"[J
line 1: " Vim support file to switch on loading indent files for file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last Change:^I2022 Feb 11[J

line 5: [J

line 6: if exists("did_indent_on")[J

line 7:   finish[J

line 8: endif[J

line 9: let did_indent_on = 1[J

line 10: [J

line 11: augroup filetypeindent[J

line 12:   au FileType * call s:LoadIndent()[J

line 13: augroup END[J

line 14: [J

line 15: def s:LoadIndent()[J

finished sourcing /usr/local/share/vim/vim90/indent.vim[J
continuing in /Users/tsen/.vim/vimrc[J
Searching for "/usr/local/share/vim/vimfiles/after/indent.vim"[J
Searching for "/Users/tsen/.vim/after/indent.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/indent.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/after/indent.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/after/indent.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after/indent.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/after/indent.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/after/indent.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/after/indent.vim"[J
line 30: " To ignore plugin indent changes, instead use:[J

line 31: "filetype plugin on[J

line 32: "[J

line 33: " Brief help[J

line 34: " :PluginList       - lists configured plugins[J

line 35: " :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate[J

line 36: " :PluginSearch foo - searches for foo; append `!` to refresh local cache[J

line 37: " :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal[J

line 38: "[J

line 39: " see :h vundle for more details or wiki for FAQ[J

line 40: " Put your non-Plugin stuff after this line[J

line 41: " ---------------------------------------------------------- 基本配置 -----------------------------------------------------[J

line 42: " 語法辨識[J

line 43: syntax enable[J

line 43: so $VIMRUNTIME/syntax/syntax.vim[J

chdir(/usr/local/share/vim/vim90/syntax)[J
fchdir() to previous dir[J
line 43: sourcing "/usr/local/share/vim/vim90/syntax/syntax.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2022 Apr 12[J

line 4: [J

line 5: " This file is used for ":syntax on".[J

line 6: " It installs the autocommands and starts highlighting for all buffers.[J

line 7: [J

line 8: if !has("syntax")[J

line 9:   finish[J

line 10: endif[J

line 11: [J

line 12: " If Syntax highlighting appears to be on already, turn it off first, so that[J

line 13: " any leftovers are cleared.[J

line 14: if exists("syntax_on") || exists("syntax_manual")[J

line 15:   so <sfile>:p:h/nosyntax.vim[J

line 16: endif[J

line 17: [J

line 18: " Load the Syntax autocommands and set the default methods for highlighting.[J

line 19: runtime syntax/synload.vim[J

Searching for "syntax/synload.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/syntax/synload.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/syntax/synload.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/syntax/synload.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/syntax/synload.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/syntax/synload.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/syntax/synload.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/syntax/synload.vim"[J
Searching for "/usr/local/share/vim/vimfiles/syntax/synload.vim"[J
Searching for "/usr/local/share/vim/vim90/syntax/synload.vim"[J
chdir(/usr/local/share/vim/vim90/syntax)[J
fchdir() to previous dir[J
line 19: sourcing "/usr/local/share/vim/vim90/syntax/synload.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2022 Apr 12[J

line 4: [J

line 5: " This file sets up for syntax highlighting.[J

line 6: " It is loaded from "syntax.vim" and "manual.vim".[J

line 7: " 1. Set the default highlight groups.[J

line 8: " 2. Install Syntax autocommands for all the available syntax files.[J

line 9: [J

line 10: if !has("syntax")[J

line 11:   finish[J

line 12: endif[J

line 13: [J

line 14: " let others know that syntax has been switched on[J

line 15: let syntax_on = 1[J

line 16: [J

line 17: " Set the default highlighting colors.  Use a color scheme if specified.[J

line 18: if exists("colors_name")[J

line 19:   exe "colors " . colors_name[J

line 20: else[J

line 21:   runtime! syntax/syncolor.vim[J

Searching for "syntax/syncolor.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/syntax/syncolor.vim"[J
Searching for "/usr/local/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/local/share/vim/vim90/syntax/syncolor.vim"[J
chdir(/usr/local/share/vim/vim90/syntax)[J
fchdir() to previous dir[J
line 21: sourcing "/usr/local/share/vim/vim90/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2020 Feb 13[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 34: hi def Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 35: hi def Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 36: hi def Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

Searching for "colors/lists/default.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/colors/lists/default.vim"[J
Searching for "/usr/local/share/vim/vimfiles/colors/lists/default.vim"[J
Searching for "/usr/local/share/vim/vim90/colors/lists/default.vim"[J
chdir(/usr/local/share/vim/vim90/colors/lists)[J
fchdir() to previous dir[J
line 36: sourcing "/usr/local/share/vim/vim90/colors/lists/default.vim"[J
line 1: " Maintainer:  Drew Vogel <dvogel@sidejump.org>[J

line 2: " Last Change: 2022 Mar 20[J

line 3: "[J

line 4: " Replaced rgb.txt as the source of de facto standard color names. This is[J

line 5: " sourced each time the colorscheme command is run. It is also sourced each[J

line 6: " time the highlight command fails to recognize a gui color. You can override[J

line 7: " these colors by introducing a new colors/lists/default.vim file earlier in[J

line 8: " the runtimepath.[J

line 9: [J

line 10: let s:keepcpo= &cpo[J

line 11: set cpo&vim[J

line 12: [J

line 13: call extend(v:colornames, { 'snow': '#fffafa', 'ghost white': '#f8f8ff', 'ghostwhite': '#f8f8ff', 'white smoke': '#f5f5f5', 'whitesmoke': '#f5f5f5', 'gainsboro': '#dcdcdc', 'floral white': '#fffaf0', 'floralwhite': '#fffaf0', 'old lace': '#fdf5e6', 'oldlace': '#fdf5e6', 'linen': '#faf0e6', 'antique white': '#faebd7', 'antiquewhite': '#faebd7', 'papaya whip': '#ffefd5', 'papayawhip': '#ffefd5', 'blanched almond': '#ffebcd', 'blanchedalmond': '#ffebcd', 'bisque': '#ffe4c4', 'peach puff': '#ffdab9', 'peachpuff': '#ffdab9', 'navajo white': '#ffdead', 'navajowhite': '#ffdead', 'moccasin': '#ffe4b5', 'cornsilk': '#fff8dc', 'ivory': '#fffff0', 'lemon chiffon': '#fffacd', 'lemonchiffon': '#fffacd', 'seashell': '#fff5ee', 'honeydew': '#f0fff0', 'mint cream': '#f5fffa', 'mintcream': '#f5fffa', 'azure': '#f0ffff', 'alice blue': '#f0f8ff', 'aliceblue': '#f0f8ff', 'lavender': '#e6e6fa', 'lavender blush': '#fff0f5', 'lavenderblush': '#fff0f5', 'misty rose': '#ffe4e1', 'mistyrose': '#ffe4e1', 'white': '#ffffff', 'b[J

line 803: [J

line 804: let &cpo= s:keepcpo[J

line 805: unlet s:keepcpo[J

line 806: [J

line 807: "vim: sw=4[J

finished sourcing /usr/local/share/vim/vim90/colors/lists/default.vim[J
continuing in /usr/local/Cellar/vim/9.0.1050/share/vim/vim90/syntax/syncolor.vim[J
Searching for "/usr/local/share/vim/vimfiles/after/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/after/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/after/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/after/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/after/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/after/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/after/colors/lists/default.vim"[J
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 37: hi def Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 38: hi def Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 39: hi def PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 40: hi def Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 41: hi def Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 42: hi def Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   " #6a5acd is SlateBlue[J

line 47:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE[J

line 48:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 49:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 50:   " #6a0dad is Purple[J

line 51:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE[J

line 52:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 53:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 54:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 55: endif[J

line 56: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 56: hi def Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 57: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 57: hi def Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 58: [J

line 59: " Common groups that link to default highlighting.[J

line 60: " You can specify other highlighting easily.[J

line 61: SynLink String^I^IConstant[J

line 61: hi def link String^I^IConstant[J

line 62: SynLink Character^IConstant[J

line 62: hi def link Character^IConstant[J

line 63: SynLink Number^I^IConstant[J

line 63: hi def link Number^I^IConstant[J

line 64: SynLink Boolean^I^IConstant[J

line 64: hi def link Boolean^I^IConstant[J

line 65: SynLink Float^I^INumber[J

line 65: hi def link Float^I^INumber[J

line 66: SynLink Function^IIdentifier[J

line 66: hi def link Function^IIdentifier[J

line 67: SynLink Conditional^IStatement[J

line 67: hi def link Conditional^IStatement[J

line 68: SynLink Repeat^I^IStatement[J

line 68: hi def link Repeat^I^IStatement[J

line 69: SynLink Label^I^IStatement[J

line 69: hi def link Label^I^IStatement[J

line 70: SynLink Operator^IStatement[J

line 70: hi def link Operator^IStatement[J

line 71: SynLink Keyword^I^IStatement[J

line 71: hi def link Keyword^I^IStatement[J

line 72: SynLink Exception^IStatement[J

line 72: hi def link Exception^IStatement[J

line 73: SynLink Include^I^IPreProc[J

line 73: hi def link Include^I^IPreProc[J

line 74: SynLink Define^I^IPreProc[J

line 74: hi def link Define^I^IPreProc[J

line 75: SynLink Macro^I^IPreProc[J

line 75: hi def link Macro^I^IPreProc[J

line 76: SynLink PreCondit^IPreProc[J

line 76: hi def link PreCondit^IPreProc[J

line 77: SynLink StorageClass^IType[J

line 77: hi def link StorageClass^IType[J

line 78: SynLink Structure^IType[J

line 78: hi def link Structure^IType[J

line 79: SynLink Typedef^I^IType[J

line 79: hi def link Typedef^I^IType[J

line 80: SynLink Tag^I^ISpecial[J

line 80: hi def link Tag^I^ISpecial[J

line 81: SynLink SpecialChar^ISpecial[J

line 81: hi def link SpecialChar^ISpecial[J

line 82: SynLink Delimiter^ISpecial[J

line 82: hi def link Delimiter^ISpecial[J

line 83: SynLink SpecialComment^ISpecial[J

line 83: hi def link SpecialComment^ISpecial[J

line 84: SynLink Debug^I^ISpecial[J

line 84: hi def link Debug^I^ISpecial[J

line 85: [J

line 86: delcommand SynColor[J

line 87: delcommand SynLink[J

finished sourcing /usr/local/share/vim/vim90/syntax/syncolor.vim[J
continuing in /usr/local/Cellar/vim/9.0.1050/share/vim/vim90/syntax/synload.vim[J
Searching for "/usr/local/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/after/syntax/syncolor.vim"[J
line 22: endif[J

line 23: [J

line 24: " Line continuation is used here, remove 'C' from 'cpoptions'[J

line 25: let s:cpo_save = &cpo[J

line 26: set cpo&vim[J

line 27: [J

line 28: " First remove all old syntax autocommands.[J

line 29: au! Syntax[J

line 30: [J

line 31: au Syntax *^I^Icall s:SynSet()[J

line 32: [J

line 33: fun! s:SynSet()[J

line 63: [J

line 64: [J

line 65: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)[J

line 66: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif[J

line 71: [J

line 72: [J

line 73: " Source the user-specified syntax highlighting file[J

line 74: if exists("mysyntaxfile")[J

line 75:   let s:fname = expand(mysyntaxfile)[J

line 76:   if filereadable(s:fname)[J

line 77:     execute "source " . fnameescape(s:fname)[J

line 78:   endif[J

line 79: endif[J

line 80: [J

line 81: " Restore 'cpoptions'[J

line 82: let &cpo = s:cpo_save[J

line 83: unlet s:cpo_save[J

finished sourcing /usr/local/share/vim/vim90/syntax/synload.vim[J
continuing in /usr/local/Cellar/vim/9.0.1050/share/vim/vim90/syntax/syntax.vim[J
line 20: [J

line 21: " Load the FileType autocommands if not done yet.[J

line 22: if exists("did_load_filetypes")[J

line 23:   let s:did_ft = 1[J

line 24: else[J

line 25:   filetype on[J

line 26:   let s:did_ft = 0[J

line 27: endif[J

line 28: [J

line 29: " Set up the connection between FileType and Syntax autocommands.[J

line 30: " This makes the syntax automatically set when the file type is detected.[J

line 31: " Avoid an error when 'verbose' is set and <amatch> expansion fails.[J

line 32: augroup syntaxset[J

line 33:   au! FileType *^I0verbose exe "set syntax=" . expand("<amatch>")[J

line 34: augroup END[J

line 35: [J

line 36: [J

line 37: " Execute the syntax autocommands for the each buffer.[J

line 38: " If the filetype wasn't detected yet, do that now.[J

line 39: " Always do the syntaxset autocommands, for buffers where the 'filetype'[J

line 40: " already was set manually (e.g., help buffers).[J

line 41: doautoall syntaxset FileType[J

Executing FileType Autocommands for "*"[J
autocommand 0verbose exe "set syntax=" . expand("<amatch>")[J

Executing: 0verbose exe "set syntax=" . expand("<amatch>")[J

line 42: if !s:did_ft[J

line 43:   doautoall filetypedetect BufRead[J

line 44: endif[J

finished sourcing /usr/local/share/vim/vim90/syntax/syntax.vim[J
continuing in /Users/tsen/.vim/vimrc[J
line 44: [J

line 45: " 行數[J

line 46: set number[J

line 47: [J

line 48: " 在 vim 中要正常使用 Backspace 鍵刪除字元，確實需要正確設置 backspace 選項的值。[J

line 49: " 在 compatible 模式下，設置backspace=indent，eol，start也能工作，但是被刪除的字元不會立刻顯示為空白，顯示效果不好。[J

line 50: set nocompatible[J

line 51: set backspace=indent,eol,start[J

line 52: [J

line 53: " 支援 256 色[J

line 54: set t_Co=256[J

line 55: [J

line 56: " 終端機背景色 : dark / light[J

line 57: set background=dark[J

Searching for "syntax/syncolor.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/syntax/syncolor.vim"[J
Searching for "/usr/local/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/local/share/vim/vim90/syntax/syncolor.vim"[J
chdir(/usr/local/share/vim/vim90/syntax)[J
fchdir() to previous dir[J
line 57: sourcing "/usr/local/share/vim/vim90/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2020 Feb 13[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   " #6a5acd is SlateBlue[J

line 47:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE[J

line 48:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 49:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 50:   " #6a0dad is Purple[J

line 51:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE[J

line 52:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 53:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 54:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 55: endif[J

line 56: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 56: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 57: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 57: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 58: [J

line 59: " Common groups that link to default highlighting.[J

line 60: " You can specify other highlighting easily.[J

line 61: SynLink String^I^IConstant[J

line 61: hi link String^I^IConstant[J

line 62: SynLink Character^IConstant[J

line 62: hi link Character^IConstant[J

line 63: SynLink Number^I^IConstant[J

line 63: hi link Number^I^IConstant[J

line 64: SynLink Boolean^I^IConstant[J

line 64: hi link Boolean^I^IConstant[J

line 65: SynLink Float^I^INumber[J

line 65: hi link Float^I^INumber[J

line 66: SynLink Function^IIdentifier[J

line 66: hi link Function^IIdentifier[J

line 67: SynLink Conditional^IStatement[J

line 67: hi link Conditional^IStatement[J

line 68: SynLink Repeat^I^IStatement[J

line 68: hi link Repeat^I^IStatement[J

line 69: SynLink Label^I^IStatement[J

line 69: hi link Label^I^IStatement[J

line 70: SynLink Operator^IStatement[J

line 70: hi link Operator^IStatement[J

line 71: SynLink Keyword^I^IStatement[J

line 71: hi link Keyword^I^IStatement[J

line 72: SynLink Exception^IStatement[J

line 72: hi link Exception^IStatement[J

line 73: SynLink Include^I^IPreProc[J

line 73: hi link Include^I^IPreProc[J

line 74: SynLink Define^I^IPreProc[J

line 74: hi link Define^I^IPreProc[J

line 75: SynLink Macro^I^IPreProc[J

line 75: hi link Macro^I^IPreProc[J

line 76: SynLink PreCondit^IPreProc[J

line 76: hi link PreCondit^IPreProc[J

line 77: SynLink StorageClass^IType[J

line 77: hi link StorageClass^IType[J

line 78: SynLink Structure^IType[J

line 78: hi link Structure^IType[J

line 79: SynLink Typedef^I^IType[J

line 79: hi link Typedef^I^IType[J

line 80: SynLink Tag^I^ISpecial[J

line 80: hi link Tag^I^ISpecial[J

line 81: SynLink SpecialChar^ISpecial[J

line 81: hi link SpecialChar^ISpecial[J

line 82: SynLink Delimiter^ISpecial[J

line 82: hi link Delimiter^ISpecial[J

line 83: SynLink SpecialComment^ISpecial[J

line 83: hi link SpecialComment^ISpecial[J

line 84: SynLink Debug^I^ISpecial[J

line 84: hi link Debug^I^ISpecial[J

line 85: [J

line 86: delcommand SynColor[J

line 87: delcommand SynLink[J

finished sourcing /usr/local/share/vim/vim90/syntax/syncolor.vim[J
continuing in /Users/tsen/.vim/vimrc[J
Searching for "/usr/local/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/after/syntax/syncolor.vim"[J
line 58: [J

line 59: " 內建風格 ( 縮寫指令 colo )[J

line 60: " 輸入 colorscheme 空一格，再按 Tab 可以依次預覽 : [J

line 61: " blue / darkblue / default / delek / desert / eldlord[J

line 62: " evening / industry / koehler / morning / murphy / pable[J

line 63: " peachpuff / ron / shine / slate / torte / zollner[J

line 64: colorscheme one[J

Searching for "colors/lists/default.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/colors/lists/default.vim"[J
Searching for "/usr/local/share/vim/vimfiles/colors/lists/default.vim"[J
Searching for "/usr/local/share/vim/vim90/colors/lists/default.vim"[J
chdir(/usr/local/share/vim/vim90/colors/lists)[J
fchdir() to previous dir[J
line 64: sourcing "/usr/local/share/vim/vim90/colors/lists/default.vim"[J
line 1: " Maintainer:  Drew Vogel <dvogel@sidejump.org>[J

line 2: " Last Change: 2022 Mar 20[J

line 3: "[J

line 4: " Replaced rgb.txt as the source of de facto standard color names. This is[J

line 5: " sourced each time the colorscheme command is run. It is also sourced each[J

line 6: " time the highlight command fails to recognize a gui color. You can override[J

line 7: " these colors by introducing a new colors/lists/default.vim file earlier in[J

line 8: " the runtimepath.[J

line 9: [J

line 10: let s:keepcpo= &cpo[J

line 11: set cpo&vim[J

line 12: [J

line 13: call extend(v:colornames, { 'snow': '#fffafa', 'ghost white': '#f8f8ff', 'ghostwhite': '#f8f8ff', 'white smoke': '#f5f5f5', 'whitesmoke': '#f5f5f5', 'gainsboro': '#dcdcdc', 'floral white': '#fffaf0', 'floralwhite': '#fffaf0', 'old lace': '#fdf5e6', 'oldlace': '#fdf5e6', 'linen': '#faf0e6', 'antique white': '#faebd7', 'antiquewhite': '#faebd7', 'papaya whip': '#ffefd5', 'papayawhip': '#ffefd5', 'blanched almond': '#ffebcd', 'blanchedalmond': '#ffebcd', 'bisque': '#ffe4c4', 'peach puff': '#ffdab9', 'peachpuff': '#ffdab9', 'navajo white': '#ffdead', 'navajowhite': '#ffdead', 'moccasin': '#ffe4b5', 'cornsilk': '#fff8dc', 'ivory': '#fffff0', 'lemon chiffon': '#fffacd', 'lemonchiffon': '#fffacd', 'seashell': '#fff5ee', 'honeydew': '#f0fff0', 'mint cream': '#f5fffa', 'mintcream': '#f5fffa', 'azure': '#f0ffff', 'alice blue': '#f0f8ff', 'aliceblue': '#f0f8ff', 'lavender': '#e6e6fa', 'lavender blush': '#fff0f5', 'lavenderblush': '#fff0f5', 'misty rose': '#ffe4e1', 'mistyrose': '#ffe4e1', 'white': '#ffffff', 'b[J

line 803: [J

line 804: let &cpo= s:keepcpo[J

line 805: unlet s:keepcpo[J

line 806: [J

line 807: "vim: sw=4[J

finished sourcing /usr/local/share/vim/vim90/colors/lists/default.vim[J
continuing in /Users/tsen/.vim/vimrc[J
Searching for "/usr/local/share/vim/vimfiles/after/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/after/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/after/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/after/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/after/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/after/colors/lists/default.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/after/colors/lists/default.vim"[J
Searching for "colors/one.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/colors/one.vim"[J
chdir(/Users/tsen/.vim/colors)[J
fchdir() to previous dir[J
line 64: sourcing "/Users/tsen/.vim/colors/one.vim"[J
line 1: " Name:    one vim colorscheme[J

line 2: " Author:  Ramzi Akremi[J

line 3: " License: MIT[J

line 4: " Version: 1.1.1-pre[J

line 5: [J

line 6: " Global setup =============================================================={{{[J

line 7: [J

line 8: if exists("*<SID>X")[J

line 9:   delf <SID>X[J

line 10:   delf <SID>XAPI[J

line 11:   delf <SID>rgb[J

line 12:   delf <SID>color[J

line 13:   delf <SID>rgb_color[J

line 14:   delf <SID>rgb_level[J

line 15:   delf <SID>rgb_number[J

line 16:   delf <SID>grey_color[J

line 17:   delf <SID>grey_level[J

line 18:   delf <SID>grey_number[J

line 19: endif[J

line 20: [J

line 21: hi clear[J

Searching for "syntax/syncolor.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/syntax/syncolor.vim"[J
Searching for "/usr/local/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/local/share/vim/vim90/syntax/syncolor.vim"[J
chdir(/usr/local/share/vim/vim90/syntax)[J
fchdir() to previous dir[J
line 21: sourcing "/usr/local/share/vim/vim90/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2020 Feb 13[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   " #6a5acd is SlateBlue[J

line 47:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE[J

line 48:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 49:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 50:   " #6a0dad is Purple[J

line 51:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE[J

line 52:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 53:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 54:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 55: endif[J

line 56: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 56: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 57: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 57: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 58: [J

line 59: " Common groups that link to default highlighting.[J

line 60: " You can specify other highlighting easily.[J

line 61: SynLink String^I^IConstant[J

line 61: hi link String^I^IConstant[J

line 62: SynLink Character^IConstant[J

line 62: hi link Character^IConstant[J

line 63: SynLink Number^I^IConstant[J

line 63: hi link Number^I^IConstant[J

line 64: SynLink Boolean^I^IConstant[J

line 64: hi link Boolean^I^IConstant[J

line 65: SynLink Float^I^INumber[J

line 65: hi link Float^I^INumber[J

line 66: SynLink Function^IIdentifier[J

line 66: hi link Function^IIdentifier[J

line 67: SynLink Conditional^IStatement[J

line 67: hi link Conditional^IStatement[J

line 68: SynLink Repeat^I^IStatement[J

line 68: hi link Repeat^I^IStatement[J

line 69: SynLink Label^I^IStatement[J

line 69: hi link Label^I^IStatement[J

line 70: SynLink Operator^IStatement[J

line 70: hi link Operator^IStatement[J

line 71: SynLink Keyword^I^IStatement[J

line 71: hi link Keyword^I^IStatement[J

line 72: SynLink Exception^IStatement[J

line 72: hi link Exception^IStatement[J

line 73: SynLink Include^I^IPreProc[J

line 73: hi link Include^I^IPreProc[J

line 74: SynLink Define^I^IPreProc[J

line 74: hi link Define^I^IPreProc[J

line 75: SynLink Macro^I^IPreProc[J

line 75: hi link Macro^I^IPreProc[J

line 76: SynLink PreCondit^IPreProc[J

line 76: hi link PreCondit^IPreProc[J

line 77: SynLink StorageClass^IType[J

line 77: hi link StorageClass^IType[J

line 78: SynLink Structure^IType[J

line 78: hi link Structure^IType[J

line 79: SynLink Typedef^I^IType[J

line 79: hi link Typedef^I^IType[J

line 80: SynLink Tag^I^ISpecial[J

line 80: hi link Tag^I^ISpecial[J

line 81: SynLink SpecialChar^ISpecial[J

line 81: hi link SpecialChar^ISpecial[J

line 82: SynLink Delimiter^ISpecial[J

line 82: hi link Delimiter^ISpecial[J

line 83: SynLink SpecialComment^ISpecial[J

line 83: hi link SpecialComment^ISpecial[J

line 84: SynLink Debug^I^ISpecial[J

line 84: hi link Debug^I^ISpecial[J

line 85: [J

line 86: delcommand SynColor[J

line 87: delcommand SynLink[J

finished sourcing /usr/local/share/vim/vim90/syntax/syncolor.vim[J
continuing in /Users/tsen/.vim/colors/one.vim[J
Searching for "/usr/local/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/after/syntax/syncolor.vim"[J
line 22: syntax reset[J

line 22: runtime! syntax/syncolor.vim[J

Searching for "syntax/syncolor.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/syntax/syncolor.vim"[J
Searching for "/usr/local/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/local/share/vim/vim90/syntax/syncolor.vim"[J
chdir(/usr/local/share/vim/vim90/syntax)[J
fchdir() to previous dir[J
line 22: sourcing "/usr/local/share/vim/vim90/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2020 Feb 13[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   " #6a5acd is SlateBlue[J

line 47:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE[J

line 48:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 49:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 50:   " #6a0dad is Purple[J

line 51:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE[J

line 52:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 53:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 54:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 55: endif[J

line 56: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 56: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 57: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 57: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 58: [J

line 59: " Common groups that link to default highlighting.[J

line 60: " You can specify other highlighting easily.[J

line 61: SynLink String^I^IConstant[J

line 61: hi! link String^I^IConstant[J

line 62: SynLink Character^IConstant[J

line 62: hi! link Character^IConstant[J

line 63: SynLink Number^I^IConstant[J

line 63: hi! link Number^I^IConstant[J

line 64: SynLink Boolean^I^IConstant[J

line 64: hi! link Boolean^I^IConstant[J

line 65: SynLink Float^I^INumber[J

line 65: hi! link Float^I^INumber[J

line 66: SynLink Function^IIdentifier[J

line 66: hi! link Function^IIdentifier[J

line 67: SynLink Conditional^IStatement[J

line 67: hi! link Conditional^IStatement[J

line 68: SynLink Repeat^I^IStatement[J

line 68: hi! link Repeat^I^IStatement[J

line 69: SynLink Label^I^IStatement[J

line 69: hi! link Label^I^IStatement[J

line 70: SynLink Operator^IStatement[J

line 70: hi! link Operator^IStatement[J

line 71: SynLink Keyword^I^IStatement[J

line 71: hi! link Keyword^I^IStatement[J

line 72: SynLink Exception^IStatement[J

line 72: hi! link Exception^IStatement[J

line 73: SynLink Include^I^IPreProc[J

line 73: hi! link Include^I^IPreProc[J

line 74: SynLink Define^I^IPreProc[J

line 74: hi! link Define^I^IPreProc[J

line 75: SynLink Macro^I^IPreProc[J

line 75: hi! link Macro^I^IPreProc[J

line 76: SynLink PreCondit^IPreProc[J

line 76: hi! link PreCondit^IPreProc[J

line 77: SynLink StorageClass^IType[J

line 77: hi! link StorageClass^IType[J

line 78: SynLink Structure^IType[J

line 78: hi! link Structure^IType[J

line 79: SynLink Typedef^I^IType[J

line 79: hi! link Typedef^I^IType[J

line 80: SynLink Tag^I^ISpecial[J

line 80: hi! link Tag^I^ISpecial[J

line 81: SynLink SpecialChar^ISpecial[J

line 81: hi! link SpecialChar^ISpecial[J

line 82: SynLink Delimiter^ISpecial[J

line 82: hi! link Delimiter^ISpecial[J

line 83: SynLink SpecialComment^ISpecial[J

line 83: hi! link SpecialComment^ISpecial[J

line 84: SynLink Debug^I^ISpecial[J

line 84: hi! link Debug^I^ISpecial[J

line 85: [J

line 86: delcommand SynColor[J

line 87: delcommand SynLink[J

finished sourcing /usr/local/share/vim/vim90/syntax/syncolor.vim[J
continuing in /Users/tsen/.vim/colors/one.vim[J
Searching for "/usr/local/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/after/syntax/syncolor.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/after/syntax/syncolor.vim"[J
line 23: if exists('g:colors_name')[J

line 24:   unlet g:colors_name[J

line 25: endif[J

line 26: let g:colors_name = 'one'[J

line 27: [J

line 28: if !exists('g:one_allow_italics')[J

line 29:   let g:one_allow_italics = 0[J

line 30: endif[J

line 31: [J

line 32: let s:italic = ''[J

line 33: if g:one_allow_italics == 1[J

line 34:   let s:italic = 'italic'[J

line 35: endif[J

line 36: [J

line 37: if has('gui_running') || has('termguicolors') || &t_Co == 88 || &t_Co == 256[J

line 38:   " functions[J

line 39:   " returns an approximate grey index for the given grey level[J

line 40: [J

line 41:   " Utility functions -------------------------------------------------------{{{[J

line 42:   fun <SID>grey_number(x)[J

line 79: [J

line 80:   " returns the actual grey level represented by the grey index[J

line 81:   fun <SID>grey_level(n)[J

line 112: [J

line 113:   " returns the palette index for the given grey index[J

line 114:   fun <SID>grey_color(n)[J

line 133: [J

line 134:   " returns an approximate color index for the given color level[J

line 135:   fun <SID>rgb_number(x)[J

line 160: [J

line 161:   " returns the actual color level for the given color index[J

line 162:   fun <SID>rgb_level(n)[J

line 181: [J

line 182:   " returns the palette index for the given R/G/B color indices[J

line 183:   fun <SID>rgb_color(x, y, z)[J

line 190: [J

line 191:   " returns the palette index to approximate the given R/G/B color levels[J

line 192:   fun <SID>color(r, g, b)[J

line 225: [J

line 226:   " returns the palette index to approximate the 'rrggbb' hex string[J

line 227:   fun <SID>rgb(rgb)[J

line 234: [J

line 235:   " sets the highlighting for the given group[J

line 236:   fun <SID>XAPI(group, fg, bg, attr)[J

line 265: [J

line 266:   " Highlight function[J

line 267:   " the original one is borrowed from mhartington/oceanic-next[J

line 268:   function! <SID>X(group, fg, bg, attr, ...)[J

line 287: [J

line 288:   " }}}[J

line 289: [J

line 290: [J

line 291:   " Color definition --------------------------------------------------------{{{[J

line 292:   let s:dark = 0[J

line 293:   if &background ==# 'dark'[J

line 294:     let s:dark = 1[J

line 295:     let s:mono_1 = ['#abb2bf', '145'][J

line 296:     let s:mono_2 = ['#828997', '102'][J

line 297:     let s:mono_3 = ['#5c6370', '59'][J

line 298:     let s:mono_4 = ['#4b5263', '59'][J

line 299: [J

line 300:     let s:hue_1  = ['#56b6c2', '73'] " cyan[J

line 301:     let s:hue_2  = ['#61afef', '75'] " blue[J

line 302:     let s:hue_3  = ['#c678dd', '176'] " purple[J

line 303:     let s:hue_4  = ['#98c379', '114'] " green[J

line 304: [J

line 305:     let s:hue_5   = ['#e06c75', '168'] " red 1[J

line 306:     let s:hue_5_2 = ['#be5046', '130'] " red 2[J

line 307: [J

line 308:     let s:hue_6   = ['#d19a66', '173'] " orange 1[J

line 309:     let s:hue_6_2 = ['#e5c07b', '180'] " orange 2[J

line 310: [J

line 311:     let s:syntax_bg     = ['#282c34', '16'][J

line 312:     let s:syntax_gutter = ['#636d83', '60'][J

line 313:     let s:syntax_cursor = ['#2c323c', '16'][J

line 314: [J

line 315:     let s:syntax_accent = ['#528bff', '69'][J

line 316: [J

line 317:     let s:vertsplit    = ['#181a1f', '233'][J

line 318:     let s:special_grey = ['#3b4048', '16'][J

line 319:     let s:visual_grey  = ['#3e4452', '17'][J

line 320:     let s:pmenu        = ['#333841', '16'][J

line 321:   else[J

line 322:     let s:mono_1 = ['#494b53', '23'][J

line 323:     let s:mono_2 = ['#696c77', '60'][J

line 324:     let s:mono_3 = ['#a0a1a7', '145'][J

line 325:     let s:mono_4 = ['#c2c2c3', '250'][J

line 326: [J

line 327:     let s:hue_1  = ['#0184bc', '31'] " cyan[J

line 328:     let s:hue_2  = ['#4078f2', '33'] " blue[J

line 329:     let s:hue_3  = ['#a626a4', '127'] " purple[J

line 330:     let s:hue_4  = ['#50a14f', '71'] " green[J

line 331: [J

line 332:     let s:hue_5   = ['#e45649', '166'] " red 1[J

line 333:     let s:hue_5_2 = ['#ca1243', '160'] " red 2[J

line 334: [J

line 335:     let s:hue_6   = ['#986801', '94'] " orange 1[J

line 336:     let s:hue_6_2 = ['#c18401', '136'] " orange 2[J

line 337: [J

line 338:     let s:syntax_bg     = ['#fafafa', '255'][J

line 339:     let s:syntax_gutter = ['#9e9e9e', '247'][J

line 340:     let s:syntax_cursor = ['#f0f0f0', '254'][J

line 341: [J

line 342:     let s:syntax_accent = ['#526fff', '63'][J

line 343:     let s:syntax_accent_2 = ['#0083be', '31'][J

line 344: [J

line 345:     let s:vertsplit    = ['#e7e9e1', '188'][J

line 346:     let s:special_grey = ['#d3d3d3', '251'][J

line 347:     let s:visual_grey  = ['#d0d0d0', '251'][J

line 348:     let s:pmenu        = ['#dfdfdf', '253'][J

line 349:   endif[J

line 350: [J

line 351:   let s:syntax_fg = s:mono_1[J

line 352:   let s:syntax_fold_bg = s:mono_3[J

line 353: [J

line 354:   " }}}[J

line 355: [J

line 356:   " Vim editor color --------------------------------------------------------{{{[J

line 357:   call <sid>X('Normal',       s:syntax_fg,     s:syntax_bg,      '')[J

calling <SNR>12_X[J('Normal', ['#abb2bf', '145'], ['#282c34', '16'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Normal guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Normal ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi Normal guibg=#282c34[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi Normal ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 358:   call <sid>X('bold',         '',              '',               'bold')[J

calling <SNR>12_X[J('bold', '', '', 'bold')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi bold gui=bold[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi bold cterm=bold[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 359:   call <sid>X('ColorColumn',  '',              s:syntax_cursor,  '')[J

calling <SNR>12_X[J('ColorColumn', '', ['#2c323c', '16'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi ColorColumn guibg=#2c323c[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi ColorColumn ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 360:   call <sid>X('Conceal',      s:mono_4,        s:syntax_bg,      '')[J

calling <SNR>12_X[J('Conceal', ['#4b5263', '59'], ['#282c34', '16'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Conceal guifg=#4b5263[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Conceal ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi Conceal guibg=#282c34[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi Conceal ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 361:   call <sid>X('Cursor',       '',              s:syntax_accent,  '')[J

calling <SNR>12_X[J('Cursor', '', ['#528bff', '69'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi Cursor guibg=#528bff[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi Cursor ctermbg=69[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 362:   call <sid>X('CursorIM',     '',              '',               '')[J

calling <SNR>12_X[J('CursorIM', '', '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 363:   call <sid>X('CursorColumn', '',              s:syntax_cursor,  '')[J

calling <SNR>12_X[J('CursorColumn', '', ['#2c323c', '16'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi CursorColumn guibg=#2c323c[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi CursorColumn ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 364:   call <sid>X('CursorLine',   '',              s:syntax_cursor,  'none')[J

calling <SNR>12_X[J('CursorLine', '', ['#2c323c', '16'], 'none')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi CursorLine guibg=#2c323c[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi CursorLine ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi CursorLine gui=none[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi CursorLine cterm=none[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 365:   call <sid>X('Directory',    s:hue_2,         '',               '')[J

calling <SNR>12_X[J('Directory', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Directory guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Directory ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 366:   call <sid>X('ErrorMsg',     s:hue_5,         s:syntax_bg,      'none')[J

calling <SNR>12_X[J('ErrorMsg', ['#e06c75', '168'], ['#282c34', '16'], 'none')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi ErrorMsg guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi ErrorMsg ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi ErrorMsg guibg=#282c34[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi ErrorMsg ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi ErrorMsg gui=none[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi ErrorMsg cterm=none[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 367:   call <sid>X('VertSplit',    s:syntax_cursor, s:syntax_cursor,  'none')[J

calling <SNR>12_X[J('VertSplit', ['#2c323c', '16'], ['#2c323c', '16'], 'none')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi VertSplit guifg=#2c323c[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi VertSplit ctermfg=16[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi VertSplit guibg=#2c323c[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi VertSplit ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi VertSplit gui=none[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi VertSplit cterm=none[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 368:   call <sid>X('Folded',       s:syntax_fg,     s:syntax_bg,      'none')[J

calling <SNR>12_X[J('Folded', ['#abb2bf', '145'], ['#282c34', '16'], 'none')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Folded guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Folded ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi Folded guibg=#282c34[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi Folded ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi Folded gui=none[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi Folded cterm=none[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 369:   call <sid>X('FoldColumn',   s:mono_3,        s:syntax_cursor,  '')[J

calling <SNR>12_X[J('FoldColumn', ['#5c6370', '59'], ['#2c323c', '16'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi FoldColumn guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi FoldColumn ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi FoldColumn guibg=#2c323c[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi FoldColumn ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 370:   call <sid>X('IncSearch',    s:hue_6,         '',               '')[J

calling <SNR>12_X[J('IncSearch', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi IncSearch guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi IncSearch ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 371:   call <sid>X('LineNr',       s:mono_4,        '',               '')[J

calling <SNR>12_X[J('LineNr', ['#4b5263', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi LineNr guifg=#4b5263[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi LineNr ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 372:   call <sid>X('CursorLineNr', s:syntax_fg,     s:syntax_cursor,  'none')[J

calling <SNR>12_X[J('CursorLineNr', ['#abb2bf', '145'], ['#2c323c', '16'], 'none')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi CursorLineNr guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi CursorLineNr ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi CursorLineNr guibg=#2c323c[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi CursorLineNr ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi CursorLineNr gui=none[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi CursorLineNr cterm=none[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 373:   call <sid>X('MatchParen',   s:hue_5,         s:syntax_cursor,  'underline,bold')[J

calling <SNR>12_X[J('MatchParen', ['#e06c75', '168'], ['#2c323c', '16'], 'underline,bold')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi MatchParen guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi MatchParen ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi MatchParen guibg=#2c323c[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi MatchParen ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi MatchParen gui=underline,bold[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi MatchParen cterm=underline,bold[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 374:   call <sid>X('Italic',       '',              '',               s:italic)[J

calling <SNR>12_X[J('Italic', '', '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 375:   call <sid>X('ModeMsg',      s:syntax_fg,     '',               '')[J

calling <SNR>12_X[J('ModeMsg', ['#abb2bf', '145'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi ModeMsg guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi ModeMsg ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 376:   call <sid>X('MoreMsg',      s:syntax_fg,     '',               '')[J

calling <SNR>12_X[J('MoreMsg', ['#abb2bf', '145'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi MoreMsg guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi MoreMsg ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 377:   call <sid>X('NonText',      s:mono_3,        '',               'none')[J

calling <SNR>12_X[J('NonText', ['#5c6370', '59'], '', 'none')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi NonText guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi NonText ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi NonText gui=none[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi NonText cterm=none[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 378:   call <sid>X('PMenu',        '',              s:pmenu,          '')[J

calling <SNR>12_X[J('PMenu', '', ['#333841', '16'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi PMenu guibg=#333841[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi PMenu ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 379:   call <sid>X('PMenuSel',     '',              s:mono_4,         '')[J

calling <SNR>12_X[J('PMenuSel', '', ['#4b5263', '59'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi PMenuSel guibg=#4b5263[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi PMenuSel ctermbg=59[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 380:   call <sid>X('PMenuSbar',    '',              s:syntax_bg,      '')[J

calling <SNR>12_X[J('PMenuSbar', '', ['#282c34', '16'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi PMenuSbar guibg=#282c34[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi PMenuSbar ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 381:   call <sid>X('PMenuThumb',   '',              s:mono_1,         '')[J

calling <SNR>12_X[J('PMenuThumb', '', ['#abb2bf', '145'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi PMenuThumb guibg=#abb2bf[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi PMenuThumb ctermbg=145[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 382:   call <sid>X('Question',     s:hue_2,         '',               '')[J

calling <SNR>12_X[J('Question', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Question guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Question ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 383:   call <sid>X('Search',       s:syntax_bg,     s:hue_6_2,        '')[J

calling <SNR>12_X[J('Search', ['#282c34', '16'], ['#e5c07b', '180'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Search guifg=#282c34[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Search ctermfg=16[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi Search guibg=#e5c07b[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi Search ctermbg=180[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 384:   call <sid>X('SpecialKey',   s:special_grey,  '',               'none')[J

calling <SNR>12_X[J('SpecialKey', ['#3b4048', '16'], '', 'none')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi SpecialKey guifg=#3b4048[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi SpecialKey ctermfg=16[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi SpecialKey gui=none[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi SpecialKey cterm=none[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 385:   call <sid>X('Whitespace',   s:special_grey,  '',               'none')[J

calling <SNR>12_X[J('Whitespace', ['#3b4048', '16'], '', 'none')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Whitespace guifg=#3b4048[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Whitespace ctermfg=16[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi Whitespace gui=none[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi Whitespace cterm=none[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 386:   call <sid>X('StatusLine',   s:syntax_fg,     s:syntax_cursor,  'none')[J

calling <SNR>12_X[J('StatusLine', ['#abb2bf', '145'], ['#2c323c', '16'], 'none')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi StatusLine guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi StatusLine ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi StatusLine guibg=#2c323c[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi StatusLine ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi StatusLine gui=none[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi StatusLine cterm=none[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 387:   call <sid>X('StatusLineNC', s:mono_3,        '',               '')[J

calling <SNR>12_X[J('StatusLineNC', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi StatusLineNC guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi StatusLineNC ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 388:   call <sid>X('TabLine',      s:mono_2,        s:visual_grey,    'none')[J

calling <SNR>12_X[J('TabLine', ['#828997', '102'], ['#3e4452', '17'], 'none')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi TabLine guifg=#828997[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi TabLine ctermfg=102[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi TabLine guibg=#3e4452[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi TabLine ctermbg=17[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi TabLine gui=none[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi TabLine cterm=none[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 389:   call <sid>X('TabLineFill',  s:mono_3,        s:visual_grey,    'none')[J

calling <SNR>12_X[J('TabLineFill', ['#5c6370', '59'], ['#3e4452', '17'], 'none')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi TabLineFill guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi TabLineFill ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi TabLineFill guibg=#3e4452[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi TabLineFill ctermbg=17[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi TabLineFill gui=none[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi TabLineFill cterm=none[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 390:   call <sid>X('TabLineSel',   s:syntax_bg,     s:hue_2,          '')[J

calling <SNR>12_X[J('TabLineSel', ['#282c34', '16'], ['#61afef', '75'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi TabLineSel guifg=#282c34[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi TabLineSel ctermfg=16[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi TabLineSel guibg=#61afef[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi TabLineSel ctermbg=75[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 391:   call <sid>X('Title',        s:syntax_fg,     '',               'bold')[J

calling <SNR>12_X[J('Title', ['#abb2bf', '145'], '', 'bold')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Title guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Title ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi Title gui=bold[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi Title cterm=bold[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 392:   call <sid>X('Visual',       '',              s:visual_grey,    '')[J

calling <SNR>12_X[J('Visual', '', ['#3e4452', '17'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi Visual guibg=#3e4452[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi Visual ctermbg=17[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 393:   call <sid>X('VisualNOS',    '',              s:visual_grey,    '')[J

calling <SNR>12_X[J('VisualNOS', '', ['#3e4452', '17'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi VisualNOS guibg=#3e4452[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi VisualNOS ctermbg=17[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 394:   call <sid>X('WarningMsg',   s:hue_5,         '',               '')[J

calling <SNR>12_X[J('WarningMsg', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi WarningMsg guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi WarningMsg ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 395:   call <sid>X('TooLong',      s:hue_5,         '',               '')[J

calling <SNR>12_X[J('TooLong', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi TooLong guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi TooLong ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 396:   call <sid>X('WildMenu',     s:syntax_fg,     s:mono_3,         '')[J

calling <SNR>12_X[J('WildMenu', ['#abb2bf', '145'], ['#5c6370', '59'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi WildMenu guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi WildMenu ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi WildMenu guibg=#5c6370[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi WildMenu ctermbg=59[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 397:   call <sid>X('SignColumn',   '',              s:syntax_bg,      '')[J

calling <SNR>12_X[J('SignColumn', '', ['#282c34', '16'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi SignColumn guibg=#282c34[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi SignColumn ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 398:   call <sid>X('Special',      s:hue_2,         '',               '')[J

calling <SNR>12_X[J('Special', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Special guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Special ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 399:   " }}}[J

line 400: [J

line 401:   " Vim Help highlighting ---------------------------------------------------{{{[J

line 402:   call <sid>X('helpCommand',      s:hue_6_2, '', '')[J

calling <SNR>12_X[J('helpCommand', ['#e5c07b', '180'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi helpCommand guifg=#e5c07b[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi helpCommand ctermfg=180[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 403:   call <sid>X('helpExample',      s:hue_6_2, '', '')[J

calling <SNR>12_X[J('helpExample', ['#e5c07b', '180'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi helpExample guifg=#e5c07b[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi helpExample ctermfg=180[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 404:   call <sid>X('helpHeader',       s:mono_1,  '', 'bold')[J

calling <SNR>12_X[J('helpHeader', ['#abb2bf', '145'], '', 'bold')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi helpHeader guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi helpHeader ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi helpHeader gui=bold[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi helpHeader cterm=bold[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 405:   call <sid>X('helpSectionDelim', s:mono_3,  '', '')[J

calling <SNR>12_X[J('helpSectionDelim', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi helpSectionDelim guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi helpSectionDelim ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 406:   " }}}[J

line 407: [J

line 408:   " Standard syntax highlighting --------------------------------------------{{{[J

line 409:   call <sid>X('Comment',        s:mono_3,        '',          s:italic)[J

calling <SNR>12_X[J('Comment', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Comment guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Comment ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 410:   call <sid>X('Constant',       s:hue_4,         '',          '')[J

calling <SNR>12_X[J('Constant', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Constant guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Constant ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 411:   call <sid>X('String',         s:hue_4,         '',          '')[J

calling <SNR>12_X[J('String', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi String guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi String ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 412:   call <sid>X('Character',      s:hue_4,         '',          '')[J

calling <SNR>12_X[J('Character', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Character guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Character ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 413:   call <sid>X('Number',         s:hue_6,         '',          '')[J

calling <SNR>12_X[J('Number', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Number guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Number ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 414:   call <sid>X('Boolean',        s:hue_6,         '',          '')[J

calling <SNR>12_X[J('Boolean', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Boolean guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Boolean ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 415:   call <sid>X('Float',          s:hue_6,         '',          '')[J

calling <SNR>12_X[J('Float', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Float guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Float ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 416:   call <sid>X('Identifier',     s:hue_5,         '',          'none')[J

calling <SNR>12_X[J('Identifier', ['#e06c75', '168'], '', 'none')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Identifier guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Identifier ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi Identifier gui=none[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi Identifier cterm=none[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 417:   call <sid>X('Function',       s:hue_2,         '',          '')[J

calling <SNR>12_X[J('Function', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Function guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Function ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 418:   call <sid>X('Statement',      s:hue_3,         '',          'none')[J

calling <SNR>12_X[J('Statement', ['#c678dd', '176'], '', 'none')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Statement guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Statement ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi Statement gui=none[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi Statement cterm=none[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 419:   call <sid>X('Conditional',    s:hue_3,         '',          '')[J

calling <SNR>12_X[J('Conditional', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Conditional guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Conditional ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 420:   call <sid>X('Repeat',         s:hue_3,         '',          '')[J

calling <SNR>12_X[J('Repeat', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Repeat guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Repeat ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 421:   call <sid>X('Label',          s:hue_3,         '',          '')[J

calling <SNR>12_X[J('Label', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Label guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Label ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 422:   call <sid>X('Operator',       s:syntax_accent, '',          'none')[J

calling <SNR>12_X[J('Operator', ['#528bff', '69'], '', 'none')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Operator guifg=#528bff[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Operator ctermfg=69[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi Operator gui=none[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi Operator cterm=none[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 423:   call <sid>X('Keyword',        s:hue_5,         '',          '')[J

calling <SNR>12_X[J('Keyword', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Keyword guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Keyword ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 424:   call <sid>X('Exception',      s:hue_3,         '',          '')[J

calling <SNR>12_X[J('Exception', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Exception guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Exception ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 425:   call <sid>X('PreProc',        s:hue_6_2,       '',          '')[J

calling <SNR>12_X[J('PreProc', ['#e5c07b', '180'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi PreProc guifg=#e5c07b[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi PreProc ctermfg=180[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 426:   call <sid>X('Include',        s:hue_2,         '',          '')[J

calling <SNR>12_X[J('Include', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Include guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Include ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 427:   call <sid>X('Define',         s:hue_3,         '',          'none')[J

calling <SNR>12_X[J('Define', ['#c678dd', '176'], '', 'none')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Define guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Define ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi Define gui=none[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi Define cterm=none[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 428:   call <sid>X('Macro',          s:hue_3,         '',          '')[J

calling <SNR>12_X[J('Macro', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Macro guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Macro ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 429:   call <sid>X('PreCondit',      s:hue_6_2,       '',          '')[J

calling <SNR>12_X[J('PreCondit', ['#e5c07b', '180'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi PreCondit guifg=#e5c07b[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi PreCondit ctermfg=180[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 430:   call <sid>X('Type',           s:hue_6_2,       '',          'none')[J

calling <SNR>12_X[J('Type', ['#e5c07b', '180'], '', 'none')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Type guifg=#e5c07b[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Type ctermfg=180[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi Type gui=none[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi Type cterm=none[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 431:   call <sid>X('StorageClass',   s:hue_6_2,       '',          '')[J

calling <SNR>12_X[J('StorageClass', ['#e5c07b', '180'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi StorageClass guifg=#e5c07b[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi StorageClass ctermfg=180[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 432:   call <sid>X('Structure',      s:hue_6_2,       '',          '')[J

calling <SNR>12_X[J('Structure', ['#e5c07b', '180'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Structure guifg=#e5c07b[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Structure ctermfg=180[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 433:   call <sid>X('Typedef',        s:hue_6_2,       '',          '')[J

calling <SNR>12_X[J('Typedef', ['#e5c07b', '180'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Typedef guifg=#e5c07b[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Typedef ctermfg=180[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 434:   call <sid>X('Special',        s:hue_2,         '',          '')[J

calling <SNR>12_X[J('Special', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Special guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Special ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 435:   call <sid>X('SpecialChar',    '',              '',          '')[J

calling <SNR>12_X[J('SpecialChar', '', '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 436:   call <sid>X('Tag',            '',              '',          '')[J

calling <SNR>12_X[J('Tag', '', '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 437:   call <sid>X('Delimiter',      '',              '',          '')[J

calling <SNR>12_X[J('Delimiter', '', '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 438:   call <sid>X('SpecialComment', '',              '',          '')[J

calling <SNR>12_X[J('SpecialComment', '', '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 439:   call <sid>X('Debug',          '',              '',          '')[J

calling <SNR>12_X[J('Debug', '', '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 440:   call <sid>X('Underlined',     '',              '',          'underline')[J

calling <SNR>12_X[J('Underlined', '', '', 'underline')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi Underlined gui=underline[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi Underlined cterm=underline[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 441:   call <sid>X('Ignore',         '',              '',          '')[J

calling <SNR>12_X[J('Ignore', '', '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 442:   call <sid>X('Error',          s:hue_5,         s:syntax_bg, 'bold')[J

calling <SNR>12_X[J('Error', ['#e06c75', '168'], ['#282c34', '16'], 'bold')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Error guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Error ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi Error guibg=#282c34[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi Error ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi Error gui=bold[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi Error cterm=bold[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 443:   call <sid>X('Todo',           s:hue_3,         s:syntax_bg, '')[J

calling <SNR>12_X[J('Todo', ['#c678dd', '176'], ['#282c34', '16'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi Todo guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi Todo ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi Todo guibg=#282c34[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi Todo ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 444:   " }}}[J

line 445: [J

line 446:   " Diff highlighting -------------------------------------------------------{{{[J

line 447:   call <sid>X('DiffAdd',     s:hue_4, s:visual_grey, '')[J

calling <SNR>12_X[J('DiffAdd', ['#98c379', '114'], ['#3e4452', '17'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi DiffAdd guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi DiffAdd ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi DiffAdd guibg=#3e4452[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi DiffAdd ctermbg=17[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 448:   call <sid>X('DiffChange',  s:hue_6, s:visual_grey, '')[J

calling <SNR>12_X[J('DiffChange', ['#d19a66', '173'], ['#3e4452', '17'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi DiffChange guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi DiffChange ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi DiffChange guibg=#3e4452[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi DiffChange ctermbg=17[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 449:   call <sid>X('DiffDelete',  s:hue_5, s:visual_grey, '')[J

calling <SNR>12_X[J('DiffDelete', ['#e06c75', '168'], ['#3e4452', '17'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi DiffDelete guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi DiffDelete ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi DiffDelete guibg=#3e4452[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi DiffDelete ctermbg=17[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 450:   call <sid>X('DiffText',    s:hue_2, s:visual_grey, '')[J

calling <SNR>12_X[J('DiffText', ['#61afef', '75'], ['#3e4452', '17'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi DiffText guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi DiffText ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi DiffText guibg=#3e4452[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi DiffText ctermbg=17[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 451:   call <sid>X('DiffAdded',   s:hue_4, s:visual_grey, '')[J

calling <SNR>12_X[J('DiffAdded', ['#98c379', '114'], ['#3e4452', '17'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi DiffAdded guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi DiffAdded ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi DiffAdded guibg=#3e4452[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi DiffAdded ctermbg=17[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 452:   call <sid>X('DiffFile',    s:hue_5, s:visual_grey, '')[J

calling <SNR>12_X[J('DiffFile', ['#e06c75', '168'], ['#3e4452', '17'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi DiffFile guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi DiffFile ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi DiffFile guibg=#3e4452[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi DiffFile ctermbg=17[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 453:   call <sid>X('DiffNewFile', s:hue_4, s:visual_grey, '')[J

calling <SNR>12_X[J('DiffNewFile', ['#98c379', '114'], ['#3e4452', '17'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi DiffNewFile guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi DiffNewFile ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi DiffNewFile guibg=#3e4452[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi DiffNewFile ctermbg=17[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 454:   call <sid>X('DiffLine',    s:hue_2, s:visual_grey, '')[J

calling <SNR>12_X[J('DiffLine', ['#61afef', '75'], ['#3e4452', '17'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi DiffLine guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi DiffLine ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi DiffLine guibg=#3e4452[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi DiffLine ctermbg=17[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 455:   call <sid>X('DiffRemoved', s:hue_5, s:visual_grey, '')[J

calling <SNR>12_X[J('DiffRemoved', ['#e06c75', '168'], ['#3e4452', '17'], '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi DiffRemoved guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi DiffRemoved ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi DiffRemoved guibg=#3e4452[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi DiffRemoved ctermbg=17[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 456:   " }}}[J

line 457: [J

line 458:   " Asciidoc highlighting ---------------------------------------------------{{{[J

line 459:   call <sid>X('asciidocListingBlock',   s:mono_2,  '', '')[J

calling <SNR>12_X[J('asciidocListingBlock', ['#828997', '102'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi asciidocListingBlock guifg=#828997[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi asciidocListingBlock ctermfg=102[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 460:   " }}}[J

line 461: [J

line 462:   " C/C++ highlighting ------------------------------------------------------{{{[J

line 463:   call <sid>X('cInclude',           s:hue_3,  '', '')[J

calling <SNR>12_X[J('cInclude', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cInclude guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cInclude ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 464:   call <sid>X('cPreCondit',         s:hue_3,  '', '')[J

calling <SNR>12_X[J('cPreCondit', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cPreCondit guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cPreCondit ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 465:   call <sid>X('cPreConditMatch',    s:hue_3,  '', '')[J

calling <SNR>12_X[J('cPreConditMatch', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cPreConditMatch guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cPreConditMatch ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 466: [J

line 467:   call <sid>X('cType',              s:hue_3,  '', '')[J

calling <SNR>12_X[J('cType', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cType guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cType ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 468:   call <sid>X('cStorageClass',      s:hue_3,  '', '')[J

calling <SNR>12_X[J('cStorageClass', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cStorageClass guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cStorageClass ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 469:   call <sid>X('cStructure',         s:hue_3,  '', '')[J

calling <SNR>12_X[J('cStructure', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cStructure guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cStructure ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 470:   call <sid>X('cOperator',          s:hue_3,  '', '')[J

calling <SNR>12_X[J('cOperator', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cOperator guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cOperator ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 471:   call <sid>X('cStatement',         s:hue_3,  '', '')[J

calling <SNR>12_X[J('cStatement', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cStatement guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cStatement ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 472:   call <sid>X('cTODO',              s:hue_3,  '', '')[J

calling <SNR>12_X[J('cTODO', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cTODO guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cTODO ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 473:   call <sid>X('cConstant',          s:hue_6,  '', '')[J

calling <SNR>12_X[J('cConstant', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cConstant guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cConstant ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 474:   call <sid>X('cSpecial',           s:hue_1,  '', '')[J

calling <SNR>12_X[J('cSpecial', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cSpecial guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cSpecial ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 475:   call <sid>X('cSpecialCharacter',  s:hue_1,  '', '')[J

calling <SNR>12_X[J('cSpecialCharacter', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cSpecialCharacter guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cSpecialCharacter ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 476:   call <sid>X('cString',            s:hue_4,  '', '')[J

calling <SNR>12_X[J('cString', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cString guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cString ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 477: [J

line 478:   call <sid>X('cppType',            s:hue_3,  '', '')[J

calling <SNR>12_X[J('cppType', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cppType guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cppType ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 479:   call <sid>X('cppStorageClass',    s:hue_3,  '', '')[J

calling <SNR>12_X[J('cppStorageClass', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cppStorageClass guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cppStorageClass ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 480:   call <sid>X('cppStructure',       s:hue_3,  '', '')[J

calling <SNR>12_X[J('cppStructure', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cppStructure guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cppStructure ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 481:   call <sid>X('cppModifier',        s:hue_3,  '', '')[J

calling <SNR>12_X[J('cppModifier', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cppModifier guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cppModifier ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 482:   call <sid>X('cppOperator',        s:hue_3,  '', '')[J

calling <SNR>12_X[J('cppOperator', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cppOperator guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cppOperator ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 483:   call <sid>X('cppAccess',          s:hue_3,  '', '')[J

calling <SNR>12_X[J('cppAccess', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cppAccess guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cppAccess ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 484:   call <sid>X('cppStatement',       s:hue_3,  '', '')[J

calling <SNR>12_X[J('cppStatement', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cppStatement guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cppStatement ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 485:   call <sid>X('cppConstant',        s:hue_5,  '', '')[J

calling <SNR>12_X[J('cppConstant', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cppConstant guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cppConstant ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 486:   call <sid>X('cCppString',         s:hue_4,  '', '')[J

calling <SNR>12_X[J('cCppString', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cCppString guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cCppString ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 487:   " }}}[J

line 488: [J

line 489:   " Cucumber highlighting ---------------------------------------------------{{{[J

line 490:   call <sid>X('cucumberGiven',           s:hue_2,  '', '')[J

calling <SNR>12_X[J('cucumberGiven', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cucumberGiven guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cucumberGiven ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 491:   call <sid>X('cucumberWhen',            s:hue_2,  '', '')[J

calling <SNR>12_X[J('cucumberWhen', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cucumberWhen guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cucumberWhen ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 492:   call <sid>X('cucumberWhenAnd',         s:hue_2,  '', '')[J

calling <SNR>12_X[J('cucumberWhenAnd', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cucumberWhenAnd guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cucumberWhenAnd ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 493:   call <sid>X('cucumberThen',            s:hue_2,  '', '')[J

calling <SNR>12_X[J('cucumberThen', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cucumberThen guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cucumberThen ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 494:   call <sid>X('cucumberThenAnd',         s:hue_2,  '', '')[J

calling <SNR>12_X[J('cucumberThenAnd', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cucumberThenAnd guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cucumberThenAnd ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 495:   call <sid>X('cucumberUnparsed',        s:hue_6,  '', '')[J

calling <SNR>12_X[J('cucumberUnparsed', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cucumberUnparsed guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cucumberUnparsed ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 496:   call <sid>X('cucumberFeature',         s:hue_5,  '', 'bold')[J

calling <SNR>12_X[J('cucumberFeature', ['#e06c75', '168'], '', 'bold')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cucumberFeature guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cucumberFeature ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi cucumberFeature gui=bold[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi cucumberFeature cterm=bold[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 497:   call <sid>X('cucumberBackground',      s:hue_3,  '', 'bold')[J

calling <SNR>12_X[J('cucumberBackground', ['#c678dd', '176'], '', 'bold')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cucumberBackground guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cucumberBackground ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi cucumberBackground gui=bold[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi cucumberBackground cterm=bold[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 498:   call <sid>X('cucumberScenario',        s:hue_3,  '', 'bold')[J

calling <SNR>12_X[J('cucumberScenario', ['#c678dd', '176'], '', 'bold')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cucumberScenario guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cucumberScenario ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi cucumberScenario gui=bold[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi cucumberScenario cterm=bold[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 499:   call <sid>X('cucumberScenarioOutline', s:hue_3,  '', 'bold')[J

calling <SNR>12_X[J('cucumberScenarioOutline', ['#c678dd', '176'], '', 'bold')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cucumberScenarioOutline guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cucumberScenarioOutline ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi cucumberScenarioOutline gui=bold[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi cucumberScenarioOutline cterm=bold[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 500:   call <sid>X('cucumberTags',            s:mono_3, '', 'bold')[J

calling <SNR>12_X[J('cucumberTags', ['#5c6370', '59'], '', 'bold')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cucumberTags guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cucumberTags ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi cucumberTags gui=bold[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi cucumberTags cterm=bold[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 501:   call <sid>X('cucumberDelimiter',       s:mono_3, '', 'bold')[J

calling <SNR>12_X[J('cucumberDelimiter', ['#5c6370', '59'], '', 'bold')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cucumberDelimiter guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cucumberDelimiter ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi cucumberDelimiter gui=bold[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi cucumberDelimiter cterm=bold[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 502:   " }}}[J

line 503: [J

line 504:   " CSS/Sass highlighting ---------------------------------------------------{{{[J

line 505:   call <sid>X('cssAttrComma',         s:hue_3,  '', '')[J

calling <SNR>12_X[J('cssAttrComma', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssAttrComma guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssAttrComma ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 506:   call <sid>X('cssAttributeSelector', s:hue_4,  '', '')[J

calling <SNR>12_X[J('cssAttributeSelector', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssAttributeSelector guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssAttributeSelector ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 507:   call <sid>X('cssBraces',            s:mono_2, '', '')[J

calling <SNR>12_X[J('cssBraces', ['#828997', '102'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssBraces guifg=#828997[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssBraces ctermfg=102[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 508:   call <sid>X('cssClassName',         s:hue_6,  '', '')[J

calling <SNR>12_X[J('cssClassName', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssClassName guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssClassName ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 509:   call <sid>X('cssClassNameDot',      s:hue_6,  '', '')[J

calling <SNR>12_X[J('cssClassNameDot', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssClassNameDot guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssClassNameDot ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 510:   call <sid>X('cssDefinition',        s:hue_3,  '', '')[J

calling <SNR>12_X[J('cssDefinition', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssDefinition guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssDefinition ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 511:   call <sid>X('cssFontAttr',          s:hue_6,  '', '')[J

calling <SNR>12_X[J('cssFontAttr', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssFontAttr guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssFontAttr ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 512:   call <sid>X('cssFontDescriptor',    s:hue_3,  '', '')[J

calling <SNR>12_X[J('cssFontDescriptor', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssFontDescriptor guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssFontDescriptor ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 513:   call <sid>X('cssFunctionName',      s:hue_2,  '', '')[J

calling <SNR>12_X[J('cssFunctionName', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssFunctionName guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssFunctionName ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 514:   call <sid>X('cssIdentifier',        s:hue_2,  '', '')[J

calling <SNR>12_X[J('cssIdentifier', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssIdentifier guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssIdentifier ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 515:   call <sid>X('cssImportant',         s:hue_3,  '', '')[J

calling <SNR>12_X[J('cssImportant', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssImportant guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssImportant ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 516:   call <sid>X('cssInclude',           s:mono_1, '', '')[J

calling <SNR>12_X[J('cssInclude', ['#abb2bf', '145'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssInclude guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssInclude ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 517:   call <sid>X('cssIncludeKeyword',    s:hue_3,  '', '')[J

calling <SNR>12_X[J('cssIncludeKeyword', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssIncludeKeyword guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssIncludeKeyword ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 518:   call <sid>X('cssMediaType',         s:hue_6,  '', '')[J

calling <SNR>12_X[J('cssMediaType', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssMediaType guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssMediaType ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 519:   call <sid>X('cssProp',              s:hue_1,  '', '')[J

calling <SNR>12_X[J('cssProp', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssProp guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssProp ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 520:   call <sid>X('cssPseudoClassId',     s:hue_6,  '', '')[J

calling <SNR>12_X[J('cssPseudoClassId', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssPseudoClassId guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssPseudoClassId ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 521:   call <sid>X('cssSelectorOp',        s:hue_3,  '', '')[J

calling <SNR>12_X[J('cssSelectorOp', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssSelectorOp guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssSelectorOp ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 522:   call <sid>X('cssSelectorOp2',       s:hue_3,  '', '')[J

calling <SNR>12_X[J('cssSelectorOp2', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssSelectorOp2 guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssSelectorOp2 ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 523:   call <sid>X('cssStringQ',           s:hue_4,  '', '')[J

calling <SNR>12_X[J('cssStringQ', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssStringQ guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssStringQ ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 524:   call <sid>X('cssStringQQ',          s:hue_4,  '', '')[J

calling <SNR>12_X[J('cssStringQQ', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssStringQQ guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssStringQQ ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 525:   call <sid>X('cssTagName',           s:hue_5,  '', '')[J

calling <SNR>12_X[J('cssTagName', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssTagName guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssTagName ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 526:   call <sid>X('cssAttr',              s:hue_6,  '', '')[J

calling <SNR>12_X[J('cssAttr', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi cssAttr guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi cssAttr ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 527: [J

line 528:   call <sid>X('sassAmpersand',      s:hue_5,   '', '')[J

calling <SNR>12_X[J('sassAmpersand', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi sassAmpersand guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi sassAmpersand ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 529:   call <sid>X('sassClass',          s:hue_6_2, '', '')[J

calling <SNR>12_X[J('sassClass', ['#e5c07b', '180'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi sassClass guifg=#e5c07b[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi sassClass ctermfg=180[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 530:   call <sid>X('sassControl',        s:hue_3,   '', '')[J

calling <SNR>12_X[J('sassControl', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi sassControl guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi sassControl ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 531:   call <sid>X('sassExtend',         s:hue_3,   '', '')[J

calling <SNR>12_X[J('sassExtend', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi sassExtend guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi sassExtend ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 532:   call <sid>X('sassFor',            s:mono_1,  '', '')[J

calling <SNR>12_X[J('sassFor', ['#abb2bf', '145'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi sassFor guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi sassFor ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 533:   call <sid>X('sassProperty',       s:hue_1,   '', '')[J

calling <SNR>12_X[J('sassProperty', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi sassProperty guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi sassProperty ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 534:   call <sid>X('sassFunction',       s:hue_1,   '', '')[J

calling <SNR>12_X[J('sassFunction', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi sassFunction guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi sassFunction ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 535:   call <sid>X('sassId',             s:hue_2,   '', '')[J

calling <SNR>12_X[J('sassId', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi sassId guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi sassId ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 536:   call <sid>X('sassInclude',        s:hue_3,   '', '')[J

calling <SNR>12_X[J('sassInclude', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi sassInclude guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi sassInclude ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 537:   call <sid>X('sassMedia',          s:hue_3,   '', '')[J

calling <SNR>12_X[J('sassMedia', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi sassMedia guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi sassMedia ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 538:   call <sid>X('sassMediaOperators', s:mono_1,  '', '')[J

calling <SNR>12_X[J('sassMediaOperators', ['#abb2bf', '145'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi sassMediaOperators guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi sassMediaOperators ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 539:   call <sid>X('sassMixin',          s:hue_3,   '', '')[J

calling <SNR>12_X[J('sassMixin', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi sassMixin guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi sassMixin ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 540:   call <sid>X('sassMixinName',      s:hue_2,   '', '')[J

calling <SNR>12_X[J('sassMixinName', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi sassMixinName guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi sassMixinName ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 541:   call <sid>X('sassMixing',         s:hue_3,   '', '')[J

calling <SNR>12_X[J('sassMixing', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi sassMixing guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi sassMixing ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 542: [J

line 543:   call <sid>X('scssSelectorName',   s:hue_6_2, '', '')[J

calling <SNR>12_X[J('scssSelectorName', ['#e5c07b', '180'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi scssSelectorName guifg=#e5c07b[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi scssSelectorName ctermfg=180[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 544:   " }}}[J

line 545: [J

line 546:   " Elixir highlighting------------------------------------------------------{{{[J

line 547:   hi link elixirModuleDefine Define[J

line 548:   call <sid>X('elixirAlias',             s:hue_6_2, '', '')[J

calling <SNR>12_X[J('elixirAlias', ['#e5c07b', '180'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi elixirAlias guifg=#e5c07b[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi elixirAlias ctermfg=180[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 549:   call <sid>X('elixirAtom',              s:hue_1,   '', '')[J

calling <SNR>12_X[J('elixirAtom', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi elixirAtom guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi elixirAtom ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 550:   call <sid>X('elixirBlockDefinition',   s:hue_3,   '', '')[J

calling <SNR>12_X[J('elixirBlockDefinition', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi elixirBlockDefinition guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi elixirBlockDefinition ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 551:   call <sid>X('elixirModuleDeclaration', s:hue_6,   '', '')[J

calling <SNR>12_X[J('elixirModuleDeclaration', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi elixirModuleDeclaration guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi elixirModuleDeclaration ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 552:   call <sid>X('elixirInclude',           s:hue_5,   '', '')[J

calling <SNR>12_X[J('elixirInclude', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi elixirInclude guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi elixirInclude ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 553:   call <sid>X('elixirOperator',          s:hue_6,   '', '')[J

calling <SNR>12_X[J('elixirOperator', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi elixirOperator guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi elixirOperator ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 554:   " }}}[J

line 555: [J

line 556:   " Git and git related plugins highlighting --------------------------------{{{[J

line 557:   call <sid>X('gitcommitComment',       s:mono_3,  '', '')[J

calling <SNR>12_X[J('gitcommitComment', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi gitcommitComment guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi gitcommitComment ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 558:   call <sid>X('gitcommitUnmerged',      s:hue_4,   '', '')[J

calling <SNR>12_X[J('gitcommitUnmerged', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi gitcommitUnmerged guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi gitcommitUnmerged ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 559:   call <sid>X('gitcommitOnBranch',      '',        '', '')[J

calling <SNR>12_X[J('gitcommitOnBranch', '', '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 560:   call <sid>X('gitcommitBranch',        s:hue_3,   '', '')[J

calling <SNR>12_X[J('gitcommitBranch', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi gitcommitBranch guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi gitcommitBranch ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 561:   call <sid>X('gitcommitDiscardedType', s:hue_5,   '', '')[J

calling <SNR>12_X[J('gitcommitDiscardedType', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi gitcommitDiscardedType guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi gitcommitDiscardedType ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 562:   call <sid>X('gitcommitSelectedType',  s:hue_4,   '', '')[J

calling <SNR>12_X[J('gitcommitSelectedType', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi gitcommitSelectedType guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi gitcommitSelectedType ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 563:   call <sid>X('gitcommitHeader',        '',        '', '')[J

calling <SNR>12_X[J('gitcommitHeader', '', '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 564:   call <sid>X('gitcommitUntrackedFile', s:hue_1,   '', '')[J

calling <SNR>12_X[J('gitcommitUntrackedFile', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi gitcommitUntrackedFile guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi gitcommitUntrackedFile ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 565:   call <sid>X('gitcommitDiscardedFile', s:hue_5,   '', '')[J

calling <SNR>12_X[J('gitcommitDiscardedFile', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi gitcommitDiscardedFile guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi gitcommitDiscardedFile ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 566:   call <sid>X('gitcommitSelectedFile',  s:hue_4,   '', '')[J

calling <SNR>12_X[J('gitcommitSelectedFile', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi gitcommitSelectedFile guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi gitcommitSelectedFile ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 567:   call <sid>X('gitcommitUnmergedFile',  s:hue_6_2, '', '')[J

calling <SNR>12_X[J('gitcommitUnmergedFile', ['#e5c07b', '180'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi gitcommitUnmergedFile guifg=#e5c07b[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi gitcommitUnmergedFile ctermfg=180[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 568:   call <sid>X('gitcommitFile',          '',        '', '')[J

calling <SNR>12_X[J('gitcommitFile', '', '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 569:   hi link gitcommitNoBranch       gitcommitBranch[J

line 570:   hi link gitcommitUntracked      gitcommitComment[J

line 571:   hi link gitcommitDiscarded      gitcommitComment[J

line 572:   hi link gitcommitSelected       gitcommitComment[J

line 573:   hi link gitcommitDiscardedArrow gitcommitDiscardedFile[J

line 574:   hi link gitcommitSelectedArrow  gitcommitSelectedFile[J

line 575:   hi link gitcommitUnmergedArrow  gitcommitUnmergedFile[J

line 576: [J

line 577:   call <sid>X('SignifySignAdd',    s:hue_4,   '', '')[J

calling <SNR>12_X[J('SignifySignAdd', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi SignifySignAdd guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi SignifySignAdd ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 578:   call <sid>X('SignifySignChange', s:hue_6_2, '', '')[J

calling <SNR>12_X[J('SignifySignChange', ['#e5c07b', '180'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi SignifySignChange guifg=#e5c07b[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi SignifySignChange ctermfg=180[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 579:   call <sid>X('SignifySignDelete', s:hue_5,   '', '')[J

calling <SNR>12_X[J('SignifySignDelete', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi SignifySignDelete guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi SignifySignDelete ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 580:   hi link GitGutterAdd    SignifySignAdd[J

line 581:   hi link GitGutterChange SignifySignChange[J

line 582:   hi link GitGutterDelete SignifySignDelete[J

line 583:   call <sid>X('diffAdded',         s:hue_4,   '', '')[J

calling <SNR>12_X[J('diffAdded', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi diffAdded guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi diffAdded ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 584:   call <sid>X('diffRemoved',       s:hue_5,   '', '')[J

calling <SNR>12_X[J('diffRemoved', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi diffRemoved guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi diffRemoved ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 585:   " }}}[J

line 586: [J

line 587:   " Go highlighting ---------------------------------------------------------{{{[J

line 588:   call <sid>X('goDeclaration',         s:hue_3, '', '')[J

calling <SNR>12_X[J('goDeclaration', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi goDeclaration guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi goDeclaration ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 589:   call <sid>X('goField',               s:hue_5, '', '')[J

calling <SNR>12_X[J('goField', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi goField guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi goField ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 590:   call <sid>X('goMethod',              s:hue_1, '', '')[J

calling <SNR>12_X[J('goMethod', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi goMethod guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi goMethod ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 591:   call <sid>X('goType',                s:hue_3, '', '')[J

calling <SNR>12_X[J('goType', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi goType guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi goType ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 592:   call <sid>X('goUnsignedInts',        s:hue_1, '', '')[J

calling <SNR>12_X[J('goUnsignedInts', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi goUnsignedInts guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi goUnsignedInts ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 593:   " }}}[J

line 594: [J

line 595:   " Haskell highlighting ----------------------------------------------------{{{[J

line 596:   call <sid>X('haskellDeclKeyword',    s:hue_2, '', '')[J

calling <SNR>12_X[J('haskellDeclKeyword', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi haskellDeclKeyword guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi haskellDeclKeyword ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 597:   call <sid>X('haskellType',           s:hue_4, '', '')[J

calling <SNR>12_X[J('haskellType', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi haskellType guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi haskellType ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 598:   call <sid>X('haskellWhere',          s:hue_5, '', '')[J

calling <SNR>12_X[J('haskellWhere', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi haskellWhere guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi haskellWhere ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 599:   call <sid>X('haskellImportKeywords', s:hue_2, '', '')[J

calling <SNR>12_X[J('haskellImportKeywords', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi haskellImportKeywords guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi haskellImportKeywords ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 600:   call <sid>X('haskellOperators',      s:hue_5, '', '')[J

calling <SNR>12_X[J('haskellOperators', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi haskellOperators guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi haskellOperators ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 601:   call <sid>X('haskellDelimiter',      s:hue_2, '', '')[J

calling <SNR>12_X[J('haskellDelimiter', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi haskellDelimiter guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi haskellDelimiter ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 602:   call <sid>X('haskellIdentifier',     s:hue_6, '', '')[J

calling <SNR>12_X[J('haskellIdentifier', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi haskellIdentifier guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi haskellIdentifier ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 603:   call <sid>X('haskellKeyword',        s:hue_5, '', '')[J

calling <SNR>12_X[J('haskellKeyword', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi haskellKeyword guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi haskellKeyword ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 604:   call <sid>X('haskellNumber',         s:hue_1, '', '')[J

calling <SNR>12_X[J('haskellNumber', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi haskellNumber guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi haskellNumber ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 605:   call <sid>X('haskellString',         s:hue_1, '', '')[J

calling <SNR>12_X[J('haskellString', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi haskellString guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi haskellString ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 606:   "}}}[J

line 607: [J

line 608:   " HTML highlighting -------------------------------------------------------{{{[J

line 609:   call <sid>X('htmlArg',            s:hue_6,  '', '')[J

calling <SNR>12_X[J('htmlArg', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi htmlArg guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi htmlArg ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 610:   call <sid>X('htmlTagName',        s:hue_5,  '', '')[J

calling <SNR>12_X[J('htmlTagName', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi htmlTagName guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi htmlTagName ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 611:   call <sid>X('htmlTagN',           s:hue_5,  '', '')[J

calling <SNR>12_X[J('htmlTagN', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi htmlTagN guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi htmlTagN ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 612:   call <sid>X('htmlSpecialTagName', s:hue_5,  '', '')[J

calling <SNR>12_X[J('htmlSpecialTagName', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi htmlSpecialTagName guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi htmlSpecialTagName ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 613:   call <sid>X('htmlTag',            s:mono_2, '', '')[J

calling <SNR>12_X[J('htmlTag', ['#828997', '102'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi htmlTag guifg=#828997[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi htmlTag ctermfg=102[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 614:   call <sid>X('htmlEndTag',         s:mono_2, '', '')[J

calling <SNR>12_X[J('htmlEndTag', ['#828997', '102'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi htmlEndTag guifg=#828997[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi htmlEndTag ctermfg=102[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 615: [J

line 616:   call <sid>X('MatchTag', s:hue_5, s:syntax_cursor, 'underline,bold')[J

calling <SNR>12_X[J('MatchTag', ['#e06c75', '168'], ['#2c323c', '16'], 'underline,bold')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi MatchTag guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi MatchTag ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi MatchTag guibg=#2c323c[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi MatchTag ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi MatchTag gui=underline,bold[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi MatchTag cterm=underline,bold[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 617:   " }}}[J

line 618: [J

line 619:   " JavaScript highlighting -------------------------------------------------{{{[J

line 620:   call <sid>X('coffeeString',           s:hue_4,   '', '')[J

calling <SNR>12_X[J('coffeeString', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi coffeeString guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi coffeeString ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 621: [J

line 622:   call <sid>X('javaScriptBraces',       s:mono_2,  '', '')[J

calling <SNR>12_X[J('javaScriptBraces', ['#828997', '102'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javaScriptBraces guifg=#828997[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javaScriptBraces ctermfg=102[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 623:   call <sid>X('javaScriptFunction',     s:hue_3,   '', '')[J

calling <SNR>12_X[J('javaScriptFunction', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javaScriptFunction guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javaScriptFunction ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 624:   call <sid>X('javaScriptIdentifier',   s:hue_3,   '', '')[J

calling <SNR>12_X[J('javaScriptIdentifier', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javaScriptIdentifier guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javaScriptIdentifier ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 625:   call <sid>X('javaScriptNull',         s:hue_6,   '', '')[J

calling <SNR>12_X[J('javaScriptNull', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javaScriptNull guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javaScriptNull ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 626:   call <sid>X('javaScriptNumber',       s:hue_6,   '', '')[J

calling <SNR>12_X[J('javaScriptNumber', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javaScriptNumber guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javaScriptNumber ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 627:   call <sid>X('javaScriptRequire',      s:hue_1,   '', '')[J

calling <SNR>12_X[J('javaScriptRequire', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javaScriptRequire guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javaScriptRequire ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 628:   call <sid>X('javaScriptReserved',     s:hue_3,   '', '')[J

calling <SNR>12_X[J('javaScriptReserved', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javaScriptReserved guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javaScriptReserved ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 629:   " https://github.com/pangloss/vim-javascript[J

line 630:   call <sid>X('jsArrowFunction',        s:hue_3,   '', '')[J

calling <SNR>12_X[J('jsArrowFunction', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsArrowFunction guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsArrowFunction ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 631:   call <sid>X('jsBraces',               s:mono_2,  '', '')[J

calling <SNR>12_X[J('jsBraces', ['#828997', '102'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsBraces guifg=#828997[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsBraces ctermfg=102[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 632:   call <sid>X('jsClassBraces',          s:mono_2,  '', '')[J

calling <SNR>12_X[J('jsClassBraces', ['#828997', '102'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsClassBraces guifg=#828997[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsClassBraces ctermfg=102[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 633:   call <sid>X('jsClassKeywords',        s:hue_3,   '', '')[J

calling <SNR>12_X[J('jsClassKeywords', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsClassKeywords guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsClassKeywords ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 634:   call <sid>X('jsDocParam',             s:hue_2,   '', '')[J

calling <SNR>12_X[J('jsDocParam', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsDocParam guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsDocParam ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 635:   call <sid>X('jsDocTags',              s:hue_3,   '', '')[J

calling <SNR>12_X[J('jsDocTags', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsDocTags guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsDocTags ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 636:   call <sid>X('jsFuncBraces',           s:mono_2,  '', '')[J

calling <SNR>12_X[J('jsFuncBraces', ['#828997', '102'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsFuncBraces guifg=#828997[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsFuncBraces ctermfg=102[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 637:   call <sid>X('jsFuncCall',             s:hue_2,   '', '')[J

calling <SNR>12_X[J('jsFuncCall', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsFuncCall guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsFuncCall ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 638:   call <sid>X('jsFuncParens',           s:mono_2,  '', '')[J

calling <SNR>12_X[J('jsFuncParens', ['#828997', '102'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsFuncParens guifg=#828997[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsFuncParens ctermfg=102[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 639:   call <sid>X('jsFunction',             s:hue_3,   '', '')[J

calling <SNR>12_X[J('jsFunction', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsFunction guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsFunction ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 640:   call <sid>X('jsGlobalObjects',        s:hue_6_2, '', '')[J

calling <SNR>12_X[J('jsGlobalObjects', ['#e5c07b', '180'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsGlobalObjects guifg=#e5c07b[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsGlobalObjects ctermfg=180[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 641:   call <sid>X('jsModuleWords',          s:hue_3,   '', '')[J

calling <SNR>12_X[J('jsModuleWords', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsModuleWords guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsModuleWords ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 642:   call <sid>X('jsModules',              s:hue_3,   '', '')[J

calling <SNR>12_X[J('jsModules', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsModules guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsModules ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 643:   call <sid>X('jsNoise',                s:mono_2,  '', '')[J

calling <SNR>12_X[J('jsNoise', ['#828997', '102'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsNoise guifg=#828997[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsNoise ctermfg=102[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 644:   call <sid>X('jsNull',                 s:hue_6,   '', '')[J

calling <SNR>12_X[J('jsNull', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsNull guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsNull ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 645:   call <sid>X('jsOperator',             s:hue_3,   '', '')[J

calling <SNR>12_X[J('jsOperator', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsOperator guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsOperator ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 646:   call <sid>X('jsParens',               s:mono_2,  '', '')[J

calling <SNR>12_X[J('jsParens', ['#828997', '102'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsParens guifg=#828997[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsParens ctermfg=102[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 647:   call <sid>X('jsStorageClass',         s:hue_3,   '', '')[J

calling <SNR>12_X[J('jsStorageClass', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsStorageClass guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsStorageClass ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 648:   call <sid>X('jsTemplateBraces',       s:hue_5_2, '', '')[J

calling <SNR>12_X[J('jsTemplateBraces', ['#be5046', '130'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsTemplateBraces guifg=#be5046[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsTemplateBraces ctermfg=130[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 649:   call <sid>X('jsTemplateVar',          s:hue_4,   '', '')[J

calling <SNR>12_X[J('jsTemplateVar', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsTemplateVar guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsTemplateVar ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 650:   call <sid>X('jsThis',                 s:hue_5,   '', '')[J

calling <SNR>12_X[J('jsThis', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsThis guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsThis ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 651:   call <sid>X('jsUndefined',            s:hue_6,   '', '')[J

calling <SNR>12_X[J('jsUndefined', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsUndefined guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsUndefined ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 652:   call <sid>X('jsObjectValue',          s:hue_2,   '', '')[J

calling <SNR>12_X[J('jsObjectValue', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsObjectValue guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsObjectValue ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 653:   call <sid>X('jsObjectKey',            s:hue_1,   '', '')[J

calling <SNR>12_X[J('jsObjectKey', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsObjectKey guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsObjectKey ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 654:   call <sid>X('jsReturn',               s:hue_3,   '', '')[J

calling <SNR>12_X[J('jsReturn', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsReturn guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsReturn ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 655:   " https://github.com/othree/yajs.vim[J

line 656:   call <sid>X('javascriptArrowFunc',    s:hue_3,   '', '')[J

calling <SNR>12_X[J('javascriptArrowFunc', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javascriptArrowFunc guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javascriptArrowFunc ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 657:   call <sid>X('javascriptClassExtends', s:hue_3,   '', '')[J

calling <SNR>12_X[J('javascriptClassExtends', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javascriptClassExtends guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javascriptClassExtends ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 658:   call <sid>X('javascriptClassKeyword', s:hue_3,   '', '')[J

calling <SNR>12_X[J('javascriptClassKeyword', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javascriptClassKeyword guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javascriptClassKeyword ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 659:   call <sid>X('javascriptDocNotation',  s:hue_3,   '', '')[J

calling <SNR>12_X[J('javascriptDocNotation', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javascriptDocNotation guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javascriptDocNotation ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 660:   call <sid>X('javascriptDocParamName', s:hue_2,   '', '')[J

calling <SNR>12_X[J('javascriptDocParamName', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javascriptDocParamName guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javascriptDocParamName ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 661:   call <sid>X('javascriptDocTags',      s:hue_3,   '', '')[J

calling <SNR>12_X[J('javascriptDocTags', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javascriptDocTags guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javascriptDocTags ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 662:   call <sid>X('javascriptEndColons',    s:mono_3,  '', '')[J

calling <SNR>12_X[J('javascriptEndColons', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javascriptEndColons guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javascriptEndColons ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 663:   call <sid>X('javascriptExport',       s:hue_3,   '', '')[J

calling <SNR>12_X[J('javascriptExport', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javascriptExport guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javascriptExport ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 664:   call <sid>X('javascriptFuncArg',      s:mono_1,  '', '')[J

calling <SNR>12_X[J('javascriptFuncArg', ['#abb2bf', '145'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javascriptFuncArg guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javascriptFuncArg ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 665:   call <sid>X('javascriptFuncKeyword',  s:hue_3,   '', '')[J

calling <SNR>12_X[J('javascriptFuncKeyword', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javascriptFuncKeyword guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javascriptFuncKeyword ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 666:   call <sid>X('javascriptIdentifier',   s:hue_5,   '', '')[J

calling <SNR>12_X[J('javascriptIdentifier', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javascriptIdentifier guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javascriptIdentifier ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 667:   call <sid>X('javascriptImport',       s:hue_3,   '', '')[J

calling <SNR>12_X[J('javascriptImport', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javascriptImport guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javascriptImport ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 668:   call <sid>X('javascriptObjectLabel',  s:mono_1,  '', '')[J

calling <SNR>12_X[J('javascriptObjectLabel', ['#abb2bf', '145'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javascriptObjectLabel guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javascriptObjectLabel ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 669:   call <sid>X('javascriptOpSymbol',     s:hue_1,   '', '')[J

calling <SNR>12_X[J('javascriptOpSymbol', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javascriptOpSymbol guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javascriptOpSymbol ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 670:   call <sid>X('javascriptOpSymbols',    s:hue_1,   '', '')[J

calling <SNR>12_X[J('javascriptOpSymbols', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javascriptOpSymbols guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javascriptOpSymbols ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 671:   call <sid>X('javascriptPropertyName', s:hue_4,   '', '')[J

calling <SNR>12_X[J('javascriptPropertyName', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javascriptPropertyName guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javascriptPropertyName ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 672:   call <sid>X('javascriptTemplateSB',   s:hue_5_2, '', '')[J

calling <SNR>12_X[J('javascriptTemplateSB', ['#be5046', '130'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javascriptTemplateSB guifg=#be5046[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javascriptTemplateSB ctermfg=130[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 673:   call <sid>X('javascriptVariable',     s:hue_3,   '', '')[J

calling <SNR>12_X[J('javascriptVariable', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi javascriptVariable guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi javascriptVariable ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 674:   " }}}[J

line 675: [J

line 676:   " JSON highlighting -------------------------------------------------------{{{[J

line 677:   call <sid>X('jsonCommentError',         s:mono_1,  '', ''        )[J

calling <SNR>12_X[J('jsonCommentError', ['#abb2bf', '145'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsonCommentError guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsonCommentError ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 678:   call <sid>X('jsonKeyword',              s:hue_5,   '', ''        )[J

calling <SNR>12_X[J('jsonKeyword', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsonKeyword guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsonKeyword ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 679:   call <sid>X('jsonQuote',                s:mono_3,  '', ''        )[J

calling <SNR>12_X[J('jsonQuote', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsonQuote guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsonQuote ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 680:   call <sid>X('jsonTrailingCommaError',   s:hue_5,   '', 'reverse' )[J

calling <SNR>12_X[J('jsonTrailingCommaError', ['#e06c75', '168'], '', 'reverse')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsonTrailingCommaError guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsonTrailingCommaError ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi jsonTrailingCommaError gui=reverse[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi jsonTrailingCommaError cterm=reverse[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 681:   call <sid>X('jsonMissingCommaError',    s:hue_5,   '', 'reverse' )[J

calling <SNR>12_X[J('jsonMissingCommaError', ['#e06c75', '168'], '', 'reverse')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsonMissingCommaError guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsonMissingCommaError ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi jsonMissingCommaError gui=reverse[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi jsonMissingCommaError cterm=reverse[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 682:   call <sid>X('jsonNoQuotesError',        s:hue_5,   '', 'reverse' )[J

calling <SNR>12_X[J('jsonNoQuotesError', ['#e06c75', '168'], '', 'reverse')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsonNoQuotesError guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsonNoQuotesError ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi jsonNoQuotesError gui=reverse[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi jsonNoQuotesError cterm=reverse[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 683:   call <sid>X('jsonNumError',             s:hue_5,   '', 'reverse' )[J

calling <SNR>12_X[J('jsonNumError', ['#e06c75', '168'], '', 'reverse')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsonNumError guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsonNumError ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi jsonNumError gui=reverse[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi jsonNumError cterm=reverse[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 684:   call <sid>X('jsonString',               s:hue_4,   '', ''        )[J

calling <SNR>12_X[J('jsonString', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsonString guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsonString ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 685:   call <sid>X('jsonBoolean',              s:hue_3,   '', ''        )[J

calling <SNR>12_X[J('jsonBoolean', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsonBoolean guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsonBoolean ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 686:   call <sid>X('jsonNumber',               s:hue_6,   '', ''        )[J

calling <SNR>12_X[J('jsonNumber', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsonNumber guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsonNumber ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 687:   call <sid>X('jsonStringSQError',        s:hue_5,   '', 'reverse' )[J

calling <SNR>12_X[J('jsonStringSQError', ['#e06c75', '168'], '', 'reverse')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsonStringSQError guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsonStringSQError ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi jsonStringSQError gui=reverse[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi jsonStringSQError cterm=reverse[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 688:   call <sid>X('jsonSemicolonError',       s:hue_5,   '', 'reverse' )[J

calling <SNR>12_X[J('jsonSemicolonError', ['#e06c75', '168'], '', 'reverse')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi jsonSemicolonError guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi jsonSemicolonError ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi jsonSemicolonError gui=reverse[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi jsonSemicolonError cterm=reverse[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 689:   " }}}[J

line 690: [J

line 691:   " Markdown highlighting ---------------------------------------------------{{{[J

line 692:   call <sid>X('markdownUrl',              s:mono_3,  '', '')[J

calling <SNR>12_X[J('markdownUrl', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi markdownUrl guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi markdownUrl ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 693:   call <sid>X('markdownBold',             s:hue_6,   '', 'bold')[J

calling <SNR>12_X[J('markdownBold', ['#d19a66', '173'], '', 'bold')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi markdownBold guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi markdownBold ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi markdownBold gui=bold[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi markdownBold cterm=bold[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 694:   call <sid>X('markdownItalic',           s:hue_6,   '', 'bold')[J

calling <SNR>12_X[J('markdownItalic', ['#d19a66', '173'], '', 'bold')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi markdownItalic guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi markdownItalic ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi markdownItalic gui=bold[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi markdownItalic cterm=bold[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 695:   call <sid>X('markdownCode',             s:hue_4,   '', '')[J

calling <SNR>12_X[J('markdownCode', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi markdownCode guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi markdownCode ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 696:   call <sid>X('markdownCodeBlock',        s:hue_5,   '', '')[J

calling <SNR>12_X[J('markdownCodeBlock', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi markdownCodeBlock guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi markdownCodeBlock ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 697:   call <sid>X('markdownCodeDelimiter',    s:hue_4,   '', '')[J

calling <SNR>12_X[J('markdownCodeDelimiter', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi markdownCodeDelimiter guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi markdownCodeDelimiter ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 698:   call <sid>X('markdownHeadingDelimiter', s:hue_5_2, '', '')[J

calling <SNR>12_X[J('markdownHeadingDelimiter', ['#be5046', '130'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi markdownHeadingDelimiter guifg=#be5046[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi markdownHeadingDelimiter ctermfg=130[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 699:   call <sid>X('markdownH1',               s:hue_5,   '', '')[J

calling <SNR>12_X[J('markdownH1', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi markdownH1 guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi markdownH1 ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 700:   call <sid>X('markdownH2',               s:hue_5,   '', '')[J

calling <SNR>12_X[J('markdownH2', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi markdownH2 guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi markdownH2 ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 701:   call <sid>X('markdownH3',               s:hue_5,   '', '')[J

calling <SNR>12_X[J('markdownH3', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi markdownH3 guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi markdownH3 ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 702:   call <sid>X('markdownH3',               s:hue_5,   '', '')[J

calling <SNR>12_X[J('markdownH3', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi markdownH3 guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi markdownH3 ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 703:   call <sid>X('markdownH4',               s:hue_5,   '', '')[J

calling <SNR>12_X[J('markdownH4', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi markdownH4 guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi markdownH4 ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 704:   call <sid>X('markdownH5',               s:hue_5,   '', '')[J

calling <SNR>12_X[J('markdownH5', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi markdownH5 guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi markdownH5 ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 705:   call <sid>X('markdownH6',               s:hue_5,   '', '')[J

calling <SNR>12_X[J('markdownH6', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi markdownH6 guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi markdownH6 ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 706:   call <sid>X('markdownListMarker',       s:hue_5,   '', '')[J

calling <SNR>12_X[J('markdownListMarker', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi markdownListMarker guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi markdownListMarker ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 707:   " }}}[J

line 708: [J

line 709:   " Perl highlighting -------------------------------------------------------{{{[J

line 710:   call <sid>X('perlFunction',      s:hue_3,     '', '')[J

calling <SNR>12_X[J('perlFunction', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi perlFunction guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi perlFunction ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 711:   call <sid>X('perlMethod',        s:syntax_fg, '', '')[J

calling <SNR>12_X[J('perlMethod', ['#abb2bf', '145'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi perlMethod guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi perlMethod ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 712:   call <sid>X('perlPackageConst',  s:hue_3,     '', '')[J

calling <SNR>12_X[J('perlPackageConst', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi perlPackageConst guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi perlPackageConst ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 713:   call <sid>X('perlPOD',           s:mono_3,    '', '')[J

calling <SNR>12_X[J('perlPOD', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi perlPOD guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi perlPOD ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 714:   call <sid>X('perlSubName',       s:syntax_fg, '', '')[J

calling <SNR>12_X[J('perlSubName', ['#abb2bf', '145'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi perlSubName guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi perlSubName ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 715:   call <sid>X('perlSharpBang',     s:mono_3,    '', '')[J

calling <SNR>12_X[J('perlSharpBang', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi perlSharpBang guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi perlSharpBang ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 716:   call <sid>X('perlSpecialString', s:hue_4,     '', '')[J

calling <SNR>12_X[J('perlSpecialString', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi perlSpecialString guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi perlSpecialString ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 717:   call <sid>X('perlVarPlain',      s:hue_2,     '', '')[J

calling <SNR>12_X[J('perlVarPlain', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi perlVarPlain guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi perlVarPlain ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 718:   call <sid>X('podCommand',        s:mono_3,    '', '')[J

calling <SNR>12_X[J('podCommand', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi podCommand guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi podCommand ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 719: [J

line 720:   " PHP highlighting --------------------------------------------------------{{{[J

line 721:   call <sid>X('phpClass',        s:hue_6_2, '', '')[J

calling <SNR>12_X[J('phpClass', ['#e5c07b', '180'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi phpClass guifg=#e5c07b[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi phpClass ctermfg=180[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 722:   call <sid>X('phpFunction',     s:hue_2,   '', '')[J

calling <SNR>12_X[J('phpFunction', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi phpFunction guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi phpFunction ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 723:   call <sid>X('phpFunctions',    s:hue_2,   '', '')[J

calling <SNR>12_X[J('phpFunctions', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi phpFunctions guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi phpFunctions ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 724:   call <sid>X('phpInclude',      s:hue_3,   '', '')[J

calling <SNR>12_X[J('phpInclude', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi phpInclude guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi phpInclude ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 725:   call <sid>X('phpKeyword',      s:hue_3,   '', '')[J

calling <SNR>12_X[J('phpKeyword', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi phpKeyword guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi phpKeyword ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 726:   call <sid>X('phpParent',       s:mono_3,  '', '')[J

calling <SNR>12_X[J('phpParent', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi phpParent guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi phpParent ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 727:   call <sid>X('phpType',         s:hue_3,   '', '')[J

calling <SNR>12_X[J('phpType', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi phpType guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi phpType ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 728:   call <sid>X('phpSuperGlobals', s:hue_5,   '', '')[J

calling <SNR>12_X[J('phpSuperGlobals', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi phpSuperGlobals guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi phpSuperGlobals ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 729:   " }}}[J

line 730: [J

line 731:   " Pug (Formerly Jade) highlighting ----------------------------------------{{{[J

line 732:   call <sid>X('pugAttributesDelimiter',   s:hue_6,    '', '')[J

calling <SNR>12_X[J('pugAttributesDelimiter', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi pugAttributesDelimiter guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi pugAttributesDelimiter ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 733:   call <sid>X('pugClass',                 s:hue_6,    '', '')[J

calling <SNR>12_X[J('pugClass', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi pugClass guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi pugClass ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 734:   call <sid>X('pugDocType',               s:mono_3,   '', s:italic)[J

calling <SNR>12_X[J('pugDocType', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi pugDocType guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi pugDocType ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 735:   call <sid>X('pugTag',                   s:hue_5,    '', '')[J

calling <SNR>12_X[J('pugTag', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi pugTag guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi pugTag ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 736:   " }}}[J

line 737: [J

line 738:   " PureScript highlighting -------------------------------------------------{{{[J

line 739:   call <sid>X('purescriptKeyword',          s:hue_3,     '', '')[J

calling <SNR>12_X[J('purescriptKeyword', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi purescriptKeyword guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi purescriptKeyword ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 740:   call <sid>X('purescriptModuleName',       s:syntax_fg, '', '')[J

calling <SNR>12_X[J('purescriptModuleName', ['#abb2bf', '145'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi purescriptModuleName guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi purescriptModuleName ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 741:   call <sid>X('purescriptIdentifier',       s:syntax_fg, '', '')[J

calling <SNR>12_X[J('purescriptIdentifier', ['#abb2bf', '145'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi purescriptIdentifier guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi purescriptIdentifier ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 742:   call <sid>X('purescriptType',             s:hue_6_2,   '', '')[J

calling <SNR>12_X[J('purescriptType', ['#e5c07b', '180'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi purescriptType guifg=#e5c07b[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi purescriptType ctermfg=180[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 743:   call <sid>X('purescriptTypeVar',          s:hue_5,     '', '')[J

calling <SNR>12_X[J('purescriptTypeVar', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi purescriptTypeVar guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi purescriptTypeVar ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 744:   call <sid>X('purescriptConstructor',      s:hue_5,     '', '')[J

calling <SNR>12_X[J('purescriptConstructor', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi purescriptConstructor guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi purescriptConstructor ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 745:   call <sid>X('purescriptOperator',         s:syntax_fg, '', '')[J

calling <SNR>12_X[J('purescriptOperator', ['#abb2bf', '145'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi purescriptOperator guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi purescriptOperator ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 746:   " }}}[J

line 747: [J

line 748:   " Python highlighting -----------------------------------------------------{{{[J

line 749:   call <sid>X('pythonImport',               s:hue_3,     '', '')[J

calling <SNR>12_X[J('pythonImport', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi pythonImport guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi pythonImport ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 750:   call <sid>X('pythonBuiltin',              s:hue_1,     '', '')[J

calling <SNR>12_X[J('pythonBuiltin', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi pythonBuiltin guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi pythonBuiltin ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 751:   call <sid>X('pythonStatement',            s:hue_3,     '', '')[J

calling <SNR>12_X[J('pythonStatement', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi pythonStatement guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi pythonStatement ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 752:   call <sid>X('pythonParam',                s:hue_6,     '', '')[J

calling <SNR>12_X[J('pythonParam', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi pythonParam guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi pythonParam ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 753:   call <sid>X('pythonEscape',               s:hue_5,     '', '')[J

calling <SNR>12_X[J('pythonEscape', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi pythonEscape guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi pythonEscape ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 754:   call <sid>X('pythonSelf',                 s:mono_2,    '', s:italic)[J

calling <SNR>12_X[J('pythonSelf', ['#828997', '102'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi pythonSelf guifg=#828997[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi pythonSelf ctermfg=102[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 755:   call <sid>X('pythonClass',                s:hue_2,     '', '')[J

calling <SNR>12_X[J('pythonClass', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi pythonClass guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi pythonClass ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 756:   call <sid>X('pythonOperator',             s:hue_3,     '', '')[J

calling <SNR>12_X[J('pythonOperator', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi pythonOperator guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi pythonOperator ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 757:   call <sid>X('pythonEscape',               s:hue_5,     '', '')[J

calling <SNR>12_X[J('pythonEscape', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi pythonEscape guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi pythonEscape ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 758:   call <sid>X('pythonFunction',             s:hue_2,     '', '')[J

calling <SNR>12_X[J('pythonFunction', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi pythonFunction guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi pythonFunction ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 759:   call <sid>X('pythonKeyword',              s:hue_2,     '', '')[J

calling <SNR>12_X[J('pythonKeyword', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi pythonKeyword guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi pythonKeyword ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 760:   call <sid>X('pythonModule',               s:hue_3,     '', '')[J

calling <SNR>12_X[J('pythonModule', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi pythonModule guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi pythonModule ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 761:   call <sid>X('pythonStringDelimiter',      s:hue_4,     '', '')[J

calling <SNR>12_X[J('pythonStringDelimiter', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi pythonStringDelimiter guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi pythonStringDelimiter ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 762:   call <sid>X('pythonSymbol',               s:hue_1,     '', '')[J

calling <SNR>12_X[J('pythonSymbol', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi pythonSymbol guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi pythonSymbol ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 763:   " }}}[J

line 764: [J

line 765:   " Ruby highlighting -------------------------------------------------------{{{[J

line 766:   call <sid>X('rubyBlock',                     s:hue_3,   '', '')[J

calling <SNR>12_X[J('rubyBlock', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyBlock guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyBlock ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 767:   call <sid>X('rubyBlockParameter',            s:hue_5,   '', '')[J

calling <SNR>12_X[J('rubyBlockParameter', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyBlockParameter guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyBlockParameter ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 768:   call <sid>X('rubyBlockParameterList',        s:hue_5,   '', '')[J

calling <SNR>12_X[J('rubyBlockParameterList', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyBlockParameterList guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyBlockParameterList ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 769:   call <sid>X('rubyCapitalizedMethod',         s:hue_3,   '', '')[J

calling <SNR>12_X[J('rubyCapitalizedMethod', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyCapitalizedMethod guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyCapitalizedMethod ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 770:   call <sid>X('rubyClass',                     s:hue_3,   '', '')[J

calling <SNR>12_X[J('rubyClass', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyClass guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyClass ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 771:   call <sid>X('rubyConstant',                  s:hue_6_2, '', '')[J

calling <SNR>12_X[J('rubyConstant', ['#e5c07b', '180'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyConstant guifg=#e5c07b[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyConstant ctermfg=180[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 772:   call <sid>X('rubyControl',                   s:hue_3,   '', '')[J

calling <SNR>12_X[J('rubyControl', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyControl guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyControl ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 773:   call <sid>X('rubyDefine',                    s:hue_3,   '', '')[J

calling <SNR>12_X[J('rubyDefine', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyDefine guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyDefine ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 774:   call <sid>X('rubyEscape',                    s:hue_5,   '', '')[J

calling <SNR>12_X[J('rubyEscape', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyEscape guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyEscape ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 775:   call <sid>X('rubyFunction',                  s:hue_2,   '', '')[J

calling <SNR>12_X[J('rubyFunction', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyFunction guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyFunction ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 776:   call <sid>X('rubyGlobalVariable',            s:hue_5,   '', '')[J

calling <SNR>12_X[J('rubyGlobalVariable', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyGlobalVariable guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyGlobalVariable ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 777:   call <sid>X('rubyInclude',                   s:hue_2,   '', '')[J

calling <SNR>12_X[J('rubyInclude', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyInclude guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyInclude ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 778:   call <sid>X('rubyIncluderubyGlobalVariable', s:hue_5,   '', '')[J

calling <SNR>12_X[J('rubyIncluderubyGlobalVariable', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyIncluderubyGlobalVariable guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyIncluderubyGlobalVariable ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 779:   call <sid>X('rubyInstanceVariable',          s:hue_5,   '', '')[J

calling <SNR>12_X[J('rubyInstanceVariable', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyInstanceVariable guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyInstanceVariable ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 780:   call <sid>X('rubyInterpolation',             s:hue_1,   '', '')[J

calling <SNR>12_X[J('rubyInterpolation', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyInterpolation guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyInterpolation ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 781:   call <sid>X('rubyInterpolationDelimiter',    s:hue_5,   '', '')[J

calling <SNR>12_X[J('rubyInterpolationDelimiter', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyInterpolationDelimiter guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyInterpolationDelimiter ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 782:   call <sid>X('rubyKeyword',                   s:hue_2,   '', '')[J

calling <SNR>12_X[J('rubyKeyword', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyKeyword guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyKeyword ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 783:   call <sid>X('rubyModule',                    s:hue_3,   '', '')[J

calling <SNR>12_X[J('rubyModule', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyModule guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyModule ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 784:   call <sid>X('rubyPseudoVariable',            s:hue_5,   '', '')[J

calling <SNR>12_X[J('rubyPseudoVariable', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyPseudoVariable guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyPseudoVariable ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 785:   call <sid>X('rubyRegexp',                    s:hue_1,   '', '')[J

calling <SNR>12_X[J('rubyRegexp', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyRegexp guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyRegexp ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 786:   call <sid>X('rubyRegexpDelimiter',           s:hue_1,   '', '')[J

calling <SNR>12_X[J('rubyRegexpDelimiter', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyRegexpDelimiter guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyRegexpDelimiter ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 787:   call <sid>X('rubyStringDelimiter',           s:hue_4,   '', '')[J

calling <SNR>12_X[J('rubyStringDelimiter', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubyStringDelimiter guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubyStringDelimiter ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 788:   call <sid>X('rubySymbol',                    s:hue_1,   '', '')[J

calling <SNR>12_X[J('rubySymbol', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rubySymbol guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rubySymbol ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 789:   " }}}[J

line 790: [J

line 791:   " Spelling highlighting ---------------------------------------------------{{{[J

line 792:   call <sid>X('SpellBad',     '', s:syntax_bg, 'undercurl')[J

calling <SNR>12_X[J('SpellBad', '', ['#282c34', '16'], 'undercurl')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi SpellBad guibg=#282c34[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi SpellBad ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi SpellBad gui=undercurl[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi SpellBad cterm=undercurl[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 793:   call <sid>X('SpellLocal',   '', s:syntax_bg, 'undercurl')[J

calling <SNR>12_X[J('SpellLocal', '', ['#282c34', '16'], 'undercurl')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi SpellLocal guibg=#282c34[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi SpellLocal ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi SpellLocal gui=undercurl[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi SpellLocal cterm=undercurl[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 794:   call <sid>X('SpellCap',     '', s:syntax_bg, 'undercurl')[J

calling <SNR>12_X[J('SpellCap', '', ['#282c34', '16'], 'undercurl')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi SpellCap guibg=#282c34[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi SpellCap ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi SpellCap gui=undercurl[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi SpellCap cterm=undercurl[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 795:   call <sid>X('SpellRare',    '', s:syntax_bg, 'undercurl')[J

calling <SNR>12_X[J('SpellRare', '', ['#282c34', '16'], 'undercurl')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 8: hi SpellRare guibg=#282c34[J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 9: hi SpellRare ctermbg=16[J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi SpellRare gui=undercurl[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi SpellRare cterm=undercurl[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 796:   " }}}[J

line 797: [J

line 798:   " Vim highlighting --------------------------------------------------------{{{[J

line 799:   call <sid>X('vimCommand',      s:hue_3,  '', '')[J

calling <SNR>12_X[J('vimCommand', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi vimCommand guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi vimCommand ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 800:   call <sid>X('vimCommentTitle', s:mono_3, '', 'bold')[J

calling <SNR>12_X[J('vimCommentTitle', ['#5c6370', '59'], '', 'bold')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi vimCommentTitle guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi vimCommentTitle ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi vimCommentTitle gui=bold[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi vimCommentTitle cterm=bold[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 801:   call <sid>X('vimFunction',     s:hue_1,  '', '')[J

calling <SNR>12_X[J('vimFunction', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi vimFunction guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi vimFunction ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 802:   call <sid>X('vimFuncName',     s:hue_3,  '', '')[J

calling <SNR>12_X[J('vimFuncName', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi vimFuncName guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi vimFuncName ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 803:   call <sid>X('vimHighlight',    s:hue_2,  '', '')[J

calling <SNR>12_X[J('vimHighlight', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi vimHighlight guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi vimHighlight ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 804:   call <sid>X('vimLineComment',  s:mono_3, '', s:italic)[J

calling <SNR>12_X[J('vimLineComment', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi vimLineComment guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi vimLineComment ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 805:   call <sid>X('vimParenSep',     s:mono_2, '', '')[J

calling <SNR>12_X[J('vimParenSep', ['#828997', '102'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi vimParenSep guifg=#828997[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi vimParenSep ctermfg=102[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 806:   call <sid>X('vimSep',          s:mono_2, '', '')[J

calling <SNR>12_X[J('vimSep', ['#828997', '102'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi vimSep guifg=#828997[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi vimSep ctermfg=102[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 807:   call <sid>X('vimUserFunc',     s:hue_1,  '', '')[J

calling <SNR>12_X[J('vimUserFunc', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi vimUserFunc guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi vimUserFunc ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 808:   call <sid>X('vimVar',          s:hue_5,  '', '')[J

calling <SNR>12_X[J('vimVar', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi vimVar guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi vimVar ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 809:   " }}}[J

line 810: [J

line 811:   " XML highlighting --------------------------------------------------------{{{[J

line 812:   call <sid>X('xmlAttrib',  s:hue_6_2, '', '')[J

calling <SNR>12_X[J('xmlAttrib', ['#e5c07b', '180'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi xmlAttrib guifg=#e5c07b[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi xmlAttrib ctermfg=180[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 813:   call <sid>X('xmlEndTag',  s:hue_5,   '', '')[J

calling <SNR>12_X[J('xmlEndTag', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi xmlEndTag guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi xmlEndTag ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 814:   call <sid>X('xmlTag',     s:hue_5,   '', '')[J

calling <SNR>12_X[J('xmlTag', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi xmlTag guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi xmlTag ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 815:   call <sid>X('xmlTagName', s:hue_5,   '', '')[J

calling <SNR>12_X[J('xmlTagName', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi xmlTagName guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi xmlTagName ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 816:   " }}}[J

line 817: [J

line 818:   " ZSH highlighting --------------------------------------------------------{{{[J

line 819:   call <sid>X('zshCommands',     s:syntax_fg, '', '')[J

calling <SNR>12_X[J('zshCommands', ['#abb2bf', '145'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi zshCommands guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi zshCommands ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 820:   call <sid>X('zshDeref',        s:hue_5,     '', '')[J

calling <SNR>12_X[J('zshDeref', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi zshDeref guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi zshDeref ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 821:   call <sid>X('zshShortDeref',   s:hue_5,     '', '')[J

calling <SNR>12_X[J('zshShortDeref', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi zshShortDeref guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi zshShortDeref ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 822:   call <sid>X('zshFunction',     s:hue_1,     '', '')[J

calling <SNR>12_X[J('zshFunction', ['#56b6c2', '73'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi zshFunction guifg=#56b6c2[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi zshFunction ctermfg=73[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 823:   call <sid>X('zshKeyword',      s:hue_3,     '', '')[J

calling <SNR>12_X[J('zshKeyword', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi zshKeyword guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi zshKeyword ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 824:   call <sid>X('zshSubst',        s:hue_5,     '', '')[J

calling <SNR>12_X[J('zshSubst', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi zshSubst guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi zshSubst ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 825:   call <sid>X('zshSubstDelim',   s:mono_3,    '', '')[J

calling <SNR>12_X[J('zshSubstDelim', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi zshSubstDelim guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi zshSubstDelim ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 826:   call <sid>X('zshTypes',        s:hue_3,     '', '')[J

calling <SNR>12_X[J('zshTypes', ['#c678dd', '176'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi zshTypes guifg=#c678dd[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi zshTypes ctermfg=176[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 827:   call <sid>X('zshVariableDef',  s:hue_6,     '', '')[J

calling <SNR>12_X[J('zshVariableDef', ['#d19a66', '173'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi zshVariableDef guifg=#d19a66[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi zshVariableDef ctermfg=173[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 828:   " }}}[J

line 829: [J

line 830:   " Rust highlighting -------------------------------------------------------{{{[J

line 831:   call <sid>X('rustExternCrate',          s:hue_5,    '', 'bold')[J

calling <SNR>12_X[J('rustExternCrate', ['#e06c75', '168'], '', 'bold')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rustExternCrate guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rustExternCrate ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 12: hi rustExternCrate gui=bold[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 13: hi rustExternCrate cterm=bold[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 832:   call <sid>X('rustIdentifier',           s:hue_2,    '', '')[J

calling <SNR>12_X[J('rustIdentifier', ['#61afef', '75'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rustIdentifier guifg=#61afef[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rustIdentifier ctermfg=75[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 833:   call <sid>X('rustDeriveTrait',          s:hue_4,    '', '')[J

calling <SNR>12_X[J('rustDeriveTrait', ['#98c379', '114'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rustDeriveTrait guifg=#98c379[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rustDeriveTrait ctermfg=114[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 834:   call <sid>X('SpecialComment',           s:mono_3,    '', '')[J

calling <SNR>12_X[J('SpecialComment', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi SpecialComment guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi SpecialComment ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 835:   call <sid>X('rustCommentLine',          s:mono_3,    '', '')[J

calling <SNR>12_X[J('rustCommentLine', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rustCommentLine guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rustCommentLine ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 836:   call <sid>X('rustCommentLineDoc',       s:mono_3,    '', '')[J

calling <SNR>12_X[J('rustCommentLineDoc', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rustCommentLineDoc guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rustCommentLineDoc ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 837:   call <sid>X('rustCommentLineDocError',  s:mono_3,    '', '')[J

calling <SNR>12_X[J('rustCommentLineDocError', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rustCommentLineDocError guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rustCommentLineDocError ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 838:   call <sid>X('rustCommentBlock',         s:mono_3,    '', '')[J

calling <SNR>12_X[J('rustCommentBlock', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rustCommentBlock guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rustCommentBlock ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 839:   call <sid>X('rustCommentBlockDoc',      s:mono_3,    '', '')[J

calling <SNR>12_X[J('rustCommentBlockDoc', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rustCommentBlockDoc guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rustCommentBlockDoc ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 840:   call <sid>X('rustCommentBlockDocError', s:mono_3,    '', '')[J

calling <SNR>12_X[J('rustCommentBlockDocError', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi rustCommentBlockDocError guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi rustCommentBlockDocError ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 841:   " }}}[J

line 842: [J

line 843:   " man highlighting --------------------------------------------------------{{{[J

line 844:   hi link manTitle String[J

line 845:   call <sid>X('manFooter', s:mono_3, '', '')[J

calling <SNR>12_X[J('manFooter', ['#5c6370', '59'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi manFooter guifg=#5c6370[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi manFooter ctermfg=59[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 846:   " }}}[J

line 847: [J

line 848:   " ALE (Asynchronous Lint Engine) highlighting -----------------------------{{{[J

line 849:   call <sid>X('ALEWarningSign', s:hue_6_2, '', '')[J

calling <SNR>12_X[J('ALEWarningSign', ['#e5c07b', '180'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi ALEWarningSign guifg=#e5c07b[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi ALEWarningSign ctermfg=180[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 850:   call <sid>X('ALEErrorSign', s:hue_5,   '', '')[J

calling <SNR>12_X[J('ALEErrorSign', ['#e06c75', '168'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi ALEErrorSign guifg=#e06c75[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi ALEErrorSign ctermfg=168[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 851: [J

line 852: [J

line 853:    " Neovim NERDTree Background fix ------------------------------------------{{{[J

line 854:   call <sid>X('NERDTreeFile', s:syntax_fg, '', '')[J

calling <SNR>12_X[J('NERDTreeFile', ['#abb2bf', '145'], '', '')

line 1:     let l:attrsp = get(a:, 1, "")[J

line 2:     " fg, bg, attr, attrsp[J

line 3:     if !empty(a:fg)[J

line 4:       exec "hi " . a:group . " guifg=" .  a:fg[0][J

line 4: hi NERDTreeFile guifg=#abb2bf[J

line 5:       exec "hi " . a:group . " ctermfg=" . a:fg[1][J

line 5: hi NERDTreeFile ctermfg=145[J

line 6:     endif[J

line 7:     if !empty(a:bg)[J

line 8:       exec "hi " . a:group . " guibg=" .  a:bg[0][J

line 9:       exec "hi " . a:group . " ctermbg=" . a:bg[1][J

line 10:     endif[J

line 11:     if a:attr != ""[J

line 12:       exec "hi " . a:group . " gui=" .   a:attr[J

line 13:       exec "hi " . a:group . " cterm=" . a:attr[J

line 14:     endif[J

line 15:     if !empty(l:attrsp)[J

line 16:       exec "hi " . a:group . " guisp=" . l:attrsp[0][J

line 17:     endif[J

<SNR>12_X returning #0[J

continuing in /Users/tsen/.vim/colors/one.vim[J

line 855:   " }}}[J

line 856: [J

line 857:   " Delete functions =========================================================={{{[J

line 858:   " delf <SID>X[J

line 859:   " delf <SID>XAPI[J

line 860:   " delf <SID>rgb[J

line 861:   " delf <SID>color[J

line 862:   " delf <SID>rgb_color[J

line 863:   " delf <SID>rgb_level[J

line 864:   " delf <SID>rgb_number[J

line 865:   " delf <SID>grey_color[J

line 866:   " delf <SID>grey_level[J

line 867:   " delf <SID>grey_number[J

line 868:   " }}}[J

line 869: [J

line 870: endif[J

line 871: "}}}[J

line 872: [J

line 873: " Public API --------------------------------------------------------------{{{[J

line 874: function! one#highlight(group, fg, bg, attr)[J

line 877: "}}}[J

line 878: [J

line 879: if exists('s:dark') && s:dark[J

line 880:   set background=dark[J

line 881: endif[J

line 882: [J

line 883: " vim: set fdl=0 fdm=marker:[J

finished sourcing /Users/tsen/.vim/colors/one.vim[J
continuing in /Users/tsen/.vim/vimrc[J
line 65: [J

line 66: " 搜尋反白[J

line 67: set hlsearch"[J

line 68: [J

line 69: " 配置檔案路徑，讓 find 可以搜尋當前目錄的所有子目錄[J

line 70: set path=.,/usr/include,,**[J

line 71: [J

line 72: " ts = tabstop[J

line 73: set ts=4 "縮排 4 格[J

line 74: [J

line 75: " tab 替換成空格[J

line 76: set expandtab[J

line 77: [J

line 78: " 自動縮排 ｜ autoindent / smartindent / cindent[J

line 79: set autoindent " 跟上一行的縮進一致[J

line 80: [J

line 81: " VIM 複製到系統剪貼簿[J

line 82: set clipboard=unnamed[J

line 83: [J

finished sourcing ~/.vim/vimrc[J
Searching for "pack/*/start/*" in "/Users/tsen/.vim,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after"[J
Searching for "/Users/tsen/.vim/pack/*/start/*"[J
Searching for "/usr/local/share/vim/vimfiles/pack/*/start/*"[J
Searching for "/usr/local/share/vim/vim90/pack/*/start/*"[J
Searching for "/usr/local/share/vim/vimfiles/after/pack/*/start/*"[J
Searching for "/Users/tsen/.vim/after/pack/*/start/*"[J
not found in 'packpath': "pack/*/start/*"[J
Searching for "plugin/**/*.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/plugin/**/*.vim"[J
chdir(/Users/tsen/.vim/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/tsen/.vim/plugin/hotkey.vim"[J
line 1: " ---------------------------------------------------------- 快捷鍵 -----------------------------------------------------[J

line 2: [J

line 3: " i = 插入模式執行, n = 普通模式執行 m =任何模式都可執行[J

line 4: " nore 代表遞歸，意味著映射關係是否可以延續[J

line 5: " <xxx> xxx 表示為鍵盤鍵, <CR> = Enter, <Shift-x> = Shift + x 組合鍵[J

line 6: inoremap ;; <ESC>[J

line 7: [J

line 8: " 執行 python[J

line 9: nmap <F5> :call CompileRun()<CR>[J

line 10: func! CompileRun()[J

line 21: [J

finished sourcing /Users/tsen/.vim/plugin/hotkey.vim[J
chdir(/Users/tsen/.vim/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/tsen/.vim/plugin/tagbar.vim"[J
line 1: " 快捷鍵 opt+3[J

line 2: nmap £:TagbarToggle<CR>[J

No mapping found[J
line 3: [J

finished sourcing /Users/tsen/.vim/plugin/tagbar.vim[J
chdir(/Users/tsen/.vim/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/tsen/.vim/plugin/vim-autoformat.vim"[J
line 1: " autoformat[J

line 2: nnoremap ™ :Autoformat<CR>[J

line 3: au BufWrite * :Autoformat[J

line 4: let g:autoformat_autoindent = 0[J

line 5: let g:autoformat_retab = 0[J

line 6: let g:autoformat_remove_trailing_spaces = 0[J

finished sourcing /Users/tsen/.vim/plugin/vim-autoformat.vim[J
chdir(/Users/tsen/.vim/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/tsen/.vim/plugin/vim-commandline-hotkey.vim"[J
line 1: " ---------------------------------------------------------- 命令行指令 -----------------------------------------------------[J

line 2: " JSON 文字格式化[J

line 3: command! JSONFormat :execute '%!python -m json.tool' | :execute '%!python -c "import re,sys;chr=__builtins__.__dict__.get(\"unichr\", chr);sys.stdout.write(re.sub(r\"\\\\u[0-9a-f]{4}\", lambda x: chr(int(\"0x\" + x.group(0)[2:], 16)).encode(\"utf-8\"), sys.stdin.read()))"' | :set ft=javascript | :1[J

line 7: [J

line 8: " XML 文字格式化[J

line 9: command! XMLFormat :execute '%!xmllint --format -'[J

line 10: [J

line 11: " 常用的文字替代[J

line 12: command! Br2line :execute '%s/<br>/---/g'[J

line 13: " xml 文字的格式化排版[J

line 14: command! XMLFormat :execute '%!xmllint --format -'[J

line 15: " 執行常用的文字替代[J

line 16: command! Br2line :execute '%s/<br>/---/g'[J

line 17: [J

finished sourcing /Users/tsen/.vim/plugin/vim-commandline-hotkey.vim[J
chdir(/Users/tsen/.vim/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/tsen/.vim/plugin/vim-nerdtree-tabs.vim"[J
line 1: " 側邊欄快捷鍵 : opt + 1[J

line 2: nnoremap ¡ : NERDTreeToggle<CR>[J

finished sourcing /Users/tsen/.vim/plugin/vim-nerdtree-tabs.vim[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/plugin/**/*.vim"[J
chdir(/Users/tsen/.vim/bundle/nerdtree/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/tsen/.vim/bundle/nerdtree/plugin/NERD_tree.vim"[J
line 1: " ============================================================================[J

line 2: " File:        NERD_tree.vim[J

line 3: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>[J

line 4: " License:     This program is free software. It comes without any warranty,[J

line 5: "              to the extent permitted by applicable law. You can redistribute[J

line 6: "              it and/or modify it under the terms of the Do What The Fuck You[J

line 7: "              Want To Public License, Version 2, as published by Sam Hocevar.[J

line 8: "              See http://sam.zoy.org/wtfpl/COPYING for more details.[J

line 9: "[J

line 10: " ============================================================================[J

line 11: "[J

line 12: " SECTION: Script init stuff {{{1[J

line 13: "============================================================[J

line 14: scriptencoding utf-8[J

line 15: [J

line 16: if exists('loaded_nerd_tree')[J

line 17:     finish[J

line 18: endif[J

line 19: if v:version < 703[J

line 20:     echoerr "NERDTree: this plugin requires vim >= 7.3. DOWNLOAD IT! You'll thank me later!"[J

line 21:     finish[J

line 22: endif[J

line 23: let loaded_nerd_tree = 1[J

line 24: [J

line 25: "for line continuation - i.e dont want C in &cpoptions[J

line 26: let s:old_cpo = &cpoptions[J

line 27: set cpoptions&vim[J

line 28: [J

line 29: "SECTION: Initialize variable calls and other random constants {{{2[J

line 30: let g:NERDTreeAutoCenter            = get(g:, 'NERDTreeAutoCenter',            1)[J

line 31: let g:NERDTreeAutoCenterThreshold   = get(g:, 'NERDTreeAutoCenterThreshold',   3)[J

line 32: let g:NERDTreeCaseSensitiveSort     = get(g:, 'NERDTreeCaseSensitiveSort',     0)[J

line 33: let g:NERDTreeNaturalSort           = get(g:, 'NERDTreeNaturalSort',           0)[J

line 34: let g:NERDTreeSortHiddenFirst       = get(g:, 'NERDTreeSortHiddenFirst',       1)[J

line 35: let g:NERDTreeUseTCD                = get(g:, 'NERDTreeUseTCD',                0)[J

line 36: let g:NERDTreeChDirMode             = get(g:, 'NERDTreeChDirMode',             0)[J

line 37: let g:NERDTreeCreatePrefix          = get(g:, 'NERDTreeCreatePrefix',          'silent')[J

line 38: let g:NERDTreeMinimalUI             = get(g:, 'NERDTreeMinimalUI',             0)[J

line 39: let g:NERDTreeMinimalMenu           = get(g:, 'NERDTreeMinimalMenu',           0)[J

line 40: let g:NERDTreeIgnore                = get(g:, 'NERDTreeIgnore',                ['\~$'])[J

line 41: let g:NERDTreeBookmarksFile         = get(g:, 'NERDTreeBookmarksFile',         expand('$HOME') . '/.NERDTreeBookmarks')[J

line 42: let g:NERDTreeBookmarksSort         = get(g:, 'NERDTreeBookmarksSort',         1)[J

line 43: let g:NERDTreeHighlightCursorline   = get(g:, 'NERDTreeHighlightCursorline',   1)[J

line 44: let g:NERDTreeHijackNetrw           = get(g:, 'NERDTreeHijackNetrw',           1)[J

line 45: let g:NERDTreeMarkBookmarks         = get(g:, 'NERDTreeMarkBookmarks',         1)[J

line 46: let g:NERDTreeMouseMode             = get(g:, 'NERDTreeMouseMode',             1)[J

line 47: let g:NERDTreeNotificationThreshold = get(g:, 'NERDTreeNotificationThreshold', 100)[J

line 48: let g:NERDTreeQuitOnOpen            = get(g:, 'NERDTreeQuitOnOpen',            0)[J

line 49: let g:NERDTreeRespectWildIgnore     = get(g:, 'NERDTreeRespectWildIgnore',     0)[J

line 50: let g:NERDTreeShowBookmarks         = get(g:, 'NERDTreeShowBookmarks',         0)[J

line 51: let g:NERDTreeShowFiles             = get(g:, 'NERDTreeShowFiles',             1)[J

line 52: let g:NERDTreeShowHidden            = get(g:, 'NERDTreeShowHidden',            0)[J

line 53: let g:NERDTreeShowLineNumbers       = get(g:, 'NERDTreeShowLineNumbers',       0)[J

line 54: let g:NERDTreeSortDirs              = get(g:, 'NERDTreeSortDirs',              1)[J

line 55: [J

line 56: if !nerdtree#runningWindows() && !nerdtree#runningCygwin()[J

Searching for "autoload/nerdtree.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/autoload/nerdtree.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/autoload/nerdtree.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/autoload/nerdtree.vim"[J
chdir(/Users/tsen/.vim/bundle/nerdtree/autoload)[J
fchdir() to previous dir[J
line 56: sourcing "/Users/tsen/.vim/bundle/nerdtree/autoload/nerdtree.vim"[J
line 1: if exists('g:loaded_nerdtree_autoload')[J

line 2:     finish[J

line 3: endif[J

line 4: let g:loaded_nerdtree_autoload = 1[J

line 5: [J

line 6: let s:rootNERDTreePath = resolve(expand('<sfile>:p:h:h'))[J

line 7: [J

line 8: "FUNCTION: nerdtree#version(...) {{{1[J

line 9: "  If any value is given as an argument, the entire line of text from the[J

line 10: "  change log is shown for the current version; otherwise, only the version[J

line 11: "  number is shown.[J

line 12: function! nerdtree#version(...) abort[J

line 29: [J

line 30: " SECTION: General Functions {{{1[J

line 31: "============================================================[J

line 32: [J

line 33: " FUNCTION: nerdtree#closeTreeOnOpen() {{{2[J

line 34: function! nerdtree#closeTreeOnOpen() abort[J

line 37: [J

line 38: " FUNCTION: nerdtree#closeBookmarksOnOpen() {{{2[J

line 39: function! nerdtree#closeBookmarksOnOpen() abort[J

line 42: [J

line 43: " FUNCTION: nerdtree#slash() {{{2[J

line 44: " Return the path separator used by the underlying file system.  Special[J

line 45: " consideration is taken for the use of the 'shellslash' option on Windows[J

line 46: " systems.[J

line 47: function! nerdtree#slash() abort[J

line 58: [J

line 59: "FUNCTION: nerdtree#checkForBrowse(dir) {{{2[J

line 60: "inits a window tree in the current buffer if appropriate[J

line 61: function! nerdtree#checkForBrowse(dir) abort[J

line 72: [J

line 73: "FUNCTION: s:reuseWin(dir) {{{2[J

line 74: "finds a NERDTree buffer with root of dir, and opens it.[J

line 75: function! s:reuseWin(dir) abort[J

line 94: [J

line 95: " FUNCTION: nerdtree#completeBookmarks(A,L,P) {{{2[J

line 96: " completion function for the bookmark commands[J

line 97: function! nerdtree#completeBookmarks(A,L,P) abort[J

line 100: [J

line 101: "FUNCTION: nerdtree#compareNodes(n1, n2) {{{2[J

line 102: function! nerdtree#compareNodes(n1, n2) abort[J

line 105: [J

line 106: "FUNCTION: nerdtree#compareNodePaths(p1, p2) {{{2[J

line 107: function! nerdtree#compareNodePaths(p1, p2) abort[J

line 139: [J

line 140: " FUNCTION: nerdtree#deprecated(func, [msg]) {{{2[J

line 141: " Issue a deprecation warning for a:func. If a second arg is given, use this[J

line 142: " as the deprecation message[J

line 143: function! nerdtree#deprecated(func, ...) abort[J

line 154: [J

line 155: " FUNCTION: nerdtree#exec(cmd, ignoreAll) {{{2[J

line 156: " Same as :exec cmd but, if ignoreAll is TRUE, set eventignore=all for the duration[J

line 157: function! nerdtree#exec(cmd, ignoreAll) abort[J

line 168: [J

line 169: " FUNCTION: nerdtree#has_opt(options, name) {{{2[J

line 170: function! nerdtree#has_opt(options, name) abort[J

line 173: [J

line 174: " FUNCTION: nerdtree#loadClassFiles() {{{2[J

line 175: function! nerdtree#loadClassFiles() abort[J

line 191: [J

line 192: " FUNCTION: nerdtree#postSourceActions() {{{2[J

line 193: function! nerdtree#postSourceActions() abort[J

line 200: [J

line 201: "FUNCTION: nerdtree#runningWindows(dir) {{{2[J

line 202: function! nerdtree#runningWindows() abort[J

line 205: [J

line 206: "FUNCTION: nerdtree#runningCygwin(dir) {{{2[J

line 207: function! nerdtree#runningCygwin() abort[J

line 210: [J

line 211: " SECTION: View Functions {{{1[J

line 212: "============================================================[J

line 213: [J

line 214: "FUNCTION: nerdtree#echo  {{{2[J

line 215: "A wrapper for :echo. Appends 'NERDTree:' on the front of all messages[J

line 216: "[J

line 217: "Args:[J

line 218: "msg: the message to echo[J

line 219: function! nerdtree#echo(msg) abort[J

line 223: [J

line 224: "FUNCTION: nerdtree#echoError {{{2[J

line 225: "Wrapper for nerdtree#echo, sets the message type to errormsg for this message[J

line 226: "Args:[J

line 227: "msg: the message to echo[J

line 228: function! nerdtree#echoError(msg) abort[J

line 233: [J

line 234: "FUNCTION: nerdtree#echoWarning {{{2[J

line 235: "Wrapper for nerdtree#echo, sets the message type to warningmsg for this message[J

line 236: "Args:[J

line 237: "msg: the message to echo[J

line 238: function! nerdtree#echoWarning(msg) abort[J

line 243: [J

line 244: "FUNCTION: nerdtree#renderView {{{2[J

line 245: function! nerdtree#renderView() abort[J

line 248: [J

line 249: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/autoload/nerdtree.vim[J
continuing in /Users/tsen/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J
calling nerdtree#runningWindows[J()

line 1:     return has('win16') || has('win32') || has('win64')[J

nerdtree#runningWindows returning #0[J

continuing in /Users/tsen/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

calling nerdtree#runningCygwin[J()

line 1:     return has('win32unix')[J

nerdtree#runningCygwin returning #0[J

continuing in /Users/tsen/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 57:     let g:NERDTreeDirArrowExpandable  = get(g:, 'NERDTreeDirArrowExpandable',  '▸')[J

line 58:     let g:NERDTreeDirArrowCollapsible = get(g:, 'NERDTreeDirArrowCollapsible', '▾')[J

line 59: else[J

line 60:     let g:NERDTreeDirArrowExpandable  = get(g:, 'NERDTreeDirArrowExpandable',  '+')[J

line 61:     let g:NERDTreeDirArrowCollapsible = get(g:, 'NERDTreeDirArrowCollapsible', '~')[J

line 62: endif[J

line 63: [J

line 64: let g:NERDTreeCascadeOpenSingleChildDir = get(g:, 'NERDTreeCascadeOpenSingleChildDir', 1)[J

line 65: let g:NERDTreeCascadeSingleChildDir     = get(g:, 'NERDTreeCascadeSingleChildDir',     1)[J

line 66: [J

line 67: let g:NERDTreeSortOrder    = get(g:, 'NERDTreeSortOrder', ['\/$', '*', '\.swp$', '\.bak$', '\~$'])[J

line 68: let g:NERDTreeOldSortOrder = [][J

line 69: [J

line 70: let g:NERDTreeGlyphReadOnly = get(g:, 'NERDTreeGlyphReadOnly', 'RO')[J

line 71: [J

line 72: if has('conceal')[J

line 73:     let g:NERDTreeNodeDelimiter = get(g:, 'NERDTreeNodeDelimiter', "\x07")[J

line 74: elseif (g:NERDTreeDirArrowExpandable ==# "\u00a0" || g:NERDTreeDirArrowCollapsible ==# "\u00a0")[J

line 75:     let g:NERDTreeNodeDelimiter = get(g:, 'NERDTreeNodeDelimiter', "\u00b7")[J

line 76: else[J

line 77:     let g:NERDTreeNodeDelimiter = get(g:, 'NERDTreeNodeDelimiter', "\u00a0")[J

line 78: endif[J

line 79: [J

line 80: "the exists() crap here is a hack to stop vim spazzing out when[J

line 81: "loading a session that was created with an open nerd tree. It spazzes[J

line 82: "because it doesnt store b:NERDTree(its a b: var, and its a hash)[J

line 83: let g:NERDTreeStatusline = get(g:, 'NERDTreeStatusline', "%{exists('b:NERDTree')?b:NERDTree.root.path.str():''}")[J

line 84: [J

line 85: let g:NERDTreeWinPos  = get(g:, 'NERDTreeWinPos', 'left')[J

line 86: let g:NERDTreeWinSize = get(g:, 'NERDTreeWinSize', 31)[J

line 87: [J

line 88: "init the shell commands that will be used to copy nodes, and remove dir trees[J

line 89: "Note: the space after the command is important[J

line 90: if nerdtree#runningWindows()[J

calling nerdtree#runningWindows[J()

line 1:     return has('win16') || has('win32') || has('win64')[J

nerdtree#runningWindows returning #0[J

continuing in /Users/tsen/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 91:     let g:NERDTreeRemoveDirCmd = get(g:, 'NERDTreeRemoveDirCmd', 'rmdir /s /q ')[J

line 92:     let g:NERDTreeCopyDirCmd   = get(g:, 'NERDTreeCopyDirCmd',   'xcopy /s /e /i /y /q ')[J

line 93:     let g:NERDTreeCopyFileCmd  = get(g:, 'NERDTreeCopyFileCmd',  'copy /y ')[J

line 94: else[J

line 95:     let g:NERDTreeRemoveDirCmd = get(g:, 'NERDTreeRemoveDirCmd', 'rm -rf ')[J

line 96:     let g:NERDTreeCopyCmd      = get(g:, 'NERDTreeCopyCmd',      'cp -r ')[J

line 97: endif[J

line 98: [J

line 99: "SECTION: Init variable calls for key mappings {{{2[J

line 100: let g:NERDTreeMapCustomOpen      = get(g:, 'NERDTreeMapCustomOpen',      '<CR>')[J

line 101: let g:NERDTreeMapActivateNode    = get(g:, 'NERDTreeMapActivateNode',    'o')[J

line 102: let g:NERDTreeMapChangeRoot      = get(g:, 'NERDTreeMapChangeRoot',      'C')[J

line 103: let g:NERDTreeMapChdir           = get(g:, 'NERDTreeMapChdir',           'cd')[J

line 104: let g:NERDTreeMapCloseChildren   = get(g:, 'NERDTreeMapCloseChildren',   'X')[J

line 105: let g:NERDTreeMapCloseDir        = get(g:, 'NERDTreeMapCloseDir',        'x')[J

line 106: let g:NERDTreeMapDeleteBookmark  = get(g:, 'NERDTreeMapDeleteBookmark',  'D')[J

line 107: let g:NERDTreeMapMenu            = get(g:, 'NERDTreeMapMenu',            'm')[J

line 108: let g:NERDTreeMapHelp            = get(g:, 'NERDTreeMapHelp',            '?')[J

line 109: let g:NERDTreeMapJumpFirstChild  = get(g:, 'NERDTreeMapJumpFirstChild',  'K')[J

line 110: let g:NERDTreeMapJumpLastChild   = get(g:, 'NERDTreeMapJumpLastChild',   'J')[J

line 111: let g:NERDTreeMapJumpNextSibling = get(g:, 'NERDTreeMapJumpNextSibling', '<C-j>')[J

line 112: let g:NERDTreeMapJumpParent      = get(g:, 'NERDTreeMapJumpParent',      'p')[J

line 113: let g:NERDTreeMapJumpPrevSibling = get(g:, 'NERDTreeMapJumpPrevSibling', '<C-k>')[J

line 114: let g:NERDTreeMapJumpRoot        = get(g:, 'NERDTreeMapJumpRoot',        'P')[J

line 115: let g:NERDTreeMapOpenExpl        = get(g:, 'NERDTreeMapOpenExpl',        'e')[J

line 116: let g:NERDTreeMapOpenInTab       = get(g:, 'NERDTreeMapOpenInTab',       't')[J

line 117: let g:NERDTreeMapOpenInTabSilent = get(g:, 'NERDTreeMapOpenInTabSilent', 'T')[J

line 118: let g:NERDTreeMapOpenRecursively = get(g:, 'NERDTreeMapOpenRecursively', 'O')[J

line 119: let g:NERDTreeMapOpenSplit       = get(g:, 'NERDTreeMapOpenSplit',       'i')[J

line 120: let g:NERDTreeMapOpenVSplit      = get(g:, 'NERDTreeMapOpenVSplit',      's')[J

line 121: let g:NERDTreeMapPreview         = get(g:, 'NERDTreeMapPreview',         'g'.NERDTreeMapActivateNode)[J

line 122: let g:NERDTreeMapPreviewSplit    = get(g:, 'NERDTreeMapPreviewSplit',    'g'.NERDTreeMapOpenSplit)[J

line 123: let g:NERDTreeMapPreviewVSplit   = get(g:, 'NERDTreeMapPreviewVSplit',   'g'.NERDTreeMapOpenVSplit)[J

line 124: let g:NERDTreeMapQuit            = get(g:, 'NERDTreeMapQuit',            'q')[J

line 125: let g:NERDTreeMapRefresh         = get(g:, 'NERDTreeMapRefresh',         'r')[J

line 126: let g:NERDTreeMapRefreshRoot     = get(g:, 'NERDTreeMapRefreshRoot',     'R')[J

line 127: let g:NERDTreeMapToggleBookmarks = get(g:, 'NERDTreeMapToggleBookmarks', 'B')[J

line 128: let g:NERDTreeMapToggleFiles     = get(g:, 'NERDTreeMapToggleFiles',     'F')[J

line 129: let g:NERDTreeMapToggleFilters   = get(g:, 'NERDTreeMapToggleFilters',   'f')[J

line 130: let g:NERDTreeMapToggleHidden    = get(g:, 'NERDTreeMapToggleHidden',    'I')[J

line 131: let g:NERDTreeMapToggleZoom      = get(g:, 'NERDTreeMapToggleZoom',      'A')[J

line 132: let g:NERDTreeMapUpdir           = get(g:, 'NERDTreeMapUpdir',           'u')[J

line 133: let g:NERDTreeMapUpdirKeepOpen   = get(g:, 'NERDTreeMapUpdirKeepOpen',   'U')[J

line 134: let g:NERDTreeMapCWD             = get(g:, 'NERDTreeMapCWD',             'CD')[J

line 135: let g:NERDTreeMenuDown           = get(g:, 'NERDTreeMenuDown',           'j')[J

line 136: let g:NERDTreeMenuUp             = get(g:, 'NERDTreeMenuUp',             'k')[J

line 137: [J

line 138: "SECTION: Load class files{{{2[J

line 139: call nerdtree#loadClassFiles()[J

calling nerdtree#loadClassFiles[J()

line 1:     runtime lib/nerdtree/path.vim[J

Searching for "lib/nerdtree/path.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/lib/nerdtree/path.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/lib/nerdtree/path.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/path.vim"[J
chdir(/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 1: sourcing "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/path.vim"[J
line 1: " ============================================================================[J

line 2: " CLASS: Path[J

line 3: "[J

line 4: " The Path class provides an abstracted representation of a file system[J

line 5: " pathname.  Various operations on pathnames are provided and a number of[J

line 6: " representations of a given path name can be accessed here.[J

line 7: " ============================================================================[J

line 8: [J

line 9: [J

line 10: let s:Path = {}[J

line 11: let g:NERDTreePath = s:Path[J

line 12: [J

line 13: " FUNCTION: Path.AbsolutePathFor(pathStr) {{{1[J

line 14: function! s:Path.AbsolutePathFor(pathStr)[J

line 37: [J

line 38: " FUNCTION: Path.bookmarkNames() {{{1[J

line 39: function! s:Path.bookmarkNames()[J

line 45: [J

line 46: " FUNCTION: Path.cacheDisplayString() {{{1[J

line 47: function! s:Path.cacheDisplayString() abort[J

line 72: [J

line 73: " FUNCTION: Path.addDelimiter() {{{1[J

line 74: function! s:Path.addDelimiter(line)[J

line 81: [J

line 82: " FUNCTION: Path.changeToDir() {{{1[J

line 83: function! s:Path.changeToDir()[J

line 101: [J

line 102: " FUNCTION: Path.Create(fullpath) {{{1[J

line 103: "[J

line 104: " Factory method.[J

line 105: "[J

line 106: " Creates a path object with the given path. The path is also created on the[J

line 107: " filesystem. If the path already exists, a NERDTree.Path.Exists exception is[J

line 108: " thrown. If any other errors occur, a NERDTree.Path exception is thrown.[J

line 109: "[J

line 110: " Args:[J

line 111: " fullpath: the full filesystem path to the file/dir to create[J

line 112: function! s:Path.Create(fullpath)[J

line 138: [J

line 139: " FUNCTION: Path.copy(dest) {{{1[J

line 140: "[J

line 141: " Copies the file/dir represented by this Path to the given location[J

line 142: "[J

line 143: " Args:[J

line 144: " dest: the location to copy this dir/file to[J

line 145: function! s:Path.copy(dest)[J

line 164: [J

line 165: " FUNCTION: Path.CopyingSupported() {{{1[J

line 166: "[J

line 167: " returns 1 if copying is supported for this OS[J

line 168: function! s:Path.CopyingSupported()[J

line 171: [J

line 172: " FUNCTION: Path.copyingWillOverwrite(dest) {{{1[J

line 173: "[J

line 174: " returns 1 if copy this path to the given location will cause files to[J

line 175: " overwritten[J

line 176: "[J

line 177: " Args:[J

line 178: " dest: the location this path will be copied to[J

line 179: function! s:Path.copyingWillOverwrite(dest)[J

line 191: [J

line 192: " FUNCTION: Path.createParentDirectories(path) {{{1[J

line 193: "[J

line 194: " create parent directories for this path if needed[J

line 195: " without throwing any errors if those directories already exist[J

line 196: "[J

line 197: " Args:[J

line 198: " path: full path of the node whose parent directories may need to be created[J

line 199: function! s:Path.createParentDirectories(path)[J

line 205: [J

line 206: " FUNCTION: Path.delete() {{{1[J

line 207: "[J

line 208: " Deletes the file or directory represented by this path.[J

line 209: "[J

line 210: " Throws NERDTree.Path.Deletion exceptions[J

line 211: function! s:Path.delete()[J

line 239: [J

line 240: " FUNCTION: Path.displayString() {{{1[J

line 241: "[J

line 242: " Returns a string that specifies how the path should be represented as a[J

line 243: " string[J

line 244: function! s:Path.displayString()[J

line 251: [J

line 252: " FUNCTION: Path.edit() {{{1[J

line 253: function! s:Path.edit()[J

line 259: [J

line 260: " FUNCTION: Path.extractDriveLetter(fullpath) {{{1[J

line 261: "[J

line 262: " If running windows, cache the drive letter for this path[J

line 263: function! s:Path.extractDriveLetter(fullpath)[J

line 277: [J

line 278: " FUNCTION: Path.exists() {{{1[J

line 279: " return 1 if this path points to a location that is readable or is a directory[J

line 280: function! s:Path.exists()[J

line 284: [J

line 285: " FUNCTION: Path._escChars() {{{1[J

line 286: function! s:Path._escChars()[J

line 293: [J

line 294: " FUNCTION: Path.getDir() {{{1[J

line 295: "[J

line 296: " Returns this path if it is a directory, else this paths parent.[J

line 297: "[J

line 298: " Return:[J

line 299: " a Path object[J

line 300: function! s:Path.getDir()[J

line 307: [J

line 308: " FUNCTION: Path.getParent() {{{1[J

line 309: "[J

line 310: " Returns a new path object for this paths parent[J

line 311: "[J

line 312: " Return:[J

line 313: " a new Path object[J

line 314: function! s:Path.getParent()[J

line 323: [J

line 324: " FUNCTION: Path.getLastPathComponent(dirSlash) {{{1[J

line 325: "[J

line 326: " Gets the last part of this path.[J

line 327: "[J

line 328: " Args:[J

line 329: " dirSlash: if 1 then a trailing slash will be added to the returned value for[J

line 330: " directory nodes.[J

line 331: function! s:Path.getLastPathComponent(dirSlash)[J

line 341: [J

line 342: " FUNCTION: Path.getSortOrderIndex() {{{1[J

line 343: " returns the index of the pattern in g:NERDTreeSortOrder that this path matches[J

line 344: function! s:Path.getSortOrderIndex()[J

line 356: [J

line 357: " FUNCTION: Path._splitChunks(path) {{{1[J

line 358: " returns a list of path chunks[J

line 359: function! s:Path._splitChunks(path)[J

line 371: [J

line 372: " FUNCTION: Path.getSortKey() {{{1[J

line 373: " returns a key used in compare function for sorting[J

line 374: function! s:Path.getSortKey()[J

line 409: [J

line 410: " FUNCTION: Path.isHiddenUnder(path) {{{1[J

line 411: function! s:Path.isHiddenUnder(path)[J

line 429: [J

line 430: " FUNCTION: Path.isUnixHiddenFile() {{{1[J

line 431: " check for unix hidden files[J

line 432: function! s:Path.isUnixHiddenFile()[J

line 435: [J

line 436: " FUNCTION: Path.isUnixHiddenPath() {{{1[J

line 437: " check for unix path with hidden components[J

line 438: function! s:Path.isUnixHiddenPath()[J

line 450: [J

line 451: " FUNCTION: Path.ignore(nerdtree) {{{1[J

line 452: " returns true if this path should be ignored[J

line 453: function! s:Path.ignore(nerdtree)[J

line 481: [J

line 482: " FUNCTION: Path._ignorePatternMatches(pattern) {{{1[J

line 483: " returns true if this path matches the given ignore pattern[J

line 484: function! s:Path._ignorePatternMatches(pattern)[J

line 503: [J

line 504: " FUNCTION: Path.isAncestor(path) {{{1[J

line 505: " return 1 if this path is somewhere above the given path in the filesystem.[J

line 506: "[J

line 507: " a:path should be a dir[J

line 508: function! s:Path.isAncestor(child)[J

line 511: [J

line 512: " FUNCTION: Path.isUnder(path) {{{1[J

line 513: " return 1 if this path is somewhere under the given path in the filesystem.[J

line 514: function! s:Path.isUnder(parent)[J

line 539: [J

line 540: " FUNCTION: Path.JoinPathStrings(...) {{{1[J

line 541: function! s:Path.JoinPathStrings(...)[J

line 548: [J

line 549: " FUNCTION: Path.equals() {{{1[J

line 550: "[J

line 551: " Determines whether 2 path objects are "equal".[J

line 552: " They are equal if the paths they represent are the same[J

line 553: "[J

line 554: " Args:[J

line 555: " path: the other path obj to compare this with[J

line 556: function! s:Path.equals(path)[J

line 563: [J

line 564: " FUNCTION: Path.New(pathStr) {{{1[J

line 565: function! s:Path.New(pathStr)[J

line 575: [J

line 576: " FUNCTION: Path.Resolve() {{{1[J

line 577: " Invoke the vim resolve() function and return the result[J

line 578: " This is necessary because in some versions of vim resolve() removes trailing[J

line 579: " slashes while in other versions it doesn't.  This always removes the trailing[J

line 580: " slash[J

line 581: function! s:Path.Resolve(path)[J

line 585: [J

line 586: " FUNCTION: Path.readInfoFromDisk(fullpath) {{{1[J

line 587: "[J

line 588: "[J

line 589: " Throws NERDTree.Path.InvalidArguments exception.[J

line 590: function! s:Path.readInfoFromDisk(fullpath)[J

line 639: [J

line 640: " FUNCTION: Path.refresh(nerdtree) {{{1[J

line 641: function! s:Path.refresh(nerdtree)[J

line 646: [J

line 647: " FUNCTION: Path.refreshFlags(nerdtree) {{{1[J

line 648: function! s:Path.refreshFlags(nerdtree)[J

line 652: [J

line 653: " FUNCTION: Path.rename() {{{1[J

line 654: "[J

line 655: " Renames this node on the filesystem[J

line 656: function! s:Path.rename(newPath)[J

line 675: [J

line 676: " FUNCTION: Path.str() {{{1[J

line 677: " Return a string representation of this Path object.[J

line 678: "[J

line 679: " Args:[J

line 680: " This function takes a single dictionary (optional) with keys and values that[J

line 681: " specify how the returned pathname should be formatted.[J

line 682: "[J

line 683: " The dictionary may have the following keys:[J

line 684: "  'format'[J

line 685: "  'escape'[J

line 686: "  'truncateTo'[J

line 687: "[J

line 688: " The 'format' key may have a value of:[J

line 689: "  'Cd' - a string to be used with ":cd" and similar commands[J

line 690: "  'Edit' - a string to be used with ":edit" and similar commands[J

line 691: "  'UI' - a string to be displayed in the NERDTree user interface[J

line 692: "[J

line 693: " The 'escape' key, if specified, will cause the output to be escaped with[J

line 694: " Vim's internal "shellescape()" function.[J

line 695: "[J

line 696: " The 'truncateTo' key shortens the length of the path to that given by the[J

line 697: " value associated with 'truncateTo'. A '<' is prepended.[J

line 698: function! s:Path.str(...)[J

line 733: [J

line 734: " FUNCTION: Path._strForUI() {{{1[J

line 735: function! s:Path._strForUI()[J

line 742: [J

line 743: " FUNCTION: Path._strForCd() {{{1[J

line 744: " Return a string representation of this Path that is suitable for use as an[J

line 745: " argument to Vim's internal ":cd" command.[J

line 746: function! s:Path._strForCd()[J

line 749: [J

line 750: " FUNCTION: Path._strForEdit() {{{1[J

line 751: " Return a string representation of this Path that is suitable for use as an[J

line 752: " argument to Vim's internal ":edit" command.[J

line 753: function! s:Path._strForEdit()[J

line 772: [J

line 773: " FUNCTION: Path._strForGlob() {{{1[J

line 774: function! s:Path._strForGlob()[J

line 789: [J

line 790: " FUNCTION: Path._str() {{{1[J

line 791: " Return the absolute pathname associated with this Path object.  The pathname[J

line 792: " returned is appropriate for the underlying file system.[J

line 793: function! s:Path._str()[J

line 803: [J

line 804: " FUNCTION: Path.strTrunk() {{{1[J

line 805: " Gets the path without the last segment on the end.[J

line 806: function! s:Path.strTrunk()[J

line 809: [J

line 810: " FUNCTION: Path.tabnr() {{{1[J

line 811: " return the number of the first tab that is displaying this file[J

line 812: "[J

line 813: " return 0 if no tab was found[J

line 814: function! s:Path.tabnr()[J

line 825: [J

line 826: " FUNCTION: Path.WinToUnixPath(pathstr){{{1[J

line 827: " Takes in a windows path and returns the unix equiv[J

line 828: "[J

line 829: " A class level method[J

line 830: "[J

line 831: " Args:[J

line 832: " pathstr: the windows path to convert[J

line 833: function! s:Path.WinToUnixPath(pathstr)[J

line 851: [J

line 852: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/path.vim[J
continuing in nerdtree#loadClassFiles[J
line 2:     runtime lib/nerdtree/menu_controller.vim[J

Searching for "lib/nerdtree/menu_controller.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/lib/nerdtree/menu_controller.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/lib/nerdtree/menu_controller.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/menu_controller.vim"[J
chdir(/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 2: sourcing "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/menu_controller.vim"[J
line 1: "CLASS: MenuController[J

line 2: "============================================================[J

line 3: let s:MenuController = {}[J

line 4: let g:NERDTreeMenuController = s:MenuController[J

line 5: [J

line 6: "FUNCTION: MenuController.New(menuItems) {{{1[J

line 7: "create a new menu controller that operates on the given menu items[J

line 8: function! s:MenuController.New(menuItems)[J

line 17: [J

line 18: " FUNCTION: s:MenuController.isMinimal() {{{1[J

line 19: function! s:MenuController.isMinimal()[J

line 22: [J

line 23: " FUNCTION: MenuController.showMenu() {{{1[J

line 24: " Enter the main loop of the NERDTree menu, prompting the user to select[J

line 25: " a menu item.[J

line 26: function! s:MenuController.showMenu()[J

line 58: [J

line 59: "FUNCTION: MenuController._echoPrompt() {{{1[J

line 60: function! s:MenuController._echoPrompt()[J

line 84: [J

line 85: "FUNCTION: MenuController._current(key) {{{1[J

line 86: "get the MenuItem that is currently selected[J

line 87: function! s:MenuController._current()[J

line 90: [J

line 91: "FUNCTION: MenuController._handleKeypress(key) {{{1[J

line 92: "change the selection (if appropriate) and return 1 if the user has made[J

line 93: "their choice, 0 otherwise[J

line 94: function! s:MenuController._handleKeypress(key)[J

line 116: [J

line 117: "FUNCTION: MenuController._allIndexesFor(shortcut) {{{1[J

line 118: "get indexes to all menu items with the given shortcut[J

line 119: function! s:MenuController._allIndexesFor(shortcut)[J

line 130: [J

line 131: "FUNCTION: MenuController._nextIndexFor(shortcut) {{{1[J

line 132: "get the index to the next menu item with the given shortcut, starts from the[J

line 133: "current cursor location and wraps around to the top again if need be[J

line 134: function! s:MenuController._nextIndexFor(shortcut)[J

line 149: [J

line 150: "FUNCTION: MenuController._setCmdheight() {{{1[J

line 151: "sets &cmdheight to whatever is needed to display the menu[J

line 152: function! s:MenuController._setCmdheight()[J

line 159: [J

line 160: "FUNCTION: MenuController._saveOptions() {{{1[J

line 161: "set any vim options that are required to make the menu work (saving their old[J

line 162: "values)[J

line 163: function! s:MenuController._saveOptions()[J

line 169: [J

line 170: "FUNCTION: MenuController._restoreOptions() {{{1[J

line 171: "restore the options we saved in _saveOptions()[J

line 172: function! s:MenuController._restoreOptions()[J

line 176: [J

line 177: "FUNCTION: MenuController._cursorDown() {{{1[J

line 178: "move the cursor to the next menu item, skipping separators[J

line 179: function! s:MenuController._cursorDown()[J

line 193: [J

line 194: "FUNCTION: MenuController._cursorUp() {{{1[J

line 195: "move the cursor to the previous menu item, skipping separators[J

line 196: function! s:MenuController._cursorUp()[J

line 210: [J

line 211: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/menu_controller.vim[J
continuing in nerdtree#loadClassFiles[J
line 3:     runtime lib/nerdtree/menu_item.vim[J

Searching for "lib/nerdtree/menu_item.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/lib/nerdtree/menu_item.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/lib/nerdtree/menu_item.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/menu_item.vim"[J
chdir(/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 3: sourcing "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/menu_item.vim"[J
line 1: "CLASS: MenuItem[J

line 2: "============================================================[J

line 3: let s:MenuItem = {}[J

line 4: let g:NERDTreeMenuItem = s:MenuItem[J

line 5: [J

line 6: "FUNCTION: MenuItem.All() {{{1[J

line 7: "get all top level menu items[J

line 8: function! s:MenuItem.All()[J

line 14: [J

line 15: "FUNCTION: MenuItem.AllEnabled() {{{1[J

line 16: "get all top level menu items that are currently enabled[J

line 17: function! s:MenuItem.AllEnabled()[J

line 26: [J

line 27: "FUNCTION: MenuItem.Create(options) {{{1[J

line 28: "make a new menu item and add it to the global list[J

line 29: function! s:MenuItem.Create(options)[J

line 54: [J

line 55: "FUNCTION: MenuItem.CreateSeparator(options) {{{1[J

line 56: "make a new separator menu item and add it to the global list[J

line 57: function! s:MenuItem.CreateSeparator(options)[J

line 65: [J

line 66: "FUNCTION: MenuItem.CreateSubmenu(options) {{{1[J

line 67: "make a new submenu and add it to global list[J

line 68: function! s:MenuItem.CreateSubmenu(options)[J

line 74: [J

line 75: "FUNCTION: MenuItem.enabled() {{{1[J

line 76: "return 1 if this menu item should be displayed[J

line 77: "[J

line 78: "delegates off to the isActiveCallback, and defaults to 1 if no callback was[J

line 79: "specified[J

line 80: function! s:MenuItem.enabled()[J

line 86: [J

line 87: "FUNCTION: MenuItem.execute() {{{1[J

line 88: "perform the action behind this menu item, if this menuitem has children then[J

line 89: "display a new menu for them, otherwise deletegate off to the menuitem's[J

line 90: "callback[J

line 91: function! s:MenuItem.execute()[J

line 105: [J

line 106: "FUNCTION: MenuItem.isSeparator() {{{1[J

line 107: "return 1 if this menuitem is a separator[J

line 108: function! s:MenuItem.isSeparator()[J

line 111: [J

line 112: "FUNCTION: MenuItem.isSubmenu() {{{1[J

line 113: "return 1 if this menuitem is a submenu[J

line 114: function! s:MenuItem.isSubmenu()[J

line 117: [J

line 118: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/menu_item.vim[J
continuing in nerdtree#loadClassFiles[J
line 4:     runtime lib/nerdtree/key_map.vim[J

Searching for "lib/nerdtree/key_map.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/lib/nerdtree/key_map.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/lib/nerdtree/key_map.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim"[J
chdir(/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 4: sourcing "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim"[J
line 1: "CLASS: KeyMap[J

line 2: "============================================================[J

line 3: let s:KeyMap = {}[J

line 4: let g:NERDTreeKeyMap = s:KeyMap[J

line 5: let s:keyMaps = {}[J

line 6: [J

line 7: "FUNCTION: KeyMap.All() {{{1[J

line 8: function! s:KeyMap.All()[J

line 14: [J

line 15: "FUNCTION: KeyMap.Compare(keyMap1, keyMap2) {{{1[J

line 16: function! s:KeyMap.Compare(keyMap1, keyMap2)[J

line 28: [J

line 29: "FUNCTION: KeyMap.FindFor(key, scope) {{{1[J

line 30: function! s:KeyMap.FindFor(key, scope)[J

line 33: [J

line 34: "FUNCTION: KeyMap.BindAll() {{{1[J

line 35: function! s:KeyMap.BindAll()[J

line 40: [J

line 41: "FUNCTION: KeyMap.bind() {{{1[J

line 42: function! s:KeyMap.bind()[J

line 60: [J

line 61: "FUNCTION: KeyMap.Remove(key, scope) {{{1[J

line 62: function! s:KeyMap.Remove(key, scope)[J

line 65: [J

line 66: "FUNCTION: KeyMap.invoke() {{{1[J

line 67: "Call the KeyMaps callback function[J

line 68: function! s:KeyMap.invoke(...)[J

line 76: [J

line 77: "FUNCTION: KeyMap.Invoke() {{{1[J

line 78: "Find a keymapping for a:key and the current scope invoke it.[J

line 79: "[J

line 80: "Scope is determined as follows:[J

line 81: "   * if the cursor is on a dir node then DirNode[J

line 82: "   * if the cursor is on a file node then FileNode[J

line 83: "   * if the cursor is on a bookmark then Bookmark[J

line 84: "[J

line 85: "If a keymap has the scope of 'all' then it will be called if no other keymap[J

line 86: "is found for a:key and the scope.[J

line 87: function! s:KeyMap.Invoke(key)[J

line 140: [J

line 141: "FUNCTION: KeyMap.Create(options) {{{1[J

line 142: function! s:KeyMap.Create(options)[J

line 158: [J

line 159: "FUNCTION: KeyMap.Add(keymap) {{{1[J

line 160: function! s:KeyMap.Add(keymap)[J

line 163: [J

line 164: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim[J
continuing in nerdtree#loadClassFiles[J
line 5:     runtime lib/nerdtree/bookmark.vim[J

Searching for "lib/nerdtree/bookmark.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/lib/nerdtree/bookmark.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/lib/nerdtree/bookmark.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim"[J
chdir(/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 5: sourcing "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim"[J
line 1: " ============================================================================[J

line 2: " CLASS: Bookmark[J

line 3: "[J

line 4: " The Bookmark class serves two purposes:[J

line 5: "   (1) It is the top-level prototype for new, concrete Bookmark objects.[J

line 6: "   (2) It provides an interface for client code to query and manipulate the[J

line 7: "       global list of Bookmark objects within the current Vim session.[J

line 8: " ============================================================================[J

line 9: [J

line 10: [J

line 11: let s:Bookmark = {}[J

line 12: let g:NERDTreeBookmark = s:Bookmark[J

line 13: [J

line 14: " FUNCTION: Bookmark.activate(nerdtree) {{{1[J

line 15: function! s:Bookmark.activate(nerdtree, ...)[J

line 18: [J

line 19: " FUNCTION: Bookmark.AddBookmark(name, path) {{{1[J

line 20: " Class method to add a new bookmark to the list, if a previous bookmark exists[J

line 21: " with the same name, just update the path for that bookmark[J

line 22: function! s:Bookmark.AddBookmark(name, path)[J

line 31: [J

line 32: " FUNCTION: Bookmark.Bookmarks() {{{1[J

line 33: " Class method to get all bookmarks. Lazily initializes the bookmarks global[J

line 34: " variable[J

line 35: function! s:Bookmark.Bookmarks()[J

line 41: [J

line 42: " FUNCTION: Bookmark.BookmarkExistsFor(name) {{{1[J

line 43: " class method that returns 1 if a bookmark with the given name is found, 0[J

line 44: " otherwise[J

line 45: function! s:Bookmark.BookmarkExistsFor(name)[J

line 53: [J

line 54: " FUNCTION: Bookmark.BookmarkFor(name) {{{1[J

line 55: " Class method that returns the Bookmark object having the specified name.[J

line 56: " Throws NERDTree.BookmarkNotFoundError if no Bookmark is found.[J

line 57: function! s:Bookmark.BookmarkFor(name)[J

line 70: [J

line 71: " FUNCTION: Bookmark.BookmarkNames() {{{1[J

line 72: " Class method to return an array of all bookmark names[J

line 73: function! s:Bookmark.BookmarkNames()[J

line 80: [J

line 81: " FUNCTION: Bookmark.CacheBookmarks(silent) {{{1[J

line 82: " Class method to read all bookmarks from the bookmarks file initialize[J

line 83: " bookmark objects for each one.[J

line 84: "[J

line 85: " Args:[J

line 86: " silent - dont echo an error msg if invalid bookmarks are found[J

line 87: function! s:Bookmark.CacheBookmarks(silent)[J

line 119: [J

line 120: " FUNCTION: Bookmark.CompareBookmarksByName(firstBookmark, secondBookmark) {{{1[J

line 121: " Class method that indicates the relative position of two bookmarks when[J

line 122: " placed in alphabetical order by name. Case-sensitivity is determined by an[J

line 123: " option. Supports the s:Bookmark.SortBookmarksList() method.[J

line 124: function! s:Bookmark.CompareBookmarksByName(firstBookmark, secondBookmark)[J

line 141: [J

line 142: " FUNCTION: Bookmark.ClearAll() {{{1[J

line 143: " Class method to delete all bookmarks.[J

line 144: function! s:Bookmark.ClearAll()[J

line 150: [J

line 151: " FUNCTION: Bookmark.delete() {{{1[J

line 152: " Delete this bookmark. If the node for this bookmark is under the current[J

line 153: " root, then recache bookmarks for its Path object[J

line 154: function! s:Bookmark.delete()[J

line 158: [J

line 159: " FUNCTION: s:Edit() {{{1[J

line 160: " opens the NERDTreeBookmarks file for manual editing[J

line 161: function! s:Bookmark.Edit()[J

line 165: [J

line 166: " FUNCTION: Bookmark.getNode(nerdtree, searchFromAbsoluteRoot) {{{1[J

line 167: " Returns the tree node object associated with this Bookmark.[J

line 168: " Throws NERDTree.BookmarkedNodeNotFoundError if the node is not found.[J

line 169: "[J

line 170: " Args:[J

line 171: " searchFromAbsoluteRoot: boolean flag, search from the highest cached node[J

line 172: "   if true and from the current tree root if false[J

line 173: function! s:Bookmark.getNode(nerdtree, searchFromAbsoluteRoot)[J

line 185: [J

line 186: " FUNCTION: Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree) {{{1[J

line 187: " Class method that returns the tree node object for the Bookmark with the[J

line 188: " given name. Throws NERDTree.BookmarkNotFoundError if a Bookmark with the[J

line 189: " name does not exist. Throws NERDTree.BookmarkedNodeNotFoundError if a[J

line 190: " tree node for the named Bookmark could not be found.[J

line 191: function! s:Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree)[J

line 195: [J

line 196: " FUNCTION: Bookmark.GetSelected() {{{1[J

line 197: " returns the Bookmark the cursor is over, or {}[J

line 198: function! s:Bookmark.GetSelected()[J

line 210: [J

line 211: " FUNCTION: Bookmark.InvalidBookmarks() {{{1[J

line 212: " Class method to get all invalid bookmark strings read from the bookmarks[J

line 213: " file[J

line 214: function! s:Bookmark.InvalidBookmarks()[J

line 220: [J

line 221: " FUNCTION: Bookmark.mustExist() {{{1[J

line 222: function! s:Bookmark.mustExist()[J

line 229: [J

line 230: " FUNCTION: Bookmark.New(name, path) {{{1[J

line 231: " Create a new bookmark object with the given name and path object[J

line 232: function! s:Bookmark.New(name, path)[J

line 242: [J

line 243: " FUNCTION: Bookmark.open(nerdtree, [options]) {{{1[J

line 244: "Args:[J

line 245: "[J

line 246: "nerdtree: the tree to load open the bookmark in[J

line 247: "[J

line 248: "A dictionary containing the following keys (all optional):[J

line 249: "  'where': Specifies whether the node should be opened in new split/tab or in[J

line 250: "           the previous window. Can be either 'v' (vertical split), 'h'[J

line 251: "           (horizontal split), 't' (new tab) or 'p' (previous window).[J

line 252: "  'reuse': if a window is displaying the file then jump the cursor there[J

line 253: "  'keepopen': dont close the tree window[J

line 254: "  'stay': open the file, but keep the cursor in the tree win[J

line 255: "[J

line 256: function! s:Bookmark.open(nerdtree, ...)[J

line 270: [J

line 271: " FUNCTION: Bookmark.openInNewTab(options) {{{1[J

line 272: " Create a new bookmark object with the given name and path object[J

line 273: function! s:Bookmark.openInNewTab(options)[J

line 277: [J

line 278: " FUNCTION: Bookmark.setPath(path) {{{1[J

line 279: " makes this bookmark point to the given path[J

line 280: function! s:Bookmark.setPath(path)[J

line 283: [J

line 284: " FUNCTION: Bookmark.SortBookmarksList() {{{1[J

line 285: " Class method that sorts the global list of bookmarks alphabetically by name.[J

line 286: " Note that case-sensitivity is determined by a user option.[J

line 287: function! s:Bookmark.SortBookmarksList()[J

line 290: [J

line 291: " FUNCTION: Bookmark.str() {{{1[J

line 292: " Get the string that should be rendered in the view for this bookmark[J

line 293: function! s:Bookmark.str()[J

line 308: [J

line 309: " FUNCTION: Bookmark.toRoot(nerdtree) {{{1[J

line 310: " Set the root of the given NERDTree to the node for this Bookmark. If a node[J

line 311: " for this Bookmark does not exist, a new one is initialized.[J

line 312: function! s:Bookmark.toRoot(nerdtree)[J

line 323: [J

line 324: " FUNCTION: Bookmark.ToRoot(name, nerdtree) {{{1[J

line 325: " Class method that makes the Bookmark with the given name the root of[J

line 326: " specified NERDTree.[J

line 327: function! s:Bookmark.ToRoot(name, nerdtree)[J

line 331: [J

line 332: " FUNCTION: Bookmark.validate() {{{1[J

line 333: function! s:Bookmark.validate()[J

line 342: [J

line 343: " FUNCTION: Bookmark.Write() {{{1[J

line 344: " Class method to write all bookmarks to the bookmarks file[J

line 345: function! s:Bookmark.Write()[J

line 364: [J

line 365: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim[J
continuing in nerdtree#loadClassFiles[J
line 6:     runtime lib/nerdtree/tree_file_node.vim[J

Searching for "lib/nerdtree/tree_file_node.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/lib/nerdtree/tree_file_node.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/lib/nerdtree/tree_file_node.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim"[J
chdir(/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 6: sourcing "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim"[J
line 1: " ============================================================================[J

line 2: " CLASS: TreeFileNode[J

line 3: "[J

line 4: " This class is the parent of the TreeDirNode class and is the 'Component'[J

line 5: " part of the composite design pattern between the NERDTree node classes.[J

line 6: " ============================================================================[J

line 7: [J

line 8: [J

line 9: let s:TreeFileNode = {}[J

line 10: let g:NERDTreeFileNode = s:TreeFileNode[J

line 11: [J

line 12: " FUNCTION: TreeFileNode.activate(...) {{{1[J

line 13: function! s:TreeFileNode.activate(...)[J

line 16: [J

line 17: " FUNCTION: TreeFileNode.bookmark(name) {{{1[J

line 18: " bookmark this node with a:name[J

line 19: function! s:TreeFileNode.bookmark(name)[J

line 38: [J

line 39: " FUNCTION: TreeFileNode.cacheParent() {{{1[J

line 40: " initializes self.parent if it isnt already[J

line 41: function! s:TreeFileNode.cacheParent()[J

line 50: [J

line 51: " FUNCTION: TreeFileNode.clearBookmarks() {{{1[J

line 52: function! s:TreeFileNode.clearBookmarks()[J

line 60: [J

line 61: " FUNCTION: TreeFileNode.copy(dest) {{{1[J

line 62: function! s:TreeFileNode.copy(dest)[J

line 73: [J

line 74: " FUNCTION: TreeFileNode.delete {{{1[J

line 75: " Removes this node from the tree and calls the Delete method for its path obj[J

line 76: function! s:TreeFileNode.delete()[J

line 80: [J

line 81: " FUNCTION: TreeFileNode.displayString() {{{1[J

line 82: "[J

line 83: " Returns a string that specifies how the node should be represented as a[J

line 84: " string[J

line 85: "[J

line 86: " Return:[J

line 87: " a string that can be used in the view to represent this node[J

line 88: function! s:TreeFileNode.displayString()[J

line 91: [J

line 92: " FUNCTION: TreeFileNode.equals(treenode) {{{1[J

line 93: "[J

line 94: " Compares this treenode to the input treenode and returns 1 if they are the[J

line 95: " same node.[J

line 96: "[J

line 97: " Use this method instead of ==  because sometimes when the treenodes contain[J

line 98: " many children, vim seg faults when doing ==[J

line 99: "[J

line 100: " Args:[J

line 101: " treenode: the other treenode to compare to[J

line 102: function! s:TreeFileNode.equals(treenode)[J

line 105: [J

line 106: " FUNCTION: TreeFileNode.findNode(path) {{{1[J

line 107: " Returns self if this node.path.Equals the given path.[J

line 108: " Returns {} if not equal.[J

line 109: "[J

line 110: " Args:[J

line 111: " path: the path object to compare against[J

line 112: function! s:TreeFileNode.findNode(path)[J

line 118: [J

line 119: " FUNCTION: TreeFileNode.findSibling(direction) {{{1[J

line 120: " Find the next or previous sibling of this node.[J

line 121: "[J

line 122: " Args:[J

line 123: " direction: 0 for previous, 1 for next[J

line 124: "[J

line 125: " Return:[J

line 126: " The next/previous TreeFileNode object or an empty dictionary if not found.[J

line 127: function! s:TreeFileNode.findSibling(direction)[J

line 155: [J

line 156: " FUNCTION: TreeFileNode.getNerdtree(){{{1[J

line 157: function! s:TreeFileNode.getNerdtree()[J

line 160: [J

line 161: " FUNCTION: TreeFileNode.GetRootForTab(){{{1[J

line 162: " get the root node for this tab[J

line 163: function! s:TreeFileNode.GetRootForTab()[J

line 169: [J

line 170: " FUNCTION: TreeFileNode.GetSelected() {{{1[J

line 171: " If the cursor is currently positioned on a tree node, return the node.[J

line 172: " Otherwise, return the empty dictionary.[J

line 173: function! s:TreeFileNode.GetSelected()[J

line 187: [J

line 188: " FUNCTION: TreeFileNode.isVisible() {{{1[J

line 189: " returns 1 if this node should be visible according to the tree filters and[J

line 190: " hidden file filters (and their on/off status)[J

line 191: function! s:TreeFileNode.isVisible()[J

line 194: [J

line 195: " FUNCTION: TreeFileNode.isRoot() {{{1[J

line 196: function! s:TreeFileNode.isRoot()[J

line 203: [J

line 204: " FUNCTION: TreeFileNode.New(path, nerdtree) {{{1[J

line 205: " Returns a new TreeNode object with the given path and parent[J

line 206: "[J

line 207: " Args:[J

line 208: " path: file/dir that the node represents[J

line 209: " nerdtree: the tree the node belongs to[J

line 210: function! s:TreeFileNode.New(path, nerdtree)[J

line 221: [J

line 222: " FUNCTION: TreeFileNode.open() {{{1[J

line 223: function! s:TreeFileNode.open(...)[J

line 228: [J

line 229: " FUNCTION: TreeFileNode.openSplit() {{{1[J

line 230: " Open this node in a new window[J

line 231: function! s:TreeFileNode.openSplit()[J

line 235: [J

line 236: " FUNCTION: TreeFileNode.openVSplit() {{{1[J

line 237: " Open this node in a new vertical window[J

line 238: function! s:TreeFileNode.openVSplit()[J

line 242: [J

line 243: " FUNCTION: TreeFileNode.openInNewTab(options) {{{1[J

line 244: function! s:TreeFileNode.openInNewTab(options)[J

line 248: [J

line 249: " FUNCTION: TreeFileNode.openExplorer()[J

line 250: function! s:TreeFileNode.openExplorer()[J

line 254: [J

line 255: " FUNCTION: TreeFileNode.putCursorHere(isJump, recurseUpward){{{1[J

line 256: " Places the cursor on the line number this node is rendered on[J

line 257: "[J

line 258: " Args:[J

line 259: " isJump: 1 if this cursor movement should be counted as a jump by vim[J

line 260: " recurseUpward: try to put the cursor on the parent if the this node isnt[J

line 261: " visible[J

line 262: function! s:TreeFileNode.putCursorHere(isJump, recurseUpward)[J

line 281: [J

line 282: " FUNCTION: TreeFileNode.refresh() {{{1[J

line 283: function! s:TreeFileNode.refresh()[J

line 286: [J

line 287: " FUNCTION: TreeFileNode.refreshFlags() {{{1[J

line 288: function! s:TreeFileNode.refreshFlags()[J

line 291: [J

line 292: " FUNCTION: TreeFileNode.rename() {{{1[J

line 293: " Calls the rename method for this nodes path obj[J

line 294: function! s:TreeFileNode.rename(newName)[J

line 307: [J

line 308: " FUNCTION: TreeFileNode.renderToString {{{1[J

line 309: " returns a string representation for this tree to be rendered in the view[J

line 310: function! s:TreeFileNode.renderToString()[J

line 313: [J

line 314: " Args:[J

line 315: " depth: the current depth in the tree for this call[J

line 316: " drawText: 1 if we should actually draw the line for this node (if 0 then the[J

line 317: " child nodes are rendered only)[J

line 318: " for each depth in the tree[J

line 319: function! s:TreeFileNode._renderToString(depth, drawText)[J

line 348: [J

line 349: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim[J
continuing in nerdtree#loadClassFiles[J
line 7:     runtime lib/nerdtree/tree_dir_node.vim[J

Searching for "lib/nerdtree/tree_dir_node.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/lib/nerdtree/tree_dir_node.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/lib/nerdtree/tree_dir_node.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim"[J
chdir(/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 7: sourcing "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim"[J
line 1: " ============================================================================[J

line 2: " CLASS: TreeDirNode[J

line 3: "[J

line 4: " A subclass of NERDTreeFileNode.[J

line 5: "[J

line 6: " The 'composite' part of the file/dir composite.[J

line 7: " ============================================================================[J

line 8: [J

line 9: [J

line 10: let s:TreeDirNode = copy(g:NERDTreeFileNode)[J

line 11: let g:NERDTreeDirNode = s:TreeDirNode[J

line 12: [J

line 13: " FUNCTION: TreeDirNode.AbsoluteTreeRoot(){{{1[J

line 14: " Class method that returns the highest cached ancestor of the current root.[J

line 15: function! s:TreeDirNode.AbsoluteTreeRoot()[J

line 22: [J

line 23: " FUNCTION: TreeDirNode.activate([options]) {{{1[J

line 24: function! s:TreeDirNode.activate(...)[J

line 38: [J

line 39: " FUNCTION: TreeDirNode.addChild(treenode, inOrder) {{{1[J

line 40: " Adds the given treenode to the list of children for this node[J

line 41: "[J

line 42: " Args:[J

line 43: " -treenode: the node to add[J

line 44: " -inOrder: 1 if the new node should be inserted in sorted order[J

line 45: function! s:TreeDirNode.addChild(treenode, inOrder)[J

line 53: [J

line 54: " FUNCTION: TreeDirNode.close() {{{1[J

line 55: " Mark this TreeDirNode as closed.[J

line 56: function! s:TreeDirNode.close()[J

line 64: [J

line 65: " FUNCTION: TreeDirNode.closeChildren() {{{1[J

line 66: " Recursively close any directory nodes that are descendants of this node.[J

line 67: function! s:TreeDirNode.closeChildren()[J

line 75: [J

line 76: " FUNCTION: TreeDirNode.createChild(path, inOrder) {{{1[J

line 77: " Instantiates a new child node for this node with the given path. The new[J

line 78: " nodes parent is set to this node.[J

line 79: "[J

line 80: " Args:[J

line 81: " path: a Path object that this node will represent/contain[J

line 82: " inOrder: 1 if the new node should be inserted in sorted order[J

line 83: "[J

line 84: " Returns:[J

line 85: " the newly created node[J

line 86: function! s:TreeDirNode.createChild(path, inOrder)[J

line 91: [J

line 92: " FUNCTION: TreeDirNode.displayString() {{{1[J

line 93: " Assemble and return a string that can represent this TreeDirNode object in[J

line 94: " the NERDTree window.[J

line 95: function! s:TreeDirNode.displayString()[J

line 113: [J

line 114: " FUNCTION: TreeDirNode.findNode(path) {{{1[J

line 115: " Will find one of the children (recursively) that has the given path[J

line 116: "[J

line 117: " Args:[J

line 118: " path: a path object[J

line 119: unlet s:TreeDirNode.findNode[J

line 120: function! s:TreeDirNode.findNode(path)[J

line 138: [J

line 139: " FUNCTION: TreeDirNode.getCascade() {{{1[J

line 140: " Return an array of dir nodes (starting from self) that can be cascade opened.[J

line 141: function! s:TreeDirNode.getCascade()[J

line 151: [J

line 152: " FUNCTION: TreeDirNode.getCascadeRoot() {{{1[J

line 153: " Return the first directory node in the cascade in which this directory node[J

line 154: " is rendered.[J

line 155: function! s:TreeDirNode.getCascadeRoot()[J

line 177: [J

line 178: " FUNCTION: TreeDirNode.getChildCount() {{{1[J

line 179: " Returns the number of children this node has[J

line 180: function! s:TreeDirNode.getChildCount()[J

line 183: [J

line 184: " FUNCTION: TreeDirNode.getChild(path) {{{1[J

line 185: " Returns child node of this node that has the given path or {} if no such node[J

line 186: " exists.[J

line 187: "[J

line 188: " This function doesnt not recurse into child dir nodes[J

line 189: "[J

line 190: " Args:[J

line 191: " path: a path object[J

line 192: function! s:TreeDirNode.getChild(path)[J

line 205: [J

line 206: " FUNCTION: TreeDirNode.getChildByIndex(indx, visible) {{{1[J

line 207: " returns the child at the given index[J

line 208: "[J

line 209: " Args:[J

line 210: " indx: the index to get the child from[J

line 211: " visible: 1 if only the visible children array should be used, 0 if all the[J

line 212: " children should be searched.[J

line 213: function! s:TreeDirNode.getChildByIndex(indx, visible)[J

line 220: [J

line 221: " FUNCTION: TreeDirNode.getChildIndex(path) {{{1[J

line 222: " Returns the index of the child node of this node that has the given path or[J

line 223: " -1 if no such node exists.[J

line 224: "[J

line 225: " This function doesnt not recurse into child dir nodes[J

line 226: "[J

line 227: " Args:[J

line 228: " path: a path object[J

line 229: function! s:TreeDirNode.getChildIndex(path)[J

line 251: [J

line 252: " FUNCTION: TreeDirNode.getDirChildren() {{{1[J

line 253: " Return a list of all child nodes from 'self.children' that are of type[J

line 254: " TreeDirNode. This function supports http://github.com/scrooloose/nerdtree-project-plugin.git.[J

line 255: function! s:TreeDirNode.getDirChildren()[J

line 258: [J

line 259: " FUNCTION: TreeDirNode._glob(pattern, all) {{{1[J

line 260: " Return a list of strings naming the descendants of the directory in this[J

line 261: " TreeDirNode object that match the specified glob pattern.[J

line 262: "[J

line 263: " Args:[J

line 264: " pattern: (string) the glob pattern to apply[J

line 265: " all: (0 or 1) if 1, include '.' and '..' if they match 'pattern'; if 0,[J

line 266: "      always exclude them[J

line 267: "[J

line 268: " Note: If the pathnames in the result list are below the working directory,[J

line 269: " they are returned as pathnames relative to that directory. This is because[J

line 270: " this function, internally, attempts to obey 'wildignore' rules that use[J

line 271: " relative paths.[J

line 272: function! s:TreeDirNode._glob(pattern, all)[J

line 332: [J

line 333: " FUNCTION: TreeDirNode.GetSelected() {{{1[J

line 334: " Returns the current node if it is a dir node, or else returns the current[J

line 335: " nodes parent[J

line 336: unlet s:TreeDirNode.GetSelected[J

line 337: function! s:TreeDirNode.GetSelected()[J

line 346: [J

line 347: " FUNCTION: TreeDirNode.getVisibleChildCount() {{{1[J

line 348: " Returns the number of visible children this node has[J

line 349: function! s:TreeDirNode.getVisibleChildCount()[J

line 352: [J

line 353: " FUNCTION: TreeDirNode.getVisibleChildren() {{{1[J

line 354: " Returns a list of children to display for this node, in the correct order[J

line 355: "[J

line 356: " Return:[J

line 357: " an array of treenodes[J

line 358: function! s:TreeDirNode.getVisibleChildren()[J

line 367: [J

line 368: " FUNCTION: TreeDirNode.hasVisibleChildren() {{{1[J

line 369: " returns 1 if this node has any childre, 0 otherwise..[J

line 370: function! s:TreeDirNode.hasVisibleChildren()[J

line 373: [J

line 374: " FUNCTION: TreeDirNode.isCascadable() {{{1[J

line 375: " true if this dir has only one visible child that is also a dir[J

line 376: " false if this dir is bookmarked or symlinked. Why? Two reasons:[J

line 377: "  1. If cascaded, we don't know which dir is bookmarked or is a symlink.[J

line 378: "  2. If the parent is a symlink or is bookmarked, you end up with unparsable[J

line 379: "     text, and NERDTree cannot get the path of any child node.[J

line 380: " Also, return false if this directory is the tree root, which should never be[J

line 381: " part of a cascade.[J

line 382: function! s:TreeDirNode.isCascadable()[J

line 404: [J

line 405: " FUNCTION: TreeDirNode._initChildren() {{{1[J

line 406: " Removes all childen from this node and re-reads them[J

line 407: "[J

line 408: " Args:[J

line 409: " silent: 1 if the function should not echo any 'please wait' messages for[J

line 410: " large directories[J

line 411: "[J

line 412: " Return: the number of child nodes read[J

line 413: function! s:TreeDirNode._initChildren(silent)[J

line 444: [J

line 445: " FUNCTION: TreeDirNode.New(path, nerdtree) {{{1[J

line 446: " Return a new TreeDirNode object with the given path and parent.[J

line 447: "[J

line 448: " Args:[J

line 449: " path: dir that the node represents[J

line 450: " nerdtree: the tree the node belongs to[J

line 451: function! s:TreeDirNode.New(path, nerdtree)[J

line 467: [J

line 468: " FUNCTION: TreeDirNode.open([options]) {{{1[J

line 469: " Open this directory node in the current tree or elsewhere if special options[J

line 470: " are provided. Return 0 if options were processed. Otherwise, return the[J

line 471: " number of new cached nodes.[J

line 472: function! s:TreeDirNode.open(...)[J

line 502: [J

line 503: " FUNCTION: TreeDirNode.openAlong([opts]) {{{1[J

line 504: " recursive open the dir if it has only one directory child.[J

line 505: "[J

line 506: " return the level of opened directories.[J

line 507: function! s:TreeDirNode.openAlong(...)[J

line 523: [J

line 524: " FUNCTION: TreeDirNode.openExplorer() {{{1[J

line 525: " Open an explorer window for this node in the previous window. The explorer[J

line 526: " can be a NERDTree window or a netrw window.[J

line 527: function! s:TreeDirNode.openExplorer()[J

line 531: [J

line 532: " FUNCTION: TreeDirNode.openInNewTab(options) {{{1[J

line 533: unlet s:TreeDirNode.openInNewTab[J

line 534: function! s:TreeDirNode.openInNewTab(options)[J

line 538: [J

line 539: " FUNCTION: TreeDirNode._openInNewTab() {{{1[J

line 540: function! s:TreeDirNode._openInNewTab()[J

line 544: [J

line 545: " FUNCTION: TreeDirNode.openRecursively() {{{1[J

line 546: " Open this directory node and any descendant directory nodes whose pathnames[J

line 547: " are not ignored.[J

line 548: function! s:TreeDirNode.openRecursively()[J

line 557: [J

line 558: " FUNCTION: TreeDirNode.refresh() {{{1[J

line 559: function! s:TreeDirNode.refresh()[J

line 596: [J

line 597: " FUNCTION: TreeDirNode.refreshFlags() {{{1[J

line 598: unlet s:TreeDirNode.refreshFlags[J

line 599: function! s:TreeDirNode.refreshFlags()[J

line 605: [J

line 606: " FUNCTION: TreeDirNode.refreshDirFlags() {{{1[J

line 607: function! s:TreeDirNode.refreshDirFlags()[J

line 610: [J

line 611: " FUNCTION: TreeDirNode.reveal(path) {{{1[J

line 612: " reveal the given path, i.e. cache and open all treenodes needed to display it[J

line 613: " in the UI[J

line 614: " Returns the revealed node[J

line 615: function! s:TreeDirNode.reveal(path, ...)[J

line 645: [J

line 646: " FUNCTION: TreeDirNode.removeChild(treenode) {{{1[J

line 647: " Remove the given treenode from self.children.[J

line 648: " Throws NERDTree.ChildNotFoundError if the node is not found.[J

line 649: "[J

line 650: " Args:[J

line 651: " treenode: the node object to remove[J

line 652: function! s:TreeDirNode.removeChild(treenode)[J

line 662: [J

line 663: " FUNCTION: TreeDirNode.sortChildren() {{{1[J

line 664: " Sort self.children by alphabetical order and directory priority.[J

line 665: function! s:TreeDirNode.sortChildren()[J

line 673: [J

line 674: " FUNCTION: TreeDirNode.toggleOpen([options]) {{{1[J

line 675: " Opens this directory if it is closed and vice versa[J

line 676: function! s:TreeDirNode.toggleOpen(...)[J

line 688: [J

line 689: " FUNCTION: TreeDirNode.transplantChild(newNode) {{{1[J

line 690: " Replaces the child of this with the given node (where the child node's full[J

line 691: " path matches a:newNode's fullpath). The search for the matching node is[J

line 692: " non-recursive[J

line 693: "[J

line 694: " Arg:[J

line 695: " newNode: the node to graft into the tree[J

line 696: function! s:TreeDirNode.transplantChild(newNode)[J

line 705: [J

line 706: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim[J
continuing in nerdtree#loadClassFiles[J
line 8:     runtime lib/nerdtree/opener.vim[J

Searching for "lib/nerdtree/opener.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/lib/nerdtree/opener.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/lib/nerdtree/opener.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/opener.vim"[J
chdir(/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 8: sourcing "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/opener.vim"[J
line 1: " ============================================================================[J

line 2: " CLASS: Opener[J

line 3: "[J

line 4: " The Opener class defines an API for 'opening' operations.[J

line 5: " ============================================================================[J

line 6: [J

line 7: [J

line 8: let s:Opener = {}[J

line 9: let g:NERDTreeOpener = s:Opener[J

line 10: [J

line 11: " FUNCTION: s:Opener._bufInWindows(bnum) {{{1[J

line 12: " [[STOLEN FROM VTREEEXPLORER.VIM]][J

line 13: " Determine the number of windows open to this buffer number.[J

line 14: " Care of Yegappan Lakshman.  Thanks![J

line 15: "[J

line 16: " Args:[J

line 17: " bnum: the subject buffers buffer number[J

line 18: function! s:Opener._bufInWindows(bnum)[J

line 34: [J

line 35: " FUNCTION: Opener._checkToCloseTree(newtab) {{{1[J

line 36: " Check the class options to see if the tree should be closed now.[J

line 37: "[J

line 38: " Args:[J

line 39: " a:newtab - boolean. If set, only close the tree now if we are opening the[J

line 40: " target in a new tab. This is needed because we have to close tree before we[J

line 41: " leave the tab[J

line 42: function! s:Opener._checkToCloseTree(newtab)[J

line 51: [J

line 52: " FUNCTION: s:Opener._firstUsableWindow() {{{1[J

line 53: " find the window number of the first normal window[J

line 54: function! s:Opener._firstUsableWindow()[J

line 68: [J

line 69: " FUNCTION: Opener._gotoTargetWin() {{{1[J

line 70: function! s:Opener._gotoTargetWin()[J

line 95: [J

line 96: " FUNCTION: s:Opener._isWindowUsable(winnumber) {{{1[J

line 97: " Returns 0 if opening a file from the tree in the given window requires it to[J

line 98: " be split, 1 otherwise[J

line 99: "[J

line 100: " Args:[J

line 101: " winnumber: the number of the window in question[J

line 102: function! s:Opener._isWindowUsable(winnumber)[J

line 126: [J

line 127: " FUNCTION: Opener.New(path, opts) {{{1[J

line 128: " Instantiate a new NERDTreeOpener object.[J

line 129: " Args:[J

line 130: " a:path: the path object that is to be opened[J

line 131: " a:opts: a dictionary containing the following optional keys...[J

line 132: "   'where': specifies whether the node should be opened in new split, in[J

line 133: "            a new tab or, in the last window; takes values 'v', 'h', or 't'[J

line 134: "   'reuse': if file is already shown in a window, jump there; takes values[J

line 135: "            'all', 'currenttab', or empty[J

line 136: "   'keepopen': boolean (0 or 1); if true, the tree window will not be closed[J

line 137: "   'stay': boolean (0 or 1); if true, remain in tree window after opening[J

line 138: function! s:Opener.New(path, opts)[J

line 152: [J

line 153: " FUNCTION: Opener._newSplit() {{{1[J

line 154: function! s:Opener._newSplit()[J

line 183: [J

line 184: " FUNCTION: Opener._newVSplit() {{{1[J

line 185: function! s:Opener._newVSplit()[J

line 207: [J

line 208: " FUNCTION: Opener.open(target) {{{1[J

line 209: function! s:Opener.open(target)[J

line 217: [J

line 218: " FUNCTION: Opener._openFile() {{{1[J

line 219: function! s:Opener._openFile()[J

line 238: [J

line 239: " FUNCTION: Opener._openDirectory(node) {{{1[J

line 240: function! s:Opener._openDirectory(node)[J

line 259: [J

line 260: " FUNCTION: Opener._previousWindow() {{{1[J

line 261: function! s:Opener._previousWindow()[J

line 279: [J

line 280: " FUNCTION: Opener._restoreCursorPos() {{{1[J

line 281: function! s:Opener._restoreCursorPos()[J

line 285: [J

line 286: " FUNCTION: Opener._reuseWindow() {{{1[J

line 287: " put the cursor in the first window we find for this file[J

line 288: "[J

line 289: " return 1 if we were successful[J

line 290: function! s:Opener._reuseWindow()[J

line 319: [J

line 320: " FUNCTION: Opener._saveCursorPos() {{{1[J

line 321: function! s:Opener._saveCursorPos()[J

line 325: [J

line 326: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/opener.vim[J
continuing in nerdtree#loadClassFiles[J
line 9:     runtime lib/nerdtree/creator.vim[J

Searching for "lib/nerdtree/creator.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/lib/nerdtree/creator.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/lib/nerdtree/creator.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/creator.vim"[J
chdir(/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 9: sourcing "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/creator.vim"[J
line 1: " ============================================================================[J

line 2: " CLASS: Creator[J

line 3: "[J

line 4: " This class is responsible for creating NERDTree instances.  The new NERDTree[J

line 5: " may be a tab tree, a window tree, or a mirrored tree.  In the process of[J

line 6: " creating a NERDTree, it sets up all of the window and buffer options and key[J

line 7: " mappings etc.[J

line 8: " ============================================================================[J

line 9: [J

line 10: [J

line 11: let s:Creator = {}[J

line 12: let g:NERDTreeCreator = s:Creator[J

line 13: [J

line 14: " FUNCTION: s:Creator._bindMappings() {{{1[J

line 15: function! s:Creator._bindMappings()[J

line 28: [J

line 29: " FUNCTION: s:Creator._broadcastInitEvent() {{{1[J

line 30: function! s:Creator._broadcastInitEvent()[J

line 35: [J

line 36: " FUNCTION: s:Creator.BufNamePrefix() {{{1[J

line 37: function! s:Creator.BufNamePrefix()[J

line 40: [J

line 41: " FUNCTION: s:Creator.CreateTabTree(a:name) {{{1[J

line 42: function! s:Creator.CreateTabTree(name)[J

line 46: [J

line 47: " FUNCTION: s:Creator.createTabTree(a:name) {{{1[J

line 48: " name: the name of a bookmark or a directory[J

line 49: function! s:Creator.createTabTree(name)[J

line 75: [J

line 76: " FUNCTION: s:Creator.CreateWindowTree(dir) {{{1[J

line 77: function! s:Creator.CreateWindowTree(dir)[J

line 81: [J

line 82: " FUNCTION: s:Creator.createWindowTree(dir) {{{1[J

line 83: function! s:Creator.createWindowTree(dir)[J

line 108: [J

line 109: " FUNCTION: s:Creator._createNERDTree(path) {{{1[J

line 110: function! s:Creator._createNERDTree(path, type)[J

line 120: [J

line 121: " FUNCTION: s:Creator.CreateMirror() {{{1[J

line 122: function! s:Creator.CreateMirror()[J

line 126: [J

line 127: " FUNCTION: s:Creator.createMirror() {{{1[J

line 128: function! s:Creator.createMirror()[J

line 180: [J

line 181: " FUNCTION: s:Creator._createTreeWin() {{{1[J

line 182: " Initialize the NERDTree window.  Open the window, size it properly, set all[J

line 183: " local options, etc.[J

line 184: function! s:Creator._createTreeWin()[J

line 207: [J

line 208: " FUNCTION: s:Creator._isBufHidden(nr) {{{1[J

line 209: function! s:Creator._isBufHidden(nr)[J

line 216: [J

line 217: " FUNCTION: s:Creator.New() {{{1[J

line 218: function! s:Creator.New()[J

line 222: [J

line 223: " FUNCTION: s:Creator._nextBufferName() {{{1[J

line 224: " returns the buffer name for the next nerd tree[J

line 225: function! s:Creator._nextBufferName()[J

line 229: [J

line 230: " FUNCTION: s:Creator._nextBufferNumber() {{{1[J

line 231: " the number to add to the nerd tree buffer name to make the buf name unique[J

line 232: function! s:Creator._nextBufferNumber()[J

line 241: [J

line 242: " FUNCTION: s:Creator._pathForString(str) {{{1[J

line 243: " find a bookmark or adirectory for the given string[J

line 244: function! s:Creator._pathForString(str)[J

line 274: [J

line 275: " Function: s:Creator._removeTreeBufForTab()   {{{1[J

line 276: function! s:Creator._removeTreeBufForTab()[J

line 291: [J

line 292: " FUNCTION: s:Creator._setCommonBufOptions() {{{1[J

line 293: function! s:Creator._setCommonBufOptions()[J

line 329: [J

line 330: " FUNCTION: s:Creator._setupStatusline() {{{1[J

line 331: function! s:Creator._setupStatusline()[J

line 336: [J

line 337: " FUNCTION: s:Creator._tabpagevar(tabnr, var) {{{1[J

line 338: function! s:Creator._tabpagevar(tabnr, var)[J

line 357: [J

line 358: " FUNCTION: s:Creator.ToggleTabTree(dir) {{{1[J

line 359: function! s:Creator.ToggleTabTree(dir)[J

line 363: [J

line 364: " FUNCTION: s:Creator.toggleTabTree(dir) {{{1[J

line 365: " Toggles the NERD tree. I.e if the NERD tree is open, it is closed. If it is[J

line 366: " closed, it is restored or initialized. If dir is not empty, it will be set[J

line 367: " as the new root.[J

line 368: "[J

line 369: " Args:[J

line 370: " dir: the full path for the root node (is used if the NERD tree is being[J

line 371: " initialized, or to change the root to a new dir.)[J

line 372: function! s:Creator.toggleTabTree(dir)[J

line 389: [J

line 390: " Function: s:Creator._uniq(list)   {{{1[J

line 391: " returns a:list without duplicates[J

line 392: function! s:Creator._uniq(list)[J

line 401: [J

line 402: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/creator.vim[J
continuing in nerdtree#loadClassFiles[J
line 10:     runtime lib/nerdtree/flag_set.vim[J

Searching for "lib/nerdtree/flag_set.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/lib/nerdtree/flag_set.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/lib/nerdtree/flag_set.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim"[J
chdir(/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 10: sourcing "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim"[J
line 1: "CLASS: FlagSet[J

line 2: "============================================================[J

line 3: let s:FlagSet = {}[J

line 4: let g:NERDTreeFlagSet = s:FlagSet[J

line 5: [J

line 6: "FUNCTION: FlagSet.addFlag(scope, flag) {{{1[J

line 7: function! s:FlagSet.addFlag(scope, flag)[J

line 13: [J

line 14: "FUNCTION: FlagSet.clearFlags(scope) {{{1[J

line 15: function! s:FlagSet.clearFlags(scope)[J

line 18: [J

line 19: "FUNCTION: FlagSet._flagsForScope(scope) {{{1[J

line 20: function! s:FlagSet._flagsForScope(scope)[J

line 26: [J

line 27: "FUNCTION: FlagSet.New() {{{1[J

line 28: function! s:FlagSet.New()[J

line 33: [J

line 34: "FUNCTION: FlagSet.removeFlag(scope, flag) {{{1[J

line 35: function! s:FlagSet.removeFlag(scope, flag)[J

line 43: [J

line 44: "FUNCTION: FlagSet.renderToString() {{{1[J

line 45: function! s:FlagSet.renderToString()[J

line 57: [J

line 58: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim[J
continuing in nerdtree#loadClassFiles[J
line 11:     runtime lib/nerdtree/nerdtree.vim[J

Searching for "lib/nerdtree/nerdtree.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/lib/nerdtree/nerdtree.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/lib/nerdtree/nerdtree.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim"[J
chdir(/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 11: sourcing "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim"[J
line 1: "CLASS: NERDTree[J

line 2: "============================================================[J

line 3: let s:NERDTree = {}[J

line 4: let g:NERDTree = s:NERDTree[J

line 5: [J

line 6: "FUNCTION: s:NERDTree.AddPathFilter() {{{1[J

line 7: function! s:NERDTree.AddPathFilter(callback)[J

line 10: [J

line 11: "FUNCTION: s:NERDTree.changeRoot(node) {{{1[J

line 12: function! s:NERDTree.changeRoot(node)[J

line 34: [J

line 35: "FUNCTION: s:NERDTree.Close() {{{1[J

line 36: "Closes the tab tree window for this tab[J

line 37: function! s:NERDTree.Close()[J

line 67: [J

line 68: "FUNCTION: s:NERDTree.CursorToBookmarkTable(){{{1[J

line 69: "Places the cursor at the top of the bookmarks table[J

line 70: function! s:NERDTree.CursorToBookmarkTable()[J

line 90: [J

line 91: "FUNCTION: s:NERDTree.CursorToTreeWin(){{{1[J

line 92: "Places the cursor in the nerd tree window[J

line 93: function! s:NERDTree.CursorToTreeWin(...)[J

line 97: [J

line 98: " Function: s:NERDTree.ExistsForBuffer()   {{{1[J

line 99: " Returns 1 if a nerd tree root exists in the current buffer[J

line 100: function! s:NERDTree.ExistsForBuf()[J

line 103: [J

line 104: " Function: s:NERDTree.ExistsForTab()   {{{1[J

line 105: " Returns 1 if a nerd tree root exists in the current tab[J

line 106: function! s:NERDTree.ExistsForTab()[J

line 114: [J

line 115: function! s:NERDTree.ForCurrentBuf()[J

line 122: [J

line 123: "FUNCTION: s:NERDTree.ForCurrentTab() {{{1[J

line 124: function! s:NERDTree.ForCurrentTab()[J

line 132: [J

line 133: "FUNCTION: s:NERDTree.getRoot() {{{1[J

line 134: function! s:NERDTree.getRoot()[J

line 137: [J

line 138: "FUNCTION: s:NERDTree.GetWinNum() {{{1[J

line 139: "gets the nerd tree window number for this tab[J

line 140: function! s:NERDTree.GetWinNum()[J

line 154: [J

line 155: "FUNCTION: s:NERDTree.IsOpen() {{{1[J

line 156: function! s:NERDTree.IsOpen()[J

line 159: [J

line 160: "FUNCTION: s:NERDTree.isTabTree() {{{1[J

line 161: function! s:NERDTree.isTabTree()[J

line 164: [J

line 165: "FUNCTION: s:NERDTree.isWinTree() {{{1[J

line 166: function! s:NERDTree.isWinTree()[J

line 169: [J

line 170: "FUNCTION: s:NERDTree.MustBeOpen() {{{1[J

line 171: function! s:NERDTree.MustBeOpen()[J

line 176: [J

line 177: "FUNCTION: s:NERDTree.New() {{{1[J

line 178: function! s:NERDTree.New(path, type)[J

line 185: [J

line 186: "FUNCTION: s:NERDTree.PathFilters() {{{1[J

line 187: function! s:NERDTree.PathFilters()[J

line 193: [J

line 194: "FUNCTION: s:NERDTree.previousBuf() {{{1[J

line 195: function! s:NERDTree.previousBuf()[J

line 198: [J

line 199: function! s:NERDTree.setPreviousBuf(bnum)[J

line 202: [J

line 203: "FUNCTION: s:NERDTree.render() {{{1[J

line 204: "A convenience function - since this is called often[J

line 205: function! s:NERDTree.render()[J

line 208: [J

line 209: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim[J
continuing in nerdtree#loadClassFiles[J
line 12:     runtime lib/nerdtree/ui.vim[J

Searching for "lib/nerdtree/ui.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/lib/nerdtree/ui.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/lib/nerdtree/ui.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/ui.vim"[J
chdir(/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 12: sourcing "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/ui.vim"[J
line 1: " ============================================================================[J

line 2: " CLASS: UI[J

line 3: " ============================================================================[J

line 4: [J

line 5: [J

line 6: let s:UI = {}[J

line 7: let g:NERDTreeUI = s:UI[J

line 8: [J

line 9: " FUNCTION: s:UI.centerView() {{{1[J

line 10: " centers the nerd tree window around the cursor (provided the nerd tree[J

line 11: " options permit)[J

line 12: function! s:UI.centerView()[J

line 22: [J

line 23: " FUNCTION: s:UI._dumpHelp  {{{1[J

line 24: " prints out the quick help[J

line 25: function! s:UI._dumpHelp()[J

line 139: [J

line 140: [J

line 141: " FUNCTION: s:UI.new(nerdtree) {{{1[J

line 142: function! s:UI.New(nerdtree)[J

line 153: [J

line 154: " FUNCTION: s:UI.getPath(ln) {{{1[J

line 155: " Return the Path object for the node that is rendered on the given line[J

line 156: " number.  If the 'up a dir' line is selected, return the Path object for[J

line 157: " the parent of the root.  Return the empty dictionary if the given line[J

line 158: " does not reference a tree node.[J

line 159: function! s:UI.getPath(ln)[J

line 207: [J

line 208: " FUNCTION: s:UI.getLineNum(node) {{{1[J

line 209: " Return the line number where the given node is rendered.  Return -1 if the[J

line 210: " given node is not visible.[J

line 211: function! s:UI.getLineNum(node)[J

line 256: [J

line 257: " FUNCTION: s:UI.getRootLineNum(){{{1[J

line 258: " gets the line number of the root node[J

line 259: function! s:UI.getRootLineNum()[J

line 266: [J

line 267: " FUNCTION: s:UI.getShowBookmarks() {{{1[J

line 268: function! s:UI.getShowBookmarks()[J

line 271: [J

line 272: " FUNCTION: s:UI.getShowFiles() {{{1[J

line 273: function! s:UI.getShowFiles()[J

line 276: [J

line 277: " FUNCTION: s:UI.getShowHelp() {{{1[J

line 278: function! s:UI.getShowHelp()[J

line 281: [J

line 282: " FUNCTION: s:UI.getShowHidden() {{{1[J

line 283: function! s:UI.getShowHidden()[J

line 286: [J

line 287: " FUNCTION: s:UI._indentLevelFor(line) {{{1[J

line 288: function! s:UI._indentLevelFor(line)[J

line 299: [J

line 300: " FUNCTION: s:UI.IndentWid() {{{1[J

line 301: function! s:UI.IndentWid()[J

line 304: [J

line 305: " FUNCTION: s:UI.isIgnoreFilterEnabled() {{{1[J

line 306: function! s:UI.isIgnoreFilterEnabled()[J

line 309: [J

line 310: " FUNCTION: s:UI.isMinimal() {{{1[J

line 311: function! s:UI.isMinimal()[J

line 314: [J

line 315: " FUNCTION: s:UI.MarkupReg() {{{1[J

line 316: function! s:UI.MarkupReg()[J

line 319: [J

line 320: " FUNCTION: s:UI._renderBookmarks {{{1[J

line 321: function! s:UI._renderBookmarks()[J

line 340: [J

line 341: " FUNCTION: s:UI.restoreScreenState() {{{1[J

line 342: "[J

line 343: " Sets the screen state back to what it was when nerdtree#saveScreenState was last[J

line 344: " called.[J

line 345: "[J

line 346: " Assumes the cursor is in the NERDTree window[J

line 347: function! s:UI.restoreScreenState()[J

line 360: [J

line 361: " FUNCTION: s:UI.saveScreenState() {{{1[J

line 362: " Saves the current cursor position in the current buffer and the window[J

line 363: " scroll position[J

line 364: function! s:UI.saveScreenState()[J

line 376: [J

line 377: " FUNCTION: s:UI.setShowHidden(val) {{{1[J

line 378: function! s:UI.setShowHidden(val)[J

line 381: [J

line 382: " FUNCTION: s:UI._stripMarkup(line){{{1[J

line 383: " find the filename in the given line, and return it.[J

line 384: "[J

line 385: " Args:[J

line 386: " line: the subject line[J

line 387: function! s:UI._stripMarkup(line)[J

line 391: [J

line 392: " FUNCTION: s:UI.render() {{{1[J

line 393: function! s:UI.render()[J

line 444: [J

line 445: [J

line 446: " FUNCTION: UI.renderViewSavingPosition {{{1[J

line 447: " Renders the tree and ensures the cursor stays on the current node or the[J

line 448: " current nodes parent if it is no longer available upon re-rendering[J

line 449: function! s:UI.renderViewSavingPosition()[J

line 464: [J

line 465: " FUNCTION: s:UI.toggleHelp() {{{1[J

line 466: function! s:UI.toggleHelp()[J

line 469: [J

line 470: " FUNCTION: s:UI.toggleIgnoreFilter() {{{1[J

line 471: " toggles the use of the NERDTreeIgnore option[J

line 472: function! s:UI.toggleIgnoreFilter()[J

line 477: [J

line 478: " FUNCTION: s:UI.toggleShowBookmarks() {{{1[J

line 479: " Toggle the visibility of the Bookmark table.[J

line 480: function! s:UI.toggleShowBookmarks()[J

line 498: [J

line 499: " FUNCTION: s:UI.toggleShowFiles() {{{1[J

line 500: " toggles the display of hidden files[J

line 501: function! s:UI.toggleShowFiles()[J

line 506: [J

line 507: " FUNCTION: s:UI.toggleShowHidden() {{{1[J

line 508: " toggles the display of hidden files[J

line 509: function! s:UI.toggleShowHidden()[J

line 514: [J

line 515: " FUNCTION: s:UI.toggleZoom() {{{1[J

line 516: " zoom (maximize/minimize) the NERDTree window[J

line 517: function! s:UI.toggleZoom()[J

line 526: [J

line 527: " FUNCTION: s:UI.UpDirLine() {{{1[J

line 528: function! s:UI.UpDirLine()[J

line 531: [J

line 532: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/ui.vim[J
continuing in nerdtree#loadClassFiles[J
line 13:     runtime lib/nerdtree/event.vim[J

Searching for "lib/nerdtree/event.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/lib/nerdtree/event.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/lib/nerdtree/event.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/event.vim"[J
chdir(/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 13: sourcing "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/event.vim"[J
line 1: "CLASS: Event[J

line 2: "============================================================[J

line 3: let s:Event = {}[J

line 4: let g:NERDTreeEvent = s:Event[J

line 5: [J

line 6: function! s:Event.New(nerdtree, subject, action, params) abort[J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/event.vim[J
continuing in nerdtree#loadClassFiles[J
line 14:     runtime lib/nerdtree/notifier.vim[J

Searching for "lib/nerdtree/notifier.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/lib/nerdtree/notifier.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/lib/nerdtree/notifier.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim"[J
chdir(/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree)[J
fchdir() to previous dir[J
line 14: sourcing "/Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim"[J
line 1: "CLASS: Notifier[J

line 2: "============================================================[J

line 3: let s:Notifier = {}[J

line 4: [J

line 5: function! s:Notifier.AddListener(event, funcname)[J

line 13: [J

line 14: function! s:Notifier.NotifyListeners(event, path, nerdtree, params)[J

line 22: [J

line 23: function! s:Notifier.GetListenersMap()[J

line 29: [J

line 30: function! s:Notifier.GetListenersForEvent(name)[J

line 34: [J

line 35: let g:NERDTreePathNotifier = deepcopy(s:Notifier)[J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim[J
continuing in nerdtree#loadClassFiles[J
nerdtree#loadClassFiles returning #0[J

continuing in /Users/tsen/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 140: [J

line 141: " SECTION: Commands {{{1[J

line 142: "============================================================[J

line 143: call nerdtree#ui_glue#setupCommands()[J

Searching for "autoload/nerdtree/ui_glue.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/autoload/nerdtree/ui_glue.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/autoload/nerdtree/ui_glue.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim"[J
chdir(/Users/tsen/.vim/bundle/nerdtree/autoload/nerdtree)[J
fchdir() to previous dir[J
line 143: sourcing "/Users/tsen/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim"[J
line 1: if exists('g:loaded_nerdtree_ui_glue_autoload')[J

line 2:     finish[J

line 3: endif[J

line 4: let g:loaded_nerdtree_ui_glue_autoload = 1[J

line 5: [J

line 6: " FUNCTION: nerdtree#ui_glue#createDefaultBindings() {{{1[J

line 7: function! nerdtree#ui_glue#createDefaultBindings() abort[J

line 83: [J

line 84: [J

line 85: "SECTION: Interface bindings {{{1[J

line 86: "============================================================[J

line 87: [J

line 88: "FUNCTION: s:customOpenFile() {{{1[J

line 89: " Open file node with the 'custom' key, initially <CR>.[J

line 90: function! s:customOpenFile(node) abort[J

line 93: [J

line 94: "FUNCTION: s:customOpenDir() {{{1[J

line 95: " Open directory node with the 'custom' key, initially <CR>.[J

line 96: function! s:customOpenDir(node) abort[J

line 99: [J

line 100: "FUNCTION: s:customOpenBookmark() {{{1[J

line 101: " Open bookmark node with the 'custom' key, initially <CR>.[J

line 102: function! s:customOpenBookmark(node) abort[J

line 109: [J

line 110: "FUNCTION: s:initCustomOpenArgs() {{{1[J

line 111: function! s:initCustomOpenArgs() abort[J

line 123: [J

line 124: "FUNCTION: s:activateAll() {{{1[J

line 125: "handle the user activating the updir line[J

line 126: function! s:activateAll() abort[J

line 131: [J

line 132: " FUNCTION: s:activateDirNode(directoryNode, options) {{{1[J

line 133: " Open a directory with optional options[J

line 134: function! s:activateDirNode(directoryNode, ...) abort[J

line 143: [J

line 144: "FUNCTION: s:activateFileNode() {{{1[J

line 145: "handle the user activating a tree node[J

line 146: function! s:activateFileNode(node) abort[J

line 149: [J

line 150: "FUNCTION: s:activateBookmark(bookmark) {{{1[J

line 151: "handle the user activating a bookmark[J

line 152: function! s:activateBookmark(bm) abort[J

line 155: [J

line 156: " FUNCTION: nerdtree#ui_glue#bookmarkNode(name) {{{1[J

line 157: " Associate the current node with the given name[J

line 158: function! nerdtree#ui_glue#bookmarkNode(...) abort[J

line 175: [J

line 176: " FUNCTION: s:chCwd(node) {{{1[J

line 177: function! s:chCwd(node) abort[J

line 184: [J

line 185: " FUNCTION: s:chRoot(node) {{{1[J

line 186: " changes the current root to the selected one[J

line 187: function! s:chRoot(node) abort[J

line 190: [J

line 191: " FUNCTION: s:nerdtree#ui_glue#chRootCwd() {{{1[J

line 192: " Change the NERDTree root to match the current working directory.[J

line 193: function! nerdtree#ui_glue#chRootCwd() abort[J

line 196: [J

line 197: " FUNCTION: nnerdtree#ui_glue#clearBookmarks(bookmarks) {{{1[J

line 198: function! nerdtree#ui_glue#clearBookmarks(bookmarks) abort[J

line 213: [J

line 214: " FUNCTION: s:closeChildren(node) {{{1[J

line 215: " closes all childnodes of the current node[J

line 216: function! s:closeChildren(node) abort[J

line 221: [J

line 222: " FUNCTION: s:closeCurrentDir(node) {{{1[J

line 223: " Close the parent directory of the current node.[J

line 224: function! s:closeCurrentDir(node) abort[J

line 246: [J

line 247: " FUNCTION: s:closeTreeWindow() {{{1[J

line 248: " close the tree window[J

line 249: function! s:closeTreeWindow() abort[J

line 260: [J

line 261: " FUNCTION: s:deleteBookmark(bookmark) {{{1[J

line 262: " Prompt the user to confirm the deletion of the selected bookmark.[J

line 263: function! s:deleteBookmark(bookmark) abort[J

line 286: [J

line 287: " FUNCTION: s:displayHelp() {{{1[J

line 288: " toggles the help display[J

line 289: function! s:displayHelp() abort[J

line 294: [J

line 295: " FUNCTION: s:findAndRevealPath(pathStr) {{{1[J

line 296: function! s:findAndRevealPath(pathStr) abort[J

line 347: [J

line 348: "FUNCTION: s:handleLeftClick() {{{1[J

line 349: "Checks if the click should open the current node[J

line 350: function! s:handleLeftClick() abort[J

line 383: [J

line 384: " FUNCTION: s:handleMiddleMouse() {{{1[J

line 385: function! s:handleMiddleMouse() abort[J

line 404: [J

line 405: " FUNCTION: nerdtree#ui_glue#invokeKeyMap(key) {{{1[J

line 406: "this is needed since I cant figure out how to invoke dict functions from a[J

line 407: "key map[J

line 408: function! nerdtree#ui_glue#invokeKeyMap(key) abort[J

line 411: [J

line 412: " FUNCTION: s:jumpToFirstChild(node) {{{1[J

line 413: function! s:jumpToFirstChild(node) abort[J

line 416: [J

line 417: " FUNCTION: s:jumpToLastChild(node) {{{1[J

line 418: function! s:jumpToLastChild(node) abort[J

line 421: [J

line 422: " FUNCTION: s:jumpToChild(node, last) {{{1[J

line 423: " Jump to the first or last child node at the same file system level.[J

line 424: "[J

line 425: " Args:[J

line 426: " node: the node on which the cursor currently sits[J

line 427: " last: 1 (true) if jumping to last child, 0 (false) if jumping to first[J

line 428: function! s:jumpToChild(node, last) abort[J

line 443: [J

line 444: " FUNCTION: s:jumpToParent(node) {{{1[J

line 445: " Move the cursor to the parent of the specified node.  For a cascade, move to[J

line 446: " the parent of the cascade's first node.  At the root node, do nothing.[J

line 447: function! s:jumpToParent(node) abort[J

line 462: [J

line 463: " FUNCTION: s:jumpToRoot() {{{1[J

line 464: " moves the cursor to the root node[J

line 465: function! s:jumpToRoot() abort[J

line 469: [J

line 470: " FUNCTION: s:jumpToNextSibling(node) {{{1[J

line 471: function! s:jumpToNextSibling(node) abort[J

line 474: [J

line 475: " FUNCTION: s:jumpToPrevSibling(node) {{{1[J

line 476: function! s:jumpToPrevSibling(node) abort[J

line 479: [J

line 480: " FUNCTION: s:jumpToSibling(node, forward) {{{1[J

line 481: " Move the cursor to the next or previous node at the same file system level.[J

line 482: "[J

line 483: " Args:[J

line 484: " node: the node on which the cursor currently sits[J

line 485: " forward: 0 to jump to previous sibling, 1 to jump to next sibling[J

line 486: function! s:jumpToSibling(node, forward) abort[J

line 497: [J

line 498: " FUNCTION: nerdtree#ui_glue#openBookmark(name) {{{1[J

line 499: " Open the Bookmark that has the specified name. This function provides the[J

line 500: " implementation for the :OpenBookmark command.[J

line 501: function! nerdtree#ui_glue#openBookmark(name) abort[J

line 515: [J

line 516: " FUNCTION: s:openHSplit(target) {{{1[J

line 517: function! s:openHSplit(target) abort[J

line 520: [J

line 521: " FUNCTION: s:openVSplit(target) {{{1[J

line 522: function! s:openVSplit(target) abort[J

line 525: [J

line 526: "FUNCTION: s:openHSplitBookmark(bookmark) {{{1[J

line 527: "handle the user activating a bookmark[J

line 528: function! s:openHSplitBookmark(bm) abort[J

line 531: [J

line 532: "FUNCTION: s:openVSplitBookmark(bookmark) {{{1[J

line 533: "handle the user activating a bookmark[J

line 534: function! s:openVSplitBookmark(bm) abort[J

line 537: [J

line 538: " FUNCTION: s:previewHSplitBookmark(bookmark) {{{1[J

line 539: function! s:previewNodeHSplitBookmark(bookmark) abort[J

line 542: [J

line 543: " FUNCTION: s:previewVSplitBookmark(bookmark) {{{1[J

line 544: function! s:previewNodeVSplitBookmark(bookmark) abort[J

line 547: [J

line 548: " FUNCTION: s:openExplorer(node) {{{1[J

line 549: function! s:openExplorer(node) abort[J

line 552: [J

line 553: " FUNCTION: s:openInNewTab(target) {{{1[J

line 554: function! s:openInNewTab(target) abort[J

line 558: [J

line 559: " FUNCTION: s:openInNewTabSilent(target) {{{1[J

line 560: function! s:openInNewTabSilent(target) abort[J

line 564: [J

line 565: " FUNCTION: s:openNodeRecursively(node) {{{1[J

line 566: function! s:openNodeRecursively(node) abort[J

line 572: [J

line 573: " FUNCTION: s:previewBookmark(bookmark) {{{1[J

line 574: function! s:previewBookmark(bookmark) abort[J

line 581: [J

line 582: "FUNCTION: s:previewNodeCurrent(node) {{{1[J

line 583: function! s:previewNodeCurrent(node) abort[J

line 586: [J

line 587: "FUNCTION: s:previewNodeHSplit(node) {{{1[J

line 588: function! s:previewNodeHSplit(node) abort[J

line 591: [J

line 592: "FUNCTION: s:previewNodeVSplit(node) {{{1[J

line 593: function! s:previewNodeVSplit(node) abort[J

line 596: [J

line 597: " FUNCTION: nerdtree#ui_glue#revealBookmark(name) {{{1[J

line 598: " put the cursor on the node associate with the given name[J

line 599: function! nerdtree#ui_glue#revealBookmark(name) abort[J

line 607: [J

line 608: " FUNCTION: s:refreshRoot() {{{1[J

line 609: " Reloads the current root. All nodes below this will be lost and the root dir[J

line 610: " will be reloaded.[J

line 611: function! s:refreshRoot() abort[J

line 625: [J

line 626: " FUNCTION: s:refreshCurrent(node) {{{1[J

line 627: " refreshes the root for the current node[J

line 628: function! s:refreshCurrent(node) abort[J

line 639: [J

line 640: " FUNCTION: nerdtree#ui_glue#setupCommands() {{{1[J

line 641: function! nerdtree#ui_glue#setupCommands() abort[J

line 652: [J

line 653: " Function: s:SID()   {{{1[J

line 654: function! s:SID() abort[J

line 660: [J

line 661: " FUNCTION: s:showMenu(node) {{{1[J

line 662: function! s:showMenu(node) abort[J

line 666: [J

line 667: " FUNCTION: s:toggleIgnoreFilter() {{{1[J

line 668: function! s:toggleIgnoreFilter() abort[J

line 671: [J

line 672: " FUNCTION: s:toggleShowBookmarks() {{{1[J

line 673: function! s:toggleShowBookmarks() abort[J

line 676: [J

line 677: " FUNCTION: s:toggleShowFiles() {{{1[J

line 678: function! s:toggleShowFiles() abort[J

line 681: [J

line 682: " FUNCTION: s:toggleShowHidden() {{{1[J

line 683: " toggles the display of hidden files[J

line 684: function! s:toggleShowHidden() abort[J

line 687: [J

line 688: " FUNCTION: s:toggleZoom() {{{1[J

line 689: function! s:toggleZoom() abort[J

line 692: [J

line 693: " FUNCTION: nerdtree#ui_glue#upDir(preserveState) {{{1[J

line 694: " Move the NERDTree up one level.[J

line 695: "[J

line 696: " Args:[J

line 697: " preserveState: if 1, the current root is left open when the new tree is[J

line 698: " rendered; if 0, the current root node is closed[J

line 699: function! nerdtree#ui_glue#upDir(preserveState) abort[J

line 721: [J

line 722: " FUNCTION: s:upDirCurrentRootOpen() {{{1[J

line 723: function! s:upDirCurrentRootOpen() abort[J

line 726: [J

line 727: " FUNCTION: s:upDirCurrentRootClosed() {{{1[J

line 728: function! s:upDirCurrentRootClosed() abort[J

line 731: [J

line 732: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim[J
continuing in /Users/tsen/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J
calling nerdtree#ui_glue#setupCommands[J()

line 1:     command! -n=? -complete=dir -bar NERDTree :call g:NERDTreeCreator.CreateTabTree('<args>')[J

line 2:     command! -n=? -complete=dir -bar NERDTreeToggle :call g:NERDTreeCreator.ToggleTabTree('<args>')[J

line 3:     command! -n=0 -bar NERDTreeClose :call g:NERDTree.Close()[J

line 4:     command! -n=1 -complete=customlist,nerdtree#completeBookmarks -bar NERDTreeFromBookmark call g:NERDTreeCreator.CreateTabTree('<args>')[J

line 5:     command! -n=0 -bar NERDTreeMirror call g:NERDTreeCreator.CreateMirror()[J

line 6:     command! -n=? -complete=file -bar NERDTreeFind call s:findAndRevealPath('<args>')[J

line 7:     command! -n=0 -bar NERDTreeRefreshRoot call s:refreshRoot()[J

line 8:     command! -n=0 -bar NERDTreeFocus call NERDTreeFocus()[J

line 9:     command! -n=0 -bar NERDTreeCWD call NERDTreeCWD()[J

nerdtree#ui_glue#setupCommands returning #0[J

continuing in /Users/tsen/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 144: [J

line 145: " SECTION: Auto commands {{{1[J

line 146: "============================================================[J

line 147: augroup NERDTree[J

line 148:     "Save the cursor position whenever we close the nerd tree[J

line 149:     exec 'autocmd BufLeave,WinLeave '. g:NERDTreeCreator.BufNamePrefix() .'* if g:NERDTree.IsOpen() | call b:NERDTree.ui.saveScreenState() | endif'[J

calling 188[J()

line 1:     return 'NERD_tree_'[J

188 returning 'NERD_tree_'[J

continuing in /Users/tsen/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 149: autocmd BufLeave,WinLeave NERD_tree_* if g:NERDTree.IsOpen() | call b:NERDTree.ui.saveScreenState() | endif[J

line 150: [J

line 151:     "disallow insert mode in the NERDTree[J

line 152:     exec 'autocmd BufEnter,WinEnter '. g:NERDTreeCreator.BufNamePrefix() .'* stopinsert'[J

calling 188[J()

line 1:     return 'NERD_tree_'[J

188 returning 'NERD_tree_'[J

continuing in /Users/tsen/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 152: autocmd BufEnter,WinEnter NERD_tree_* stopinsert[J

line 153: augroup END[J

line 154: [J

line 155: if g:NERDTreeHijackNetrw[J

line 156:     augroup NERDTreeHijackNetrw[J

line 157:         autocmd VimEnter * silent! autocmd! FileExplorer[J

line 158:         au BufEnter,VimEnter * call nerdtree#checkForBrowse(expand('<amatch>'))[J

line 159:     augroup END[J

line 160: endif[J

line 161: [J

line 162: if g:NERDTreeChDirMode ==# 3[J

line 163:     augroup NERDTreeChDirOnTabSwitch[J

line 164:         autocmd TabEnter * if g:NERDTree.ExistsForTab()|call g:NERDTree.ForCurrentTab().getRoot().path.changeToDir()|endif[J

line 165:     augroup END[J

line 166: endif[J

line 167: [J

line 168: " SECTION: Public API {{{1[J

line 169: "============================================================[J

line 170: function! NERDTreeAddMenuItem(options)[J

line 173: [J

line 174: function! NERDTreeAddMenuSeparator(...)[J

line 178: [J

line 179: function! NERDTreeAddSubmenu(options)[J

line 182: [J

line 183: function! NERDTreeAddKeyMap(options)[J

line 186: [J

line 187: function! NERDTreeRender()[J

line 190: [J

line 191: function! NERDTreeFocus()[J

line 198: [J

line 199: function! NERDTreeCWD()[J

line 223: [J

line 224: function! NERDTreeAddPathFilter(callback)[J

line 227: [J

line 228: " SECTION: Post Source Actions {{{1[J

line 229: call nerdtree#postSourceActions()[J

calling nerdtree#postSourceActions[J()

line 1:     call g:NERDTreeBookmark.CacheBookmarks(1)[J

calling 87[J(1)

line 1:     if filereadable(g:NERDTreeBookmarksFile)[J

line 2:         let g:NERDTreeBookmarks = [][J

line 3:         let g:NERDTreeInvalidBookmarks = [][J

line 4:         let bookmarkStrings = readfile(g:NERDTreeBookmarksFile)[J

line 5:         let invalidBookmarksFound = 0[J

line 6:         for i in bookmarkStrings[J

line 7: [J

line 8:             "ignore blank lines[J

line 9:             if i !=# ''[J

line 10: [J

line 11:                 let name = substitute(i, '^\(.\{-}\) .*$', '\1', '')[J

line 12:                 let path = substitute(i, '^.\{-} \(.*\)$', '\1', '')[J

line 13:                 let path = fnamemodify(path, ':p')[J

line 14: [J

line 15:                 try[J

line 16:                     let bookmark = s:Bookmark.New(name, g:NERDTreePath.New(path))[J

line 17:                     call add(g:NERDTreeBookmarks, bookmark)[J

line 18:                 catch /^NERDTree.InvalidArgumentsError/[J

line 19:                     call add(g:NERDTreeInvalidBookmarks, i)[J

line 20:                     let invalidBookmarksFound += 1[J

line 21:                 endtry[J

line 22:             endif[J

line 23:         endfor[J

line 24:         if invalidBookmarksFound[J

line 25:             call s:Bookmark.Write()[J

line 26:             if !a:silent[J

line 27:                 call nerdtree#echo(invalidBookmarksFound . ' invalid bookmarks were read. See :help NERDTreeInvalidBookmarks for info.')[J

line 28:             endif[J

line 29:         endif[J

line 30:     endif[J

87 returning #0[J

continuing in nerdtree#postSourceActions[J

line 2:     call nerdtree#ui_glue#createDefaultBindings()[J

calling nerdtree#ui_glue#createDefaultBindings[J()

line 1:     let s = '<SNR>' . s:SID() . '_'[J

calling <SNR>34_SID[J()

line 1:     if !exists('s:sid')[J

line 2:         let s:sid = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')[J

line 3:     endif[J

line 4:     return s:sid[J

<SNR>34_SID returning '34'[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 2: [J

line 3:     call NERDTreeAddKeyMap({ 'key': '<MiddleMouse>', 'scope': 'all', 'callback': s . 'handleMiddleMouse' })[J

calling NERDTreeAddKeyMap[J({'key': '<MiddleMouse>', 'scope': 'all...callback': '<SNR>34_handleMiddleMouse'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': '<MiddleMouse>', 'scope': 'all...callback': '<SNR>34_handleMiddleMouse'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('<MiddleMouse>', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...leMiddleMouse', 'key': '<MiddleMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 4:     call NERDTreeAddKeyMap({ 'key': '<LeftRelease>', 'scope': 'all', 'callback': s.'handleLeftClick' })[J

calling NERDTreeAddKeyMap[J({'key': '<LeftRelease>', 'scope': 'all', 'callback': '<SNR>34_handleLeftClick'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': '<LeftRelease>', 'scope': 'all', 'callback': '<SNR>34_handleLeftClick'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('<LeftRelease>', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...ndleLeftClick', 'key': '<LeftRelease>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 5:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'DirNode', 'callback': s.'activateDirNode' })[J

calling NERDTreeAddKeyMap[J({'key': '<2-LeftMouse>', 'scope': 'Dir... 'callback': '<SNR>34_activateDirNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': '<2-LeftMouse>', 'scope': 'Dir... 'callback': '<SNR>34_activateDirNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('<2-LeftMouse>', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...tivateDirNode', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 6:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'FileNode', 'callback': s.'activateFileNode' })[J

calling NERDTreeAddKeyMap[J({'key': '<2-LeftMouse>', 'scope': 'Fil...'callback': '<SNR>34_activateFileNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': '<2-LeftMouse>', 'scope': 'Fil...'callback': '<SNR>34_activateFileNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('<2-LeftMouse>', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...ivateFileNode', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 7:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'Bookmark', 'callback': s.'activateBookmark' })[J

calling NERDTreeAddKeyMap[J({'key': '<2-LeftMouse>', 'scope': 'Boo...'callback': '<SNR>34_activateBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': '<2-LeftMouse>', 'scope': 'Boo...'callback': '<SNR>34_activateBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('<2-LeftMouse>', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...ivateBookmark', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 8:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': 'all', 'callback': s.'activateAll' })[J

calling NERDTreeAddKeyMap[J({'key': '<2-LeftMouse>', 'scope': 'all', 'callback': '<SNR>34_activateAll'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': '<2-LeftMouse>', 'scope': 'all', 'callback': '<SNR>34_activateAll'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('<2-LeftMouse>', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...4_activateAll', 'key': '<2-LeftMouse>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 9: [J

line 10:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'FileNode', 'callback': s.'customOpenFile'})[J

calling NERDTreeAddKeyMap[J({'key': '<CR>', 'scope': 'FileNode', 'callback': '<SNR>34_customOpenFile'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': '<CR>', 'scope': 'FileNode', 'callback': '<SNR>34_customOpenFile'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('<CR>', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...<SNR>34_customOpenFile', 'key': '<CR>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 11:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'DirNode', 'callback': s.'customOpenDir'})[J

calling NERDTreeAddKeyMap[J({'key': '<CR>', 'scope': 'DirNode', 'callback': '<SNR>34_customOpenDir'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': '<CR>', 'scope': 'DirNode', 'callback': '<SNR>34_customOpenDir'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('<CR>', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...'<SNR>34_customOpenDir', 'key': '<CR>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 12:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'Bookmark', 'callback': s.'customOpenBookmark'})[J

calling NERDTreeAddKeyMap[J({'key': '<CR>', 'scope': 'Bookmark', 'callback': '<SNR>34_customOpenBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': '<CR>', 'scope': 'Bookmark', 'callback': '<SNR>34_customOpenBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('<CR>', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...>34_customOpenBookmark', 'key': '<CR>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 13:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCustomOpen, 'scope':'all', 'callback': s.'activateAll' })[J

calling NERDTreeAddKeyMap[J({'key': '<CR>', 'scope': 'all', 'callback': '<SNR>34_activateAll'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': '<CR>', 'scope': 'all', 'callback': '<SNR>34_activateAll'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('<CR>', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...: '<SNR>34_activateAll', 'key': '<CR>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 14: [J

line 15:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'DirNode', 'callback': s.'activateDirNode' })[J

calling NERDTreeAddKeyMap[J({'key': 'o', 'scope': 'DirNode', 'callback': '<SNR>34_activateDirNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'o', 'scope': 'DirNode', 'callback': '<SNR>34_activateDirNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('o', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun... '<SNR>34_activateDirNode', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 16:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'FileNode', 'callback': s.'activateFileNode' })[J

calling NERDTreeAddKeyMap[J({'key': 'o', 'scope': 'FileNode', 'callback': '<SNR>34_activateFileNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'o', 'scope': 'FileNode', 'callback': '<SNR>34_activateFileNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('o', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...'<SNR>34_activateFileNode', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 17:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'Bookmark', 'callback': s.'activateBookmark' })[J

calling NERDTreeAddKeyMap[J({'key': 'o', 'scope': 'Bookmark', 'callback': '<SNR>34_activateBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'o', 'scope': 'Bookmark', 'callback': '<SNR>34_activateBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('o', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...'<SNR>34_activateBookmark', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 18:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': 'Bookmark', 'callback': s.'previewBookmark' })[J

calling NERDTreeAddKeyMap[J({'key': 'go', 'scope': 'Bookmark', 'callback': '<SNR>34_previewBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'go', 'scope': 'Bookmark', 'callback': '<SNR>34_previewBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('go', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...'<SNR>34_previewBookmark', 'key': 'go'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 19:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': 'all', 'callback': s.'activateAll' })[J

calling NERDTreeAddKeyMap[J({'key': 'o', 'scope': 'all', 'callback': '<SNR>34_activateAll'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'o', 'scope': 'all', 'callback': '<SNR>34_activateAll'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('o', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...ck': '<SNR>34_activateAll', 'key': 'o'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 20: [J

line 21:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': 'FileNode', 'callback': s.'openHSplit' })[J

calling NERDTreeAddKeyMap[J({'key': 'i', 'scope': 'FileNode', 'callback': '<SNR>34_openHSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'i', 'scope': 'FileNode', 'callback': '<SNR>34_openHSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('i', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...ack': '<SNR>34_openHSplit', 'key': 'i'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 22:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': 'Bookmark', 'callback': s.'openHSplitBookmark' })[J

calling NERDTreeAddKeyMap[J({'key': 'i', 'scope': 'Bookmark', 'callback': '<SNR>34_openHSplitBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'i', 'scope': 'Bookmark', 'callback': '<SNR>34_openHSplitBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('i', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...SNR>34_openHSplitBookmark', 'key': 'i'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 23:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': 'FileNode', 'callback': s.'openVSplit' })[J

calling NERDTreeAddKeyMap[J({'key': 's', 'scope': 'FileNode', 'callback': '<SNR>34_openVSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 's', 'scope': 'FileNode', 'callback': '<SNR>34_openVSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('s', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...ack': '<SNR>34_openVSplit', 'key': 's'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 24:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': 'Bookmark', 'callback': s.'openVSplitBookmark' })[J

calling NERDTreeAddKeyMap[J({'key': 's', 'scope': 'Bookmark', 'callback': '<SNR>34_openVSplitBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 's', 'scope': 'Bookmark', 'callback': '<SNR>34_openVSplitBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('s', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...SNR>34_openVSplitBookmark', 'key': 's'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 25: [J

line 26:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': 'FileNode', 'callback': s.'previewNodeCurrent' })[J

calling NERDTreeAddKeyMap[J({'key': 'go', 'scope': 'FileNode', 'callback': '<SNR>34_previewNodeCurrent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'go', 'scope': 'FileNode', 'callback': '<SNR>34_previewNodeCurrent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('go', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...NR>34_previewNodeCurrent', 'key': 'go'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 27:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': 'FileNode', 'callback': s.'previewNodeHSplit' })[J

calling NERDTreeAddKeyMap[J({'key': 'gi', 'scope': 'FileNode', 'callback': '<SNR>34_previewNodeHSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'gi', 'scope': 'FileNode', 'callback': '<SNR>34_previewNodeHSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('gi', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...SNR>34_previewNodeHSplit', 'key': 'gi'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 28:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': 'Bookmark', 'callback': s.'previewNodeHSplitBookmark' })[J

calling NERDTreeAddKeyMap[J({'key': 'gi', 'scope': 'Bookmark', 'ca...': '<SNR>34_previewNodeHSplitBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'gi', 'scope': 'Bookmark', 'ca...': '<SNR>34_previewNodeHSplitBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('gi', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...reviewNodeHSplitBookmark', 'key': 'gi'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 29:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': 'FileNode', 'callback': s.'previewNodeVSplit' })[J

calling NERDTreeAddKeyMap[J({'key': 'gs', 'scope': 'FileNode', 'callback': '<SNR>34_previewNodeVSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'gs', 'scope': 'FileNode', 'callback': '<SNR>34_previewNodeVSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('gs', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...SNR>34_previewNodeVSplit', 'key': 'gs'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 30:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': 'Bookmark', 'callback': s.'previewNodeVSplitBookmark' })[J

calling NERDTreeAddKeyMap[J({'key': 'gs', 'scope': 'Bookmark', 'ca...': '<SNR>34_previewNodeVSplitBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'gs', 'scope': 'Bookmark', 'ca...': '<SNR>34_previewNodeVSplitBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('gs', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...reviewNodeVSplitBookmark', 'key': 'gs'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 31: [J

line 32:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenRecursively, 'scope': 'DirNode', 'callback': s.'openNodeRecursively' })[J

calling NERDTreeAddKeyMap[J({'key': 'O', 'scope': 'DirNode', 'callback': '<SNR>34_openNodeRecursively'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'O', 'scope': 'DirNode', 'callback': '<SNR>34_openNodeRecursively'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('O', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...NR>34_openNodeRecursively', 'key': 'O'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 33: [J

line 34:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdir, 'scope': 'all', 'callback': s . 'upDirCurrentRootClosed' })[J

calling NERDTreeAddKeyMap[J({'key': 'u', 'scope': 'all', 'callback': '<SNR>34_upDirCurrentRootClosed'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'u', 'scope': 'all', 'callback': '<SNR>34_upDirCurrentRootClosed'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('u', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...34_upDirCurrentRootClosed', 'key': 'u'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 35:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdirKeepOpen, 'scope': 'all', 'callback': s . 'upDirCurrentRootOpen' })[J

calling NERDTreeAddKeyMap[J({'key': 'U', 'scope': 'all', 'callback': '<SNR>34_upDirCurrentRootOpen'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'U', 'scope': 'all', 'callback': '<SNR>34_upDirCurrentRootOpen'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('U', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...R>34_upDirCurrentRootOpen', 'key': 'U'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 36:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChangeRoot, 'scope': 'Node', 'callback': s . 'chRoot' })[J

calling NERDTreeAddKeyMap[J({'key': 'C', 'scope': 'Node', 'callback': '<SNR>34_chRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'C', 'scope': 'Node', 'callback': '<SNR>34_chRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('C', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...allback': '<SNR>34_chRoot', 'key': 'C'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 37: [J

line 38:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChdir, 'scope': 'Node', 'callback': s.'chCwd' })[J

calling NERDTreeAddKeyMap[J({'key': 'cd', 'scope': 'Node', 'callback': '<SNR>34_chCwd'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'cd', 'scope': 'Node', 'callback': '<SNR>34_chCwd'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('cd', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...allback': '<SNR>34_chCwd', 'key': 'cd'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 39: [J

line 40:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapQuit, 'scope': 'all', 'callback': s.'closeTreeWindow' })[J

calling NERDTreeAddKeyMap[J({'key': 'q', 'scope': 'all', 'callback': '<SNR>34_closeTreeWindow'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'q', 'scope': 'all', 'callback': '<SNR>34_closeTreeWindow'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('q', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun... '<SNR>34_closeTreeWindow', 'key': 'q'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 41: [J

line 42:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCWD, 'scope': 'all', 'callback': 'nerdtree#ui_glue#chRootCwd' })[J

calling NERDTreeAddKeyMap[J({'key': 'CD', 'scope': 'all', 'callback': 'nerdtree#ui_glue#chRootCwd'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'CD', 'scope': 'all', 'callback': 'nerdtree#ui_glue#chRootCwd'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('CD', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...rdtree#ui_glue#chRootCwd', 'key': 'CD'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 43: [J

line 44:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefreshRoot, 'scope': 'all', 'callback': s.'refreshRoot' })[J

calling NERDTreeAddKeyMap[J({'key': 'R', 'scope': 'all', 'callback': '<SNR>34_refreshRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'R', 'scope': 'all', 'callback': '<SNR>34_refreshRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('R', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...ck': '<SNR>34_refreshRoot', 'key': 'R'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 45:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefresh, 'scope': 'Node', 'callback': s.'refreshCurrent' })[J

calling NERDTreeAddKeyMap[J({'key': 'r', 'scope': 'Node', 'callback': '<SNR>34_refreshCurrent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'r', 'scope': 'Node', 'callback': '<SNR>34_refreshCurrent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('r', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...: '<SNR>34_refreshCurrent', 'key': 'r'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 46: [J

line 47:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapHelp, 'scope': 'all', 'callback': s.'displayHelp' })[J

calling NERDTreeAddKeyMap[J({'key': '?', 'scope': 'all', 'callback': '<SNR>34_displayHelp'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': '?', 'scope': 'all', 'callback': '<SNR>34_displayHelp'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('?', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...ck': '<SNR>34_displayHelp', 'key': '?'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 48:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleZoom, 'scope': 'all', 'callback': s.'toggleZoom' })[J

calling NERDTreeAddKeyMap[J({'key': 'A', 'scope': 'all', 'callback': '<SNR>34_toggleZoom'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'A', 'scope': 'all', 'callback': '<SNR>34_toggleZoom'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('A', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...ack': '<SNR>34_toggleZoom', 'key': 'A'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 49:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleHidden, 'scope': 'all', 'callback': s.'toggleShowHidden' })[J

calling NERDTreeAddKeyMap[J({'key': 'I', 'scope': 'all', 'callback': '<SNR>34_toggleShowHidden'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'I', 'scope': 'all', 'callback': '<SNR>34_toggleShowHidden'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('I', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...'<SNR>34_toggleShowHidden', 'key': 'I'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 50:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFilters, 'scope': 'all', 'callback': s.'toggleIgnoreFilter' })[J

calling NERDTreeAddKeyMap[J({'key': 'f', 'scope': 'all', 'callback': '<SNR>34_toggleIgnoreFilter'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'f', 'scope': 'all', 'callback': '<SNR>34_toggleIgnoreFilter'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('f', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...SNR>34_toggleIgnoreFilter', 'key': 'f'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 51:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFiles, 'scope': 'all', 'callback': s.'toggleShowFiles' })[J

calling NERDTreeAddKeyMap[J({'key': 'F', 'scope': 'all', 'callback': '<SNR>34_toggleShowFiles'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'F', 'scope': 'all', 'callback': '<SNR>34_toggleShowFiles'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('F', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun... '<SNR>34_toggleShowFiles', 'key': 'F'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 52:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleBookmarks, 'scope': 'all', 'callback': s.'toggleShowBookmarks' })[J

calling NERDTreeAddKeyMap[J({'key': 'B', 'scope': 'all', 'callback': '<SNR>34_toggleShowBookmarks'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'B', 'scope': 'all', 'callback': '<SNR>34_toggleShowBookmarks'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('B', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...NR>34_toggleShowBookmarks', 'key': 'B'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 53: [J

line 54:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseDir, 'scope': 'Node', 'callback': s.'closeCurrentDir' })[J

calling NERDTreeAddKeyMap[J({'key': 'x', 'scope': 'Node', 'callback': '<SNR>34_closeCurrentDir'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'x', 'scope': 'Node', 'callback': '<SNR>34_closeCurrentDir'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('x', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun... '<SNR>34_closeCurrentDir', 'key': 'x'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 55:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseChildren, 'scope': 'DirNode', 'callback': s.'closeChildren' })[J

calling NERDTreeAddKeyMap[J({'key': 'X', 'scope': 'DirNode', 'callback': '<SNR>34_closeChildren'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'X', 'scope': 'DirNode', 'callback': '<SNR>34_closeChildren'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('X', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...': '<SNR>34_closeChildren', 'key': 'X'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 56: [J

line 57:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapMenu, 'scope': 'Node', 'callback': s.'showMenu' })[J

calling NERDTreeAddKeyMap[J({'key': 'm', 'scope': 'Node', 'callback': '<SNR>34_showMenu'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'm', 'scope': 'Node', 'callback': '<SNR>34_showMenu'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('m', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...lback': '<SNR>34_showMenu', 'key': 'm'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 58: [J

line 59:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpParent, 'scope': 'Node', 'callback': s.'jumpToParent' })[J

calling NERDTreeAddKeyMap[J({'key': 'p', 'scope': 'Node', 'callback': '<SNR>34_jumpToParent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'p', 'scope': 'Node', 'callback': '<SNR>34_jumpToParent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('p', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...k': '<SNR>34_jumpToParent', 'key': 'p'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 60:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpFirstChild, 'scope': 'Node', 'callback': s.'jumpToFirstChild' })[J

calling NERDTreeAddKeyMap[J({'key': 'K', 'scope': 'Node', 'callback': '<SNR>34_jumpToFirstChild'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'K', 'scope': 'Node', 'callback': '<SNR>34_jumpToFirstChild'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('K', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...'<SNR>34_jumpToFirstChild', 'key': 'K'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 61:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpLastChild, 'scope': 'Node', 'callback': s.'jumpToLastChild' })[J

calling NERDTreeAddKeyMap[J({'key': 'J', 'scope': 'Node', 'callback': '<SNR>34_jumpToLastChild'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'J', 'scope': 'Node', 'callback': '<SNR>34_jumpToLastChild'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('J', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun... '<SNR>34_jumpToLastChild', 'key': 'J'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 62:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpRoot, 'scope': 'all', 'callback': s.'jumpToRoot' })[J

calling NERDTreeAddKeyMap[J({'key': 'P', 'scope': 'all', 'callback': '<SNR>34_jumpToRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'P', 'scope': 'all', 'callback': '<SNR>34_jumpToRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('P', 'all')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...ack': '<SNR>34_jumpToRoot', 'key': 'P'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 63:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpNextSibling, 'scope': 'Node', 'callback': s.'jumpToNextSibling' })[J

calling NERDTreeAddKeyMap[J({'key': '<C-j>', 'scope': 'Node', 'callback': '<SNR>34_jumpToNextSibling'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': '<C-j>', 'scope': 'Node', 'callback': '<SNR>34_jumpToNextSibling'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('<C-j>', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...>34_jumpToNextSibling', 'key': '<C-j>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 64:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpPrevSibling, 'scope': 'Node', 'callback': s.'jumpToPrevSibling' })[J

calling NERDTreeAddKeyMap[J({'key': '<C-k>', 'scope': 'Node', 'callback': '<SNR>34_jumpToPrevSibling'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': '<C-k>', 'scope': 'Node', 'callback': '<SNR>34_jumpToPrevSibling'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('<C-k>', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...>34_jumpToPrevSibling', 'key': '<C-k>'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 65: [J

line 66:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Node', 'callback': s . 'openInNewTab' })[J

calling NERDTreeAddKeyMap[J({'key': 't', 'scope': 'Node', 'callback': '<SNR>34_openInNewTab'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 't', 'scope': 'Node', 'callback': '<SNR>34_openInNewTab'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('t', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...k': '<SNR>34_openInNewTab', 'key': 't'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 67:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Node', 'callback': s . 'openInNewTabSilent' })[J

calling NERDTreeAddKeyMap[J({'key': 'T', 'scope': 'Node', 'callback': '<SNR>34_openInNewTabSilent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'T', 'scope': 'Node', 'callback': '<SNR>34_openInNewTabSilent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('T', 'Node')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...SNR>34_openInNewTabSilent', 'key': 'T'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 68:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': 'Bookmark', 'callback': s . 'openInNewTab' })[J

calling NERDTreeAddKeyMap[J({'key': 't', 'scope': 'Bookmark', 'callback': '<SNR>34_openInNewTab'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 't', 'scope': 'Bookmark', 'callback': '<SNR>34_openInNewTab'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('t', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...k': '<SNR>34_openInNewTab', 'key': 't'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 69:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': 'Bookmark', 'callback': s . 'openInNewTabSilent' })[J

calling NERDTreeAddKeyMap[J({'key': 'T', 'scope': 'Bookmark', 'callback': '<SNR>34_openInNewTabSilent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'T', 'scope': 'Bookmark', 'callback': '<SNR>34_openInNewTabSilent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('T', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...SNR>34_openInNewTabSilent', 'key': 'T'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 70: [J

line 71:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': 'DirNode', 'callback': s.'openExplorer' })[J

calling NERDTreeAddKeyMap[J({'key': 'e', 'scope': 'DirNode', 'callback': '<SNR>34_openExplorer'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'e', 'scope': 'DirNode', 'callback': '<SNR>34_openExplorer'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('e', 'DirNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...k': '<SNR>34_openExplorer', 'key': 'e'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 72:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': 'FileNode', 'callback': s.'openExplorer' })[J

calling NERDTreeAddKeyMap[J({'key': 'e', 'scope': 'FileNode', 'callback': '<SNR>34_openExplorer'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'e', 'scope': 'FileNode', 'callback': '<SNR>34_openExplorer'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('e', 'FileNode')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...k': '<SNR>34_openExplorer', 'key': 'e'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

line 73: [J

line 74:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapDeleteBookmark, 'scope': 'Bookmark', 'callback': s.'deleteBookmark' })[J

calling NERDTreeAddKeyMap[J({'key': 'D', 'scope': 'Bookmark', 'callback': '<SNR>34_deleteBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)[J

calling 79[J({'key': 'D', 'scope': 'Bookmark', 'callback': '<SNR>34_deleteBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 2: [J

line 3:     "dont override other mappings unless the 'override' option is given[J

line 4:     if get(opts, 'override', 0) ==# 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))[J

calling 73[J('D', 'Bookmark')

line 1:     return get(s:keyMaps, a:key . a:scope, {})[J

73 returning {}[J

continuing in 79[J

line 5:         return[J

line 6:     end[J

line 7: [J

line 8:     let newKeyMap = copy(self)[J

line 9:     let newKeyMap.key = opts['key'][J

line 10:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 11:     let newKeyMap.callback = opts['callback'][J

line 12:     let newKeyMap.scope = opts['scope'][J

line 13: [J

line 14:     call s:KeyMap.Add(newKeyMap)[J

calling 80[J({'All': function('71'), 'BindAll': fun...: '<SNR>34_deleteBookmark', 'key': 'D'})

line 1:     let s:keyMaps[a:keymap.key . a:keymap.scope] = a:keymap[J

80 returning #0[J

continuing in 79[J

79 returning #0[J

continuing in NERDTreeAddKeyMap[J

NERDTreeAddKeyMap returning #0[J

continuing in nerdtree#ui_glue#createDefaultBindings[J

nerdtree#ui_glue#createDefaultBindings returning #0[J

continuing in nerdtree#postSourceActions[J

line 3: [J

line 4:     "load all nerdtree plugins[J

line 5:     runtime! nerdtree_plugin/**/*.vim[J

Searching for "nerdtree_plugin/**/*.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/Users/tsen/.vim/nerdtree_plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/nerdtree_plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/**/*.vim"[J
chdir(/Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin)[J
fchdir() to previous dir[J
line 5: sourcing "/Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim"[J
line 1: " ============================================================================[J

line 2: " File:        exec_menuitem.vim[J

line 3: " Description: plugin for NERD Tree that provides an execute file menu item[J

line 4: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>[J

line 5: " License:     This program is free software. It comes without any warranty,[J

line 6: "              to the extent permitted by applicable law. You can redistribute[J

line 7: "              it and/or modify it under the terms of the Do What The Fuck You[J

line 8: "              Want To Public License, Version 2, as published by Sam Hocevar.[J

line 9: "              See http://sam.zoy.org/wtfpl/COPYING for more details.[J

line 10: "[J

line 11: " ============================================================================[J

line 12: if exists('g:loaded_nerdtree_exec_menuitem')[J

line 13:     finish[J

line 14: endif[J

line 15: let g:loaded_nerdtree_exec_menuitem = 1[J

line 16: [J

line 17: call NERDTreeAddMenuItem({ 'text': '(!)Execute file', 'shortcut': '!', 'callback': 'NERDTreeExecFile', 'isActiveCallback': 'NERDTreeExecFileActive' })[J

calling NERDTreeAddMenuItem[J({'callback': 'NERDTreeExecFile', 'shor...iveCallback': 'NERDTreeExecFileActive'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)[J

calling 64[J({'callback': 'NERDTreeExecFile', 'shor...iveCallback': 'NERDTreeExecFileActive'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling 62[J()

line 1:     if !exists('s:menuItems')[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

62 returning [][J

continuing in 64[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

64 returning {'All': function('62'), 'isActiveCallb...reeExecFile', 'Create': function('64')}[J

continuing in NERDTreeAddMenuItem[J

NERDTreeAddMenuItem returning #0[J

continuing in /Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim[J

line 22: [J

line 23: function! NERDTreeExecFileActive()[J

line 27: [J

line 28: function! NERDTreeExecFile()[J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim[J
continuing in nerdtree#postSourceActions[J
chdir(/Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin)[J
fchdir() to previous dir[J
line 5: sourcing "/Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim"[J
line 1: " ============================================================================[J

line 2: " File:        fs_menu.vim[J

line 3: " Description: plugin for the NERD Tree that provides a file system menu[J

line 4: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>[J

line 5: " License:     This program is free software. It comes without any warranty,[J

line 6: "              to the extent permitted by applicable law. You can redistribute[J

line 7: "              it and/or modify it under the terms of the Do What The Fuck You[J

line 8: "              Want To Public License, Version 2, as published by Sam Hocevar.[J

line 9: "              See http://sam.zoy.org/wtfpl/COPYING for more details.[J

line 10: "[J

line 11: " ============================================================================[J

line 12: if exists('g:loaded_nerdtree_fs_menu')[J

line 13:     finish[J

line 14: endif[J

line 15: let g:loaded_nerdtree_fs_menu = 1[J

line 16: [J

line 17: "Automatically delete the buffer after deleting or renaming a file[J

line 18: if !exists('g:NERDTreeAutoDeleteBuffer')[J

line 19:     let g:NERDTreeAutoDeleteBuffer = 0[J

line 20: endif[J

line 21: [J

line 22: call NERDTreeAddMenuItem({'text': '(a)dd a childnode', 'shortcut': 'a', 'callback': 'NERDTreeAddNode'})[J

calling NERDTreeAddMenuItem[J({'callback': 'NERDTreeAddNode', 'shortcut': 'a', 'text': '(a)dd a childnode'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)[J

calling 64[J({'callback': 'NERDTreeAddNode', 'shortcut': 'a', 'text': '(a)dd a childnode'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling 62[J()

line 1:     if !exists('s:menuItems')[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

62 returning [{'All': function('62'), 'isActiveCall...eeExecFile', 'Create': function('64')}][J

continuing in 64[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

64 returning {'All': function('62'), 'isActiveCallb...TreeAddNode', 'Create': function('64')}[J

continuing in NERDTreeAddMenuItem[J

NERDTreeAddMenuItem returning #0[J

continuing in /Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 23: call NERDTreeAddMenuItem({'text': '(m)ove the current node', 'shortcut': 'm', 'callback': 'NERDTreeMoveNode'})[J

calling NERDTreeAddMenuItem[J({'callback': 'NERDTreeMoveNode', 'shor...'m', 'text': '(m)ove the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)[J

calling 64[J({'callback': 'NERDTreeMoveNode', 'shor...'m', 'text': '(m)ove the current node'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling 62[J()

line 1:     if !exists('s:menuItems')[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

62 returning [{'All': function('62'), 'isActiveCall...reeAddNode', 'Create': function('64')}][J

continuing in 64[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

64 returning {'All': function('62'), 'isActiveCallb...reeMoveNode', 'Create': function('64')}[J

continuing in NERDTreeAddMenuItem[J

NERDTreeAddMenuItem returning #0[J

continuing in /Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 24: call NERDTreeAddMenuItem({'text': '(d)elete the current node', 'shortcut': 'd', 'callback': 'NERDTreeDeleteNode'})[J

calling NERDTreeAddMenuItem[J({'callback': 'NERDTreeDeleteNode', 'sh...', 'text': '(d)elete the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)[J

calling 64[J({'callback': 'NERDTreeDeleteNode', 'sh...', 'text': '(d)elete the current node'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling 62[J()

line 1:     if !exists('s:menuItems')[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

62 returning [{'All': function('62'), 'isActiveCall...eeMoveNode', 'Create': function('64')}][J

continuing in 64[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

64 returning {'All': function('62'), 'isActiveCallb...eDeleteNode', 'Create': function('64')}[J

continuing in NERDTreeAddMenuItem[J

NERDTreeAddMenuItem returning #0[J

continuing in /Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 25: [J

line 26: if has('gui_mac') || has('gui_macvim') || has('mac')[J

line 27:     call NERDTreeAddMenuItem({'text': '(r)eveal in Finder the current node', 'shortcut': 'r', 'callback': 'NERDTreeRevealInFinder'})[J

calling NERDTreeAddMenuItem[J({'callback': 'NERDTreeRevealInFinder',... '(r)eveal in Finder the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)[J

calling 64[J({'callback': 'NERDTreeRevealInFinder',... '(r)eveal in Finder the current node'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling 62[J()

line 1:     if !exists('s:menuItems')[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

62 returning [{'All': function('62'), 'isActiveCall...DeleteNode', 'Create': function('64')}][J

continuing in 64[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

64 returning {'All': function('62'), 'isActiveCallb...ealInFinder', 'Create': function('64')}[J

continuing in NERDTreeAddMenuItem[J

NERDTreeAddMenuItem returning #0[J

continuing in /Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 28:     call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFile'})[J

calling NERDTreeAddMenuItem[J({'callback': 'NERDTreeExecuteFile', 's...n the current node with system editor'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)[J

calling 64[J({'callback': 'NERDTreeExecuteFile', 's...n the current node with system editor'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling 62[J()

line 1:     if !exists('s:menuItems')[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

62 returning [{'All': function('62'), 'isActiveCall...alInFinder', 'Create': function('64')}][J

continuing in 64[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

64 returning {'All': function('62'), 'isActiveCallb...ExecuteFile', 'Create': function('64')}[J

continuing in NERDTreeAddMenuItem[J

NERDTreeAddMenuItem returning #0[J

continuing in /Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 29:     call NERDTreeAddMenuItem({'text': '(q)uicklook the current node', 'shortcut': 'q', 'callback': 'NERDTreeQuickLook'})[J

calling NERDTreeAddMenuItem[J({'callback': 'NERDTreeQuickLook', 'sho...'text': '(q)uicklook the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)[J

calling 64[J({'callback': 'NERDTreeQuickLook', 'sho...'text': '(q)uicklook the current node'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling 62[J()

line 1:     if !exists('s:menuItems')[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

62 returning [{'All': function('62'), 'isActiveCall...xecuteFile', 'Create': function('64')}][J

continuing in 64[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

64 returning {'All': function('62'), 'isActiveCallb...eeQuickLook', 'Create': function('64')}[J

continuing in NERDTreeAddMenuItem[J

NERDTreeAddMenuItem returning #0[J

continuing in /Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 30: endif[J

line 31: [J

line 32: if executable('xdg-open')[J

line 33:     call NERDTreeAddMenuItem({'text': '(r)eveal the current node in file manager', 'shortcut': 'r', 'callback': 'NERDTreeRevealFileLinux'})[J

line 34:     call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFileLinux'})[J

line 35: endif[J

line 36: [J

line 37: if nerdtree#runningWindows()[J

calling nerdtree#runningWindows[J()

line 1:     return has('win16') || has('win32') || has('win64')[J

nerdtree#runningWindows returning #0[J

continuing in /Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 38:     call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFileWindows'})[J

line 39: endif[J

line 40: [J

line 41: if g:NERDTreePath.CopyingSupported()[J

calling 10[J()

line 1:     return exists('g:NERDTreeCopyCmd') || (exists('g:NERDTreeCopyDirCmd') && exists('g:NERDTreeCopyFileCmd'))[J

10 returning #1[J

continuing in /Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 42:     call NERDTreeAddMenuItem({'text': '(c)opy the current node', 'shortcut': 'c', 'callback': 'NERDTreeCopyNode'})[J

calling NERDTreeAddMenuItem[J({'callback': 'NERDTreeCopyNode', 'shor...'c', 'text': '(c)opy the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)[J

calling 64[J({'callback': 'NERDTreeCopyNode', 'shor...'c', 'text': '(c)opy the current node'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling 62[J()

line 1:     if !exists('s:menuItems')[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

62 returning [{'All': function('62'), 'isActiveCall...eQuickLook', 'Create': function('64')}][J

continuing in 64[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

64 returning {'All': function('62'), 'isActiveCallb...reeCopyNode', 'Create': function('64')}[J

continuing in NERDTreeAddMenuItem[J

NERDTreeAddMenuItem returning #0[J

continuing in /Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 43: endif[J

line 44: call NERDTreeAddMenuItem({'text': (has('clipboard')?'copy (p)ath to clipboard':'print (p)ath to screen'), 'shortcut': 'p', 'callback': 'NERDTreeCopyPath'})[J

calling NERDTreeAddMenuItem[J({'callback': 'NERDTreeCopyPath', 'shor...p', 'text': 'copy (p)ath to clipboard'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)[J

calling 64[J({'callback': 'NERDTreeCopyPath', 'shor...p', 'text': 'copy (p)ath to clipboard'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling 62[J()

line 1:     if !exists('s:menuItems')[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

62 returning [{'All': function('62'), 'isActiveCall...eeCopyNode', 'Create': function('64')}][J

continuing in 64[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

64 returning {'All': function('62'), 'isActiveCallb...reeCopyPath', 'Create': function('64')}[J

continuing in NERDTreeAddMenuItem[J

NERDTreeAddMenuItem returning #0[J

continuing in /Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 45: [J

line 46: if has('unix') || has('osx')[J

line 47:     call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNode'})[J

calling NERDTreeAddMenuItem[J({'callback': 'NERDTreeListNode', 'shor...'l', 'text': '(l)ist the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)[J

calling 64[J({'callback': 'NERDTreeListNode', 'shor...'l', 'text': '(l)ist the current node'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling 62[J()

line 1:     if !exists('s:menuItems')[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

62 returning [{'All': function('62'), 'isActiveCall...eeCopyPath', 'Create': function('64')}][J

continuing in 64[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

64 returning {'All': function('62'), 'isActiveCallb...reeListNode', 'Create': function('64')}[J

continuing in NERDTreeAddMenuItem[J

NERDTreeAddMenuItem returning #0[J

continuing in /Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 48: else[J

line 49:     call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNodeWin32'})[J

line 50: endif[J

line 51: [J

line 52: if exists('*system')[J

line 53:     call NERDTreeAddMenuItem({'text': 'Run (s)ystem command in this directory', 'shortcut':'s', 'callback': 'NERDTreeSystemCommand'})[J

calling NERDTreeAddMenuItem[J({'callback': 'NERDTreeSystemCommand', ...un (s)ystem command in this directory'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)[J

calling 64[J({'callback': 'NERDTreeSystemCommand', ...un (s)ystem command in this directory'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling 62[J()

line 1:     if !exists('s:menuItems')[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

62 returning [{'All': function('62'), 'isActiveCall...eeListNode', 'Create': function('64')}][J

continuing in 64[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

64 returning {'All': function('62'), 'isActiveCallb...stemCommand', 'Create': function('64')}[J

continuing in NERDTreeAddMenuItem[J

NERDTreeAddMenuItem returning #0[J

continuing in /Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 54: endif[J

line 55: [J

line 56: "FUNCTION: s:inputPrompt(action){{{1[J

line 57: "returns the string that should be prompted to the user for the given action[J

line 58: "[J

line 59: "Args:[J

line 60: "action: the action that is being performed, e.g. 'delete'[J

line 61: function! s:inputPrompt(action)[J

line 96: [J

line 97: "FUNCTION: s:promptToDelBuffer(bufnum, msg){{{1[J

line 98: "prints out the given msg and, if the user responds by pushing 'y' then the[J

line 99: "buffer with the given bufnum is deleted[J

line 100: "[J

line 101: "Args:[J

line 102: "bufnum: the buffer that may be deleted[J

line 103: "msg: a message that will be echoed to the user asking them if they wish to[J

line 104: "     del the buffer[J

line 105: function! s:promptToDelBuffer(bufnum, msg)[J

line 135: [J

line 136: "FUNCTION: s:renameBuffer(bufNum, newNodeName, isDirectory){{{1[J

line 137: "The buffer with the given bufNum is replaced with a new one[J

line 138: "[J

line 139: "Args:[J

line 140: "bufNum: the buffer that may be deleted[J

line 141: "newNodeName: the name given to the renamed node[J

line 142: "isDirectory: determines how to do the create the new filenames[J

line 143: function! s:renameBuffer(bufNum, newNodeName, isDirectory)[J

line 167: [J

line 168: "FUNCTION: NERDTreeAddNode(){{{1[J

line 169: function! NERDTreeAddNode()[J

line 201: [J

line 202: "FUNCTION: NERDTreeMoveNode(){{{1[J

line 203: function! NERDTreeMoveNode()[J

line 256: [J

line 257: " FUNCTION: NERDTreeDeleteNode() {{{1[J

line 258: function! NERDTreeDeleteNode()[J

line 295: [J

line 296: " FUNCTION: NERDTreeListNode() {{{1[J

line 297: function! NERDTreeListNode()[J

line 317: [J

line 318: " FUNCTION: NERDTreeListNodeWin32() {{{1[J

line 319: function! NERDTreeListNodeWin32()[J

line 335: [J

line 336: " FUNCTION: NERDTreeCopyNode() {{{1[J

line 337: function! NERDTreeCopyNode()[J

line 375: [J

line 376: " FUNCTION: NERDTreeCopyPath() {{{1[J

line 377: function! NERDTreeCopyPath()[J

line 390: [J

line 391: " FUNCTION: NERDTreeQuickLook() {{{1[J

line 392: function! NERDTreeQuickLook()[J

line 401: [J

line 402: " FUNCTION: NERDTreeRevealInFinder() {{{1[J

line 403: function! NERDTreeRevealInFinder()[J

line 412: [J

line 413: " FUNCTION: NERDTreeExecuteFile() {{{1[J

line 414: function! NERDTreeExecuteFile()[J

line 423: [J

line 424: " FUNCTION: NERDTreeRevealFileLinux() {{{1[J

line 425: function! NERDTreeRevealFileLinux()[J

line 444: [J

line 445: " FUNCTION: NERDTreeExecuteFileLinux() {{{1[J

line 446: function! NERDTreeExecuteFileLinux()[J

line 455: [J

line 456: " FUNCTION: NERDTreeExecuteFileWindows() {{{1[J

line 457: function! NERDTreeExecuteFileWindows()[J

line 466: [J

line 467: " FUNCTION: NERDTreeSystemCommand() {{{1[J

line 468: function! NERDTreeSystemCommand()[J

line 483: [J

line 484: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J
continuing in nerdtree#postSourceActions[J
chdir(/Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin)[J
fchdir() to previous dir[J
line 5: sourcing "/Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/vcs.vim"[J
line 1: " ============================================================================[J

line 2: " File:        vcs.vim[J

line 3: " Description: NERDTree plugin that provides a command to open on the root of[J

line 4: "              a version control system repository.[J

line 5: " Maintainer:  Phil Runninger[J

line 6: " License:     This program is free software. It comes without any warranty,[J

line 7: "              to the extent permitted by applicable law. You can redistribute[J

line 8: "              it and/or modify it under the terms of the Do What The Fuck You[J

line 9: "              Want To Public License, Version 2, as published by Sam Hocevar.[J

line 10: "              See http://sam.zoy.org/wtfpl/COPYING for more details.[J

line 11: "[J

line 12: " ============================================================================[J

line 13: command! -n=? -complete=dir -bar NERDTreeVCS :call <SID>CreateTabTreeVCS('<args>')[J

line 14: command! -n=? -complete=dir -bar NERDTreeToggleVCS :call <SID>ToggleTabTreeVCS('<args>')[J

line 15: [J

line 16: " FUNCTION: s:CreateTabTreeVCS(a:name) {{{1[J

line 17: function! s:CreateTabTreeVCS(name)[J

line 22: [J

line 23: " FUNCTION: s:ToggleTabTreeVCS(a:name) {{{1[J

line 24: " Behaves the same as ToggleTabTree except roots directory at VCS root[J

line 25: function! s:ToggleTabTreeVCS(name)[J

line 30: [J

line 31: " FUNCTION: s:FindParentVCSRoot(a:path) {{{1[J

line 32: " Finds the root version control system folder of the given path. If a:path is[J

line 33: " not part of a repository, return the original path.[J

line 34: function! s:FindParentVCSRoot(path)[J

line 47: [J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/nerdtree_plugin/vcs.vim[J
continuing in nerdtree#postSourceActions[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/nerdtree_plugin/**/*.vim"[J
chdir(/Users/tsen/.vim/bundle/vim-nerdtree-tabs/nerdtree_plugin)[J
fchdir() to previous dir[J
line 5: sourcing "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/nerdtree_plugin/vim-nerdtree-tabs.vim"[J
line 1: " === plugin configuration variables === {{{[J

line 2: "[J

line 3: " Open NERDTree on gvim/macvim startup. When set to `2`,[J

line 4: " open only if directory was given as startup argument.[J

line 5: if !exists('g:nerdtree_tabs_open_on_gui_startup')[J

line 6:   let g:nerdtree_tabs_open_on_gui_startup = 1[J

line 7: endif[J

line 8: [J

line 9: " Open NERDTree on console vim startup (off by default). When set to `2`,[J

line 10: " open only if directory was given as startup argument.[J

line 11: if !exists('g:nerdtree_tabs_open_on_console_startup')[J

line 12:   let g:nerdtree_tabs_open_on_console_startup = 0[J

line 13: endif[J

line 14: [J

line 15: " do not open NERDTree if vim starts in diff mode[J

line 16: if !exists('g:nerdtree_tabs_no_startup_for_diff')[J

line 17:     let g:nerdtree_tabs_no_startup_for_diff = 1[J

line 18: endif[J

line 19: [J

line 20: " On startup - focus NERDTree when opening a directory, focus the file if[J

line 21: " editing a specified file. When set to `2`, always focus file after startup.[J

line 22: if !exists('g:nerdtree_tabs_smart_startup_focus')[J

line 23:   let g:nerdtree_tabs_smart_startup_focus = 1[J

line 24: endif[J

line 25: [J

line 26: " Open NERDTree on new tab creation if NERDTree was globally opened[J

line 27: " by :NERDTreeTabsToggle[J

line 28: if !exists('g:nerdtree_tabs_open_on_new_tab')[J

line 29:   let g:nerdtree_tabs_open_on_new_tab = 1[J

line 30: endif[J

line 31: [J

line 32: " unfocus NERDTree when leaving a tab so that you have descriptive tab names[J

line 33: " and not names like 'NERD_tree_1'[J

line 34: if !exists('g:nerdtree_tabs_meaningful_tab_names')[J

line 35:   let g:nerdtree_tabs_meaningful_tab_names = 1[J

line 36: endif[J

line 37: [J

line 38: " close current tab if there is only one window in it and it's NERDTree[J

line 39: if !exists('g:nerdtree_tabs_autoclose')[J

line 40:   let g:nerdtree_tabs_autoclose = 1[J

line 41: endif[J

line 42: [J

line 43: " synchronize view of all NERDTree windows (scroll and cursor position)[J

line 44: if !exists('g:nerdtree_tabs_synchronize_view')[J

line 45:   let g:nerdtree_tabs_synchronize_view = 1[J

line 46: endif[J

line 47: [J

line 48: " synchronize focus when switching tabs (focus NERDTree after tab switch[J

line 49: " if and only if it was focused before tab switch)[J

line 50: if !exists('g:nerdtree_tabs_synchronize_focus')[J

line 51:   let g:nerdtree_tabs_synchronize_focus = 1[J

line 52: endif[J

line 53: [J

line 54: " when switching into a tab, make sure that focus will always be in file[J

line 55: " editing window, not in NERDTree window (off by default)[J

line 56: if !exists('g:nerdtree_tabs_focus_on_files')[J

line 57:   let g:nerdtree_tabs_focus_on_files = 0[J

line 58: endif[J

line 59: [J

line 60: " when starting up with a directory name as a parameter, cd into it[J

line 61: if !exists('g:nerdtree_tabs_startup_cd')[J

line 62:   let g:nerdtree_tabs_startup_cd = 1[J

line 63: endif[J

line 64: [J

line 65: " automatically find and select currently opened file[J

line 66: if !exists('g:nerdtree_tabs_autofind')[J

line 67:   let g:nerdtree_tabs_autofind = 0[J

line 68: endif[J

line 69: "[J

line 70: " }}}[J

line 71: " === plugin mappings === {{{[J

line 72: "[J

line 73: noremap <silent> <script> <Plug>NERDTreeTabsOpen     :call <SID>NERDTreeOpenAllTabs()[J

line 74: noremap <silent> <script> <Plug>NERDTreeTabsClose    :call <SID>NERDTreeCloseAllTabs()[J

line 75: noremap <silent> <script> <Plug>NERDTreeTabsToggle   :call <SID>NERDTreeToggleAllTabs()[J

line 76: noremap <silent> <script> <Plug>NERDTreeTabsFind     :call <SID>NERDTreeFindFile()[J

line 77: noremap <silent> <script> <Plug>NERDTreeMirrorOpen   :call <SID>NERDTreeMirrorOrCreate()[J

line 78: noremap <silent> <script> <Plug>NERDTreeMirrorToggle :call <SID>NERDTreeMirrorToggle()[J

line 79: noremap <silent> <script> <Plug>NERDTreeSteppedOpen  :call <SID>NERDTreeSteppedOpen()[J

line 80: noremap <silent> <script> <Plug>NERDTreeSteppedClose :call <SID>NERDTreeSteppedClose()[J

line 81: noremap <silent> <script> <Plug>NERDTreeFocusToggle  :call <SID>NERDTreeFocusToggle()[J

line 82: "[J

line 83: " }}}[J

line 84: " === plugin commands === {{{[J

line 85: "[J

line 86: command! NERDTreeTabsOpen     call <SID>NERDTreeOpenAllTabs()[J

line 87: command! NERDTreeTabsClose    call <SID>NERDTreeCloseAllTabs()[J

line 88: command! NERDTreeTabsToggle   call <SID>NERDTreeToggleAllTabs()[J

line 89: command! NERDTreeTabsFind     call <SID>NERDTreeFindFile()[J

line 90: command! NERDTreeMirrorOpen   call <SID>NERDTreeMirrorOrCreate()[J

line 91: command! NERDTreeMirrorToggle call <SID>NERDTreeMirrorToggle()[J

line 92: command! NERDTreeSteppedOpen  call <SID>NERDTreeSteppedOpen()[J

line 93: command! NERDTreeSteppedClose call <SID>NERDTreeSteppedClose()[J

line 94: command! NERDTreeFocusToggle  call <SID>NERDTreeFocusToggle()[J

line 95: "[J

line 96: " }}}[J

line 97: " === plugin functions === {{{[J

line 98: "[J

line 99: " === NERDTree manipulation (opening, closing etc.) === {{{[J

line 100: "[J

line 101: " s:NERDTreeMirrorOrCreate() {{{[J

line 102: "[J

line 103: " switch NERDTree on for current tab -- mirror it if possible, otherwise create it[J

line 104: fun! s:NERDTreeMirrorOrCreate()[J

line 120: [J

line 121: " }}}[J

line 122: " s:NERDTreeMirrorToggle() {{{[J

line 123: "[J

line 124: " toggle NERDTree in current tab, use mirror if possible[J

line 125: fun! s:NERDTreeMirrorToggle()[J

line 134: [J

line 135: " }}}[J

line 136: " s:NERDTreeOpenAllTabs() {{{[J

line 137: "[J

line 138: " switch NERDTree on for all tabs while making sure there is only one NERDTree buffer[J

line 139: fun! s:NERDTreeOpenAllTabs()[J

line 151: [J

line 152: " }}}[J

line 153: " s:NERDTreeCloseAllTabs() {{{[J

line 154: "[J

line 155: " close NERDTree across all tabs[J

line 156: fun! s:NERDTreeCloseAllTabs()[J

line 164: [J

line 165: " }}}[J

line 166: " s:NERDTreeToggleAllTabs() {{{[J

line 167: "[J

line 168: " toggle NERDTree in current tab and match the state in all other tabs[J

line 169: fun! s:NERDTreeToggleAllTabs()[J

line 185: [J

line 186: " }}}[J

line 187: " s:NERDTreeSteppedOpen() {{{[J

line 188: "[J

line 189: " focus the NERDTree view, creating one first if none is present[J

line 190: fun! s:NERDTreeSteppedOpen()[J

line 199: [J

line 200: " }}}[J

line 201: " s:NERDTreeSteppedClose{() {{{[J

line 202: "[J

line 203: " unfocus the NERDTree view or closes it if it hadn't had focus at the time of[J

line 204: " the call[J

line 205: fun! s:NERDTreeSteppedClose()[J

line 216: [J

line 217: " }}}[J

line 218: " s:NERDTreeFocusToggle() {{{[J

line 219: "[J

line 220: " focus the NERDTree view or creates it if in a file,[J

line 221: " or unfocus NERDTree view if in NERDTree[J

line 222: fun! s:NERDTreeFocusToggle()[J

line 234: " }}}[J

line 235: "[J

line 236: " === NERDTree manipulation (opening, closing etc.) === }}}[J

line 237: " === focus functions === {{{[J

line 238: "[J

line 239: " s:NERDTreeFocus() {{{[J

line 240: "[J

line 241: " if the current window is NERDTree, move focus to the next window[J

line 242: fun! s:NERDTreeFocus()[J

line 247: [J

line 248: " }}}[J

line 249: " s:NERDTreeUnfocus() {{{[J

line 250: "[J

line 251: " if the current window is NERDTree, move focus to the next window[J

line 252: fun! s:NERDTreeUnfocus()[J

line 265: [J

line 266: " }}}[J

line 267: " s:NERDTreeRestoreFocus() {{{[J

line 268: "[J

line 269: " restore focus to the window that was focused before leaving current tab[J

line 270: fun! s:NERDTreeRestoreFocus()[J

line 281: [J

line 282: " }}}[J

line 283: " s:SaveGlobalFocus() {{{[J

line 284: "[J

line 285: fun! s:SaveGlobalFocus()[J

line 288: [J

line 289: " }}}[J

line 290: " s:IfFocusOnStartup() {{{[J

line 291: "[J

line 292: fun! s:IfFocusOnStartup()[J

line 295: [J

line 296: " }}}[J

line 297: "[J

line 298: " === focus functions === }}}[J

line 299: " === utility functions === {{{[J

line 300: "[J

line 301: " s:NextNormalWindow() {{{[J

line 302: "[J

line 303: " find next window with a normal buffer[J

line 304: fun! s:NextNormalWindow()[J

line 331: [J

line 332: " }}}[J

line 333: " s:CloseIfOnlyNerdTreeLeft() {{{[J

line 334: "[J

line 335: " Close all open buffers on entering a window if the only[J

line 336: " buffer that's left is the NERDTree buffer[J

line 337: fun! s:CloseIfOnlyNerdTreeLeft()[J

line 342: [J

line 343: " }}}[J

line 344: " s:IsCurrentWindowNERDTree() {{{[J

line 345: "[J

line 346: " returns 1 if current window is NERDTree, false otherwise[J

line 347: fun! s:IsCurrentWindowNERDTree()[J

line 350: [J

line 351: " }}}[J

line 352: " s:IsNERDTreeOpenInCurrentTab() {{{[J

line 353: "[J

line 354: " check if NERDTree is open in current tab[J

line 355: fun! s:IsNERDTreeOpenInCurrentTab()[J

line 358: [J

line 359: " }}}[J

line 360: " s:IsNERDTreePresentInCurrentTab() {{{[J

line 361: "[J

line 362: " check if NERDTree is present in current tab (not necessarily visible)[J

line 363: fun! s:IsNERDTreePresentInCurrentTab()[J

line 366: [J

line 367: " }}}[J

line 368: "[J

line 369: " === utility functions === }}}[J

line 370: " === NERDTree view manipulation (scroll and cursor positions) === {{{[J

line 371: "[J

line 372: " s:SaveNERDTreeViewIfPossible() {{{[J

line 373: "[J

line 374: fun! s:SaveNERDTreeViewIfPossible()[J

line 387: [J

line 388: " }}}[J

line 389: " s:RestoreNERDTreeViewIfPossible() {{{[J

line 390: "[J

line 391: fun! s:RestoreNERDTreeViewIfPossible()[J

line 414: [J

line 415: " }}}[J

line 416: " s:NERDTreeFindFile() {{{[J

line 417: "[J

line 418: fun! s:NERDTreeFindFile()[J

line 423: [J

line 424: " }}}[J

line 425: "[J

line 426: " === NERDTree view manipulation (scroll and cursor positions) === }}}[J

line 427: "[J

line 428: " === plugin functions ===  }}}[J

line 429: " === plugin event handlers === {{{[J

line 430: "[J

line 431: " s:LoadPlugin() {{{[J

line 432: "[J

line 433: fun! s:LoadPlugin()[J

line 469: [J

line 470: " }}}[J

line 471: " s:VimEnterHandler() {{{[J

line 472: "[J

line 473: fun! s:VimEnterHandler()[J

line 524: [J

line 525: " }}} s:NewTabCreated {{{[J

line 526: "[J

line 527: " A flag to indicate that a new tab has just been created.[J

line 528: "[J

line 529: " We will handle the remaining work for this newly created tab separately in[J

line 530: " BufWinEnter event.[J

line 531: "[J

line 532: let s:NewTabCreated = 0[J

line 533: [J

line 534: " }}}[J

line 535: " s:TabEnterHandler() {{{[J

line 536: "[J

line 537: fun! s:TabEnterHandler()[J

line 563: [J

line 564: " }}}[J

line 565: " s:TabLeaveHandler() {{{[J

line 566: "[J

line 567: fun! s:TabLeaveHandler()[J

line 573: [J

line 574: " }}}[J

line 575: " s:WinEnterHandler() {{{[J

line 576: "[J

line 577: fun! s:WinEnterHandler()[J

line 591: [J

line 592: " }}}[J

line 593: " s:WinLeaveHandler() {{{[J

line 594: "[J

line 595: fun! s:WinLeaveHandler()[J

line 604: [J

line 605: " }}}[J

line 606: " s:BufWinEnterHandler() {{{[J

line 607: "[J

line 608: " BufWinEnter event only gets triggered after a new buffer has been[J

line 609: " successfully loaded, it is a proper time to finish the remaining[J

line 610: " work for newly opened tab.[J

line 611: "[J

line 612: fun! s:BufWinEnterHandler()[J

line 623: [J

line 624: " }}}[J

line 625: " s:BufReadHandler() {{{[J

line 626: "[J

line 627: " BufRead event gets triggered after a new buffer has been[J

line 628: " successfully read from file.[J

line 629: "[J

line 630: fun! s:BufReadHandler()[J

line 637: [J

line 638: " }}}[J

line 639: "[J

line 640: " === plugin event handlers === }}}[J

line 641: [J

line 642: call s:LoadPlugin()[J

calling <SNR>38_LoadPlugin[J()

line 1:   if exists('g:nerdtree_tabs_loaded')[J

line 2:     return[J

line 3:   endif[J

line 4: [J

line 5:   let g:NERDTreeHijackNetrw = 0[J

line 6: [J

line 7:   let s:disable_handlers_for_tabdo = 0[J

line 8: [J

line 9:   " global on/off NERDTree state[J

line 10:   " the exists check is to enable script reloading without resetting the state[J

line 11:   if !exists('s:nerdtree_globally_active')[J

line 12:     let s:nerdtree_globally_active = 0[J

line 13:   endif[J

line 14: [J

line 15:   " global focused/unfocused NERDTree state[J

line 16:   " the exists check is to enable script reloading without resetting the state[J

line 17:   if !exists('s:is_nerdtree_globally_focused')[J

line 18:     call s:SaveGlobalFocus()[J

calling <SNR>38_SaveGlobalFocus[J()

line 1:   let s:is_nerdtree_globally_focused = s:IsCurrentWindowNERDTree()[J

calling <SNR>38_IsCurrentWindowNERDTree[J()

line 1:   return exists("t:NERDTreeBufName") && bufwinnr(t:NERDTreeBufName) == winnr()[J

<SNR>38_IsCurrentWindowNERDTree returning #0[J

continuing in <SNR>38_SaveGlobalFocus[J

<SNR>38_SaveGlobalFocus returning #0[J

continuing in <SNR>38_LoadPlugin[J

line 19:   end[J

line 20: [J

line 21:   augroup NERDTreeTabs[J

line 22:     autocmd![J

line 23:     autocmd VimEnter * call <SID>VimEnterHandler()[J

line 24:     autocmd TabEnter * call <SID>TabEnterHandler()[J

line 25:     autocmd TabLeave * call <SID>TabLeaveHandler()[J

line 26:     " We enable nesting for this autocommand (see :h autocmd-nested) so that[J

line 27:     " exiting Vim when NERDTree is the last window triggers the VimLeave event.[J

line 28:     autocmd WinEnter * nested call <SID>WinEnterHandler()[J

line 29:     autocmd WinLeave * call <SID>WinLeaveHandler()[J

line 30:     autocmd BufWinEnter * call <SID>BufWinEnterHandler()[J

line 31:     autocmd BufRead * call <SID>BufReadHandler()[J

line 32:   augroup END[J

line 33: [J

line 34:   let g:nerdtree_tabs_loaded = 1[J

<SNR>38_LoadPlugin returning #0[J

continuing in /Users/tsen/.vim/bundle/vim-nerdtree-tabs/nerdtree_plugin/vim-nerdtree-tabs.vim[J

finished sourcing /Users/tsen/.vim/bundle/vim-nerdtree-tabs/nerdtree_plugin/vim-nerdtree-tabs.vim[J
continuing in nerdtree#postSourceActions[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/nerdtree_plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/nerdtree_plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/nerdtree_plugin/**/*.vim"[J
Searching for "/usr/local/share/vim/vimfiles/nerdtree_plugin/**/*.vim"[J
Searching for "/usr/local/share/vim/vim90/nerdtree_plugin/**/*.vim"[J
Searching for "/usr/local/share/vim/vimfiles/after/nerdtree_plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/after/nerdtree_plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/nerdtree_plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/after/nerdtree_plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/after/nerdtree_plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after/nerdtree_plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/after/nerdtree_plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/after/nerdtree_plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/after/nerdtree_plugin/**/*.vim"[J
nerdtree#postSourceActions returning #0[J

continuing in /Users/tsen/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 230: [J

line 231: "reset &cpoptions back to users setting[J

line 232: let &cpoptions = s:old_cpo[J

line 233: [J

line 234: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /Users/tsen/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/plugin/**/*.vim"[J
chdir(/Users/tsen/.vim/bundle/vim-autoformat/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/tsen/.vim/bundle/vim-autoformat/plugin/autoformat.vim"[J
line 1: " Function for getting the verbose mode level[J

line 2: function! s:GetVerboseMode(...)[J

line 11: [J

line 12: " Function for finding the formatters for this filetype[J

line 13: " Result is stored in b:formatters[J

line 14: function! s:FindFormatters(...)[J

line 78: [J

line 79: [J

line 80: " Try all formatters, starting with the currently selected one, until one[J

line 81: " works. If none works, autoindent the buffer.[J

line 82: function! s:TryAllFormatters(...) range[J

line 189: [J

line 190: function! s:Fallback()[J

line 217: [J

line 218: function! s:WinSaveViews()[J

line 224: [J

line 225: function! s:WinRestViews()[J

line 230: [J

line 231: [J

line 232: " Call formatter[J

line 233: " If stderr is empty, apply result, return 0[J

line 234: " Otherwise, return 1[J

line 235: [J

line 236: " +python version[J

line 237: function! s:TryFormatterPython()[J

line 295: [J

line 296: " +python3 version[J

line 297: function! s:TryFormatterPython3()[J

line 358: [J

line 359: [J

line 360: " Create a command for formatting the entire buffer[J

line 361: " Save and recall window state to prevent vim from jumping to line 1[J

line 362: " Write and read viminfo to restore marks[J

line 363: command! -nargs=? -range=% -complete=filetype -bar Autoformat call s:WinSaveViews()|wviminfo|<line1>,<line2>call s:TryAllFormatters(<f-args>)|call s:WinRestViews()|rviminfo[J

line 365: [J

line 366: " Create a command for formatting a single line, or range of lines[J

line 367: " Save and recall window state to prevent vim from jumping to line 1[J

line 368: " Write and read viminfo to restore marks[J

line 369: command! -nargs=? -range -complete=filetype -bar AutoformatLine call s:WinSaveViews()|wviminfo|<line1>,<line2>call s:TryAllFormatters(<f-args>)|call s:WinRestViews()|rviminfo[J

line 371: [J

line 372: [J

line 373: " Functions for iterating through list of available formatters[J

line 374: function! s:NextFormatter()[J

line 382: [J

line 383: function! s:PreviousFormatter()[J

line 392: [J

line 393: function! s:CurrentFormatter()[J

line 400: [J

line 401: " Create commands for iterating through formatter list[J

line 402: command! NextFormatter call s:NextFormatter()[J

line 403: command! PreviousFormatter call s:PreviousFormatter()[J

line 404: command! CurrentFormatter call s:CurrentFormatter()[J

line 405: [J

line 406: " Other commands[J

line 407: function! s:RemoveTrailingSpaces()[J

line 416: command! RemoveTrailingSpaces call s:RemoveTrailingSpaces()[J

finished sourcing /Users/tsen/.vim/bundle/vim-autoformat/plugin/autoformat.vim[J
chdir(/Users/tsen/.vim/bundle/vim-autoformat/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/tsen/.vim/bundle/vim-autoformat/plugin/defaults.vim"[J
line 1: [J

line 2: "[J

line 3: " This file contains default settings and all format program definitions and links these to filetypes[J

line 4: "[J

line 5: [J

line 6: [J

line 7: " Vim-autoformat configuration variables[J

line 8: if !exists('g:autoformat_autoindent')[J

line 9:     let g:autoformat_autoindent = 1[J

line 10: endif[J

line 11: [J

line 12: if !exists('g:autoformat_retab')[J

line 13:     let g:autoformat_retab = 1[J

line 14: endif[J

line 15: [J

line 16: if !exists('g:autoformat_remove_trailing_spaces')[J

line 17:     let g:autoformat_remove_trailing_spaces = 1[J

line 18: endif[J

line 19: [J

line 20: if !exists('g:autoformat_verbosemode')[J

line 21:     let g:autoformat_verbosemode = 0[J

line 22: endif[J

line 23: [J

line 24: [J

line 25: " Ada[J

line 26: if !exists('g:formatdef_gnatpp')[J

line 27:     let g:formatdef_gnatpp = "'cat > /tmp/adafile; gnatpp --pipe /tmp/adafile; rm -f /tmp/adafile'"[J

line 28: endif[J

line 29: [J

line 30: if !exists('g:formatters_ada')[J

line 31:     let g:formatters_ada = ['gnatpp'][J

line 32: endif[J

line 33: [J

line 34: " Python[J

line 35: if !exists('g:formatdef_autopep8')[J

line 36:     " Autopep8 will not do indentation fixes when a range is specified, so we[J

line 37:     " only pass a range when there is a visual selection that is not the[J

line 38:     " entire file. See #125.[J

line 39:     let g:formatdef_autopep8 = '"autopep8 -".(g:DoesRangeEqualBuffer(a:firstline, a:lastline) ? " --range ".a:firstline." ".a:lastline : "")." ".(&textwidth ? "--max-line-length=".&textwidth : "")'[J

line 40: endif[J

line 41: [J

line 42: " There doesn't seem to be a reliable way to detect if are in some kind of visual mode,[J

line 43: " so we use this as a workaround. We compare the length of the file against[J

line 44: " the range arguments. If there is no range given, the range arguments default[J

line 45: " to the entire file, so we return false if the range comprises the entire file.[J

line 46: function! g:DoesRangeEqualBuffer(first, last)[J

line 49: [J

line 50: " Yapf supports multiple formatter styles: pep8, google, chromium, or facebook[J

line 51: if !exists('g:formatter_yapf_style')[J

line 52:     let g:formatter_yapf_style = 'pep8'[J

line 53: endif[J

line 54: if !exists('g:formatdef_yapf')[J

line 55:     let s:configfile_def   = "'yapf -l '.a:firstline.'-'.a:lastline"[J

line 56:     let s:noconfigfile_def = "'yapf --style=\"{based_on_style:'.g:formatter_yapf_style.',indent_width:'.shiftwidth().(&textwidth ? ',column_limit:'.&textwidth : '').'}\" -l '.a:firstline.'-'.a:lastline"[J

line 57:     let g:formatdef_yapf   = "g:YAPFFormatConfigFileExists() ? (" . s:configfile_def . ") : (" . s:noconfigfile_def . ")"[J

line 58: endif[J

line 59: [J

line 60: function! g:YAPFFormatConfigFileExists()[J

line 63: [J

line 64: if !exists('g:formatdef_black')[J

line 65:     let g:formatdef_black = '"black -q ".(&textwidth ? "-l".&textwidth : "")." -"'[J

line 66: endif[J

line 67: [J

line 68: if !exists('g:formatters_python')[J

line 69:     let g:formatters_python = ['autopep8','yapf', 'black'][J

line 70: endif[J

line 71: [J

line 72: [J

line 73: " C#[J

line 74: if !exists('g:formatdef_astyle_cs')[J

line 75:     if filereadable('.astylerc')[J

line 76:         let g:formatdef_astyle_cs = '"astyle --mode=cs --options=.astylerc"'[J

line 77:     elseif filereadable(expand('~/.astylerc')) || exists('$ARTISTIC_STYLE_OPTIONS')[J

line 78:         let g:formatdef_astyle_cs = '"astyle --mode=cs"'[J

line 79:     else[J

line 80:         let g:formatdef_astyle_cs = '"astyle --mode=cs --style=ansi --indent-namespaces -pcH".(&expandtab ? "s".shiftwidth() : "t")'[J

line 81:     endif[J

line 82: endif[J

line 83: [J

line 84: if !exists('g:formatters_cs')[J

line 85:     let g:formatters_cs = ['astyle_cs'][J

line 86: endif[J

line 87: [J

line 88: if !exists('g:formatters_bzl')[J

line 89:     let g:formatters_bzl = ['buildifier'][J

line 90: endif[J

line 91: [J

line 92: [J

line 93: " Generic C, C++, Objective-C[J

line 94: if !exists('g:formatdef_clangformat')[J

line 95:     let s:configfile_def = "'clang-format -lines='.a:firstline.':'.a:lastline.' --assume-filename=\"'.expand('%:p').'\" -style=file'"[J

line 96:     let s:noconfigfile_def = "'clang-format -lines='.a:firstline.':'.a:lastline.' --assume-filename=\"'.expand('%:p').'\" -style=\"{BasedOnStyle: WebKit, AlignTrailingComments: true, '.(&textwidth ? 'ColumnLimit: '.&textwidth.', ' : '').'IndentWidth: '.shiftwidth().', TabWidth: '.&tabstop.', '.(&expandtab ? 'UseTab: Never' : 'UseTab: Always').'}\"'"[J

line 97:     let g:formatdef_clangformat = "g:ClangFormatConfigFileExists() ? (" . s:configfile_def . ") : (" . s:noconfigfile_def . ")"[J

line 98: endif[J

line 99: [J

line 100: function! g:ClangFormatConfigFileExists()[J

line 103: [J

line 104: [J

line 105: [J

line 106: " C[J

line 107: if !exists('g:formatdef_astyle_c')[J

line 108:     if filereadable('.astylerc')[J

line 109:         let g:formatdef_astyle_c = '"astyle --mode=c --options=.astylerc"'[J

line 110:     elseif filereadable(expand('~/.astylerc')) || exists('$ARTISTIC_STYLE_OPTIONS')[J

line 111:         let g:formatdef_astyle_c = '"astyle --mode=c"'[J

line 112:     else[J

line 113:         let g:formatdef_astyle_c = '"astyle --mode=c --style=ansi -pcH".(&expandtab ? "s".shiftwidth() : "t")'[J

line 114:     endif[J

line 115: endif[J

line 116: [J

line 117: if !exists('g:formatters_c')[J

line 118:     let g:formatters_c = ['clangformat', 'astyle_c'][J

line 119: endif[J

line 120: [J

line 121: [J

line 122: " C++[J

line 123: if !exists('g:formatdef_astyle_cpp')[J

line 124:     if filereadable('.astylerc')[J

line 125:         let g:formatdef_astyle_cpp = '"astyle --mode=c --options=.astylerc"'[J

line 126:     elseif filereadable(expand('~/.astylerc')) || exists('$ARTISTIC_STYLE_OPTIONS')[J

line 127:         let g:formatdef_astyle_cpp = '"astyle --mode=c"'[J

line 128:     else[J

line 129:         let g:formatdef_astyle_cpp = '"astyle --mode=c --style=ansi -pcH".(&expandtab ? "s".shiftwidth() : "t")'[J

line 130:     endif[J

line 131: endif[J

line 132: [J

line 133: if !exists('g:formatters_cpp')[J

line 134:     let g:formatters_cpp = ['clangformat', 'astyle_cpp'][J

line 135: endif[J

line 136: [J

line 137: [J

line 138: " Objective C[J

line 139: if !exists('g:formatters_objc')[J

line 140:     let g:formatters_objc = ['clangformat'][J

line 141: endif[J

line 142: [J

line 143: [J

line 144: " D[J

line 145: if !exists('g:formatdef_dfmt')[J

line 146:     if executable('dfmt')[J

line 147:         let s:dfmt_command = 'dfmt'[J

line 148:     else[J

line 149:         let s:dfmt_command = 'dub run -q dfmt --'[J

line 150:     endif[J

line 151: [J

line 152:     let s:configfile_def = '"' . s:dfmt_command . '"'[J

line 153:     let s:noconfigfile_def = '"' . s:dfmt_command . ' -t " . (&expandtab ? "space" : "tab") . " --indent_size " . shiftwidth() . (&textwidth ? " --soft_max_line_length " . &textwidth : "")'[J

line 154: [J

line 155:     let g:formatdef_dfmt = 'g:EditorconfigFileExists() ? (' . s:configfile_def . ') : (' . s:noconfigfile_def . ')'[J

line 156:     let g:formatters_d = ['dfmt'][J

line 157: endif[J

line 158: [J

line 159: function! g:EditorconfigFileExists()[J

line 162: [J

line 163: [J

line 164: " Protobuf[J

line 165: if !exists('g:formatters_proto')[J

line 166:     let g:formatters_proto = ['clangformat'][J

line 167: endif[J

line 168: [J

line 169: [J

line 170: " Java[J

line 171: if !exists('g:formatdef_astyle_java')[J

line 172:     if filereadable('.astylerc')[J

line 173:         let g:formatdef_astyle_java = '"astyle --mode=java --options=.astylerc"'[J

line 174:     elseif filereadable(expand('~/.astylerc')) || exists('$ARTISTIC_STYLE_OPTIONS')[J

line 175:         let g:formatdef_astyle_java = '"astyle --mode=java"'[J

line 176:     else[J

line 177:         let g:formatdef_astyle_java = '"astyle --mode=java --style=java -pcH".(&expandtab ? "s".shiftwidth() : "t")'[J

line 178:     endif[J

line 179: endif[J

line 180: [J

line 181: if !exists('g:formatters_java')[J

line 182:     let g:formatters_java = ['astyle_java'][J

line 183: endif[J

line 184: [J

line 185: [J

line 186: " Javascript[J

line 187: if !exists('g:formatdef_jsbeautify_javascript')[J

line 188:     if filereadable('.jsbeautifyrc')[J

line 189:         let g:formatdef_jsbeautify_javascript = '"js-beautify"'[J

line 190:     elseif filereadable(expand('~/.jsbeautifyrc'))[J

line 191:         let g:formatdef_jsbeautify_javascript = '"js-beautify"'[J

line 192:     else[J

line 193:         let g:formatdef_jsbeautify_javascript = '"js-beautify -X -".(&expandtab ? "s ".shiftwidth() : "t").(&textwidth ? " -w ".&textwidth : "")'[J

line 194:     endif[J

line 195: endif[J

line 196: [J

line 197: if !exists('g:formatdef_jscs')[J

line 198:     let g:formatdef_jscs = '"jscs -x"'[J

line 199: endif[J

line 200: [J

line 201: if !exists('g:formatdef_standard_javascript')[J

line 202:     let g:formatdef_standard_javascript = '"standard --fix --stdin"'[J

line 203: endif[J

line 204: [J

line 205: [J

line 206: if !exists('g:formatdef_prettier')[J

line 207:     let g:formatdef_prettier = '"prettier --stdin-filepath ".expand("%:p").(&textwidth ? " --print-width ".&textwidth : "")." --tab-width=".shiftwidth()'[J

line 208: endif[J

line 209: [J

line 210: [J

line 211: " This is an xo formatter (inspired by the above eslint formatter)[J

line 212: " To support ignore and overrides options, we need to use a tmp file[J

line 213: " So we create a tmp file here and then remove it afterwards[J

line 214: if !exists('g:formatdef_xo_javascript')[J

line 215:     function! g:BuildXOLocalCmd()[J

line 218:     let g:formatdef_xo_javascript = "g:BuildXOLocalCmd()"[J

line 219: endif[J

line 220: [J

line 221: function! s:NodeJsFindPathToExecFile(exec_name)[J

line 235: [J

line 236: " Setup ESLint local. Setup is done on formatter execution if ESLint and[J

line 237: " corresponding config is found they are used, otherwiese the formatter fails.[J

line 238: " No windows support at the moment.[J

line 239: if !exists('g:formatdef_eslint_local')[J

line 240:     " returns unique file name near original[J

line 241:     function! g:BuildESLintTmpFile(path, ext)[J

line 255: [J

line 256:     function! g:BuildESLintLocalCmd()[J

line 312:     let g:formatdef_eslint_local = "g:BuildESLintLocalCmd()"[J

line 313: endif[J

line 314: [J

line 315: if !exists('g:formatters_javascript')[J

line 316:     let g:formatters_javascript = [ 'eslint_local', 'jsbeautify_javascript', 'jscs', 'standard_javascript', 'prettier', 'xo_javascript', 'stylelint', ][J

line 325: endif[J

line 326: [J

line 327: " Vue[J

line 328: if !exists('g:formatters_vue')[J

line 329:     let g:formatters_vue = [ 'eslint_local', 'stylelint', ][J

line 333: endif[J

line 334: [J

line 335: " JSON[J

line 336: if !exists('g:formatdef_jsbeautify_json')[J

line 337:     if filereadable('.jsbeautifyrc')[J

line 338:         let g:formatdef_jsbeautify_json = '"js-beautify"'[J

line 339:     elseif filereadable(expand('~/.jsbeautifyrc'))[J

line 340:         let g:formatdef_jsbeautify_json = '"js-beautify"'[J

line 341:     else[J

line 342:         let g:formatdef_jsbeautify_json = '"js-beautify -".(&expandtab ? "s ".shiftwidth() : "t")'[J

line 343:     endif[J

line 344: endif[J

line 345: [J

line 346: if !exists('g:formatdef_fixjson')[J

line 347:     let g:formatdef_fixjson =  '"fixjson"'[J

line 348: endif[J

line 349: [J

line 350: if !exists('g:formatters_json')[J

line 351:     let g:formatters_json = [ 'jsbeautify_json', 'fixjson', 'prettier', ][J

line 356: endif[J

line 357: [J

line 358: [J

line 359: " Julia[J

line 360: if !exists('g:formatdef_juliaformatter')[J

line 361:     function! g:BuildJuliaCmd()[J

line 364:     let g:formatdef_juliaformatter = 'g:BuildJuliaCmd()'[J

line 365: endif[J

line 366: [J

line 367: if !exists('g:formatters_julia')[J

line 368:     let g:formatters_julia = ['juliaformatter'][J

line 369: endif[J

line 370: [J

line 371: [J

line 372: " HTML[J

line 373: if !exists('g:formatdef_htmlbeautify')[J

line 374:     let g:formatdef_htmlbeautify = '"html-beautify - -".(&expandtab ? "s ".shiftwidth() : "t").(&textwidth ? " -w ".&textwidth : "")'[J

line 375: endif[J

line 376: [J

line 377: if !exists('g:formatdef_tidy_html')[J

line 378:     let g:formatdef_tidy_html = '"tidy -q --show-errors 0 --show-warnings 0 --force-output --indent auto --indent-spaces ".shiftwidth()." --vertical-space yes --tidy-mark no -wrap ".&textwidth'[J

line 379: endif[J

line 380: [J

line 381: if !exists('g:formatters_html')[J

line 382:     let g:formatters_html = ['htmlbeautify', 'tidy_html', 'stylelint'][J

line 383: endif[J

line 384: [J

line 385: [J

line 386: [J

line 387: " XML[J

line 388: if !exists('g:formatdef_tidy_xml')[J

line 389:     let g:formatdef_tidy_xml = '"tidy -q -xml --show-errors 0 --show-warnings 0 --force-output --indent auto --indent-spaces ".shiftwidth()." --vertical-space yes --tidy-mark no -wrap ".&textwidth'[J

line 390: endif[J

line 391: [J

line 392: if !exists('g:formatters_xml')[J

line 393:     let g:formatters_xml = ['tidy_xml'][J

line 394: endif[J

line 395: [J

line 396: " SVG[J

line 397: if !exists('g:formatters_svg')[J

line 398:     let g:formatters_svg = ['tidy_xml'][J

line 399: endif[J

line 400: [J

line 401: " XHTML[J

line 402: if !exists('g:formatdef_tidy_xhtml')[J

line 403:     let g:formatdef_tidy_xhtml = '"tidy -q --show-errors 0 --show-warnings 0 --force-output --indent auto --indent-spaces ".shiftwidth()." --vertical-space yes --tidy-mark no -asxhtml -wrap ".&textwidth'[J

line 404: endif[J

line 405: [J

line 406: if !exists('g:formatters_xhtml')[J

line 407:     let g:formatters_xhtml = ['tidy_xhtml'][J

line 408: endif[J

line 409: [J

line 410: " Ruby[J

line 411: if !exists('g:formatdef_rbeautify')[J

line 412:     let g:formatdef_rbeautify = '"rbeautify ".(&expandtab ? "-s -c ".shiftwidth() : "-t")'[J

line 413: endif[J

line 414: [J

line 415: if !exists('g:formatdef_rubocop')[J

line 416:     " The pipe to sed is required to remove some rubocop output that could not[J

line 417:     " be suppressed.[J

line 418:     let g:formatdef_rubocop = "'rubocop --auto-correct -o /dev/null -s '.bufname('%').' \| sed -n 2,\\$p'"[J

line 419: endif[J

line 420: [J

line 421: if !exists('g:formatters_ruby')[J

line 422:     let g:formatters_ruby = ['rbeautify', 'rubocop'][J

line 423: endif[J

line 424: [J

line 425: [J

line 426: " CSS[J

line 427: [J

line 428: " Setup stylelint. Setup is done on formatter execution[J

line 429: " if stylelint is found, otherwise the formatter fails.[J

line 430: " No windows support at the moment.[J

line 431: if !exists('g:formatdef_stylelint')[J

line 432:     function! g:BuildStyleLintCmd()[J

line 449:     let g:formatdef_stylelint = "g:BuildStyleLintCmd()"[J

line 450: endif[J

line 451: [J

line 452: [J

line 453: if !exists('g:formatdef_cssbeautify')[J

line 454:     let g:formatdef_cssbeautify = '"css-beautify -f - -s ".shiftwidth()'[J

line 455: endif[J

line 456: [J

line 457: if !exists('g:formatters_css')[J

line 458:     let g:formatters_css = ['cssbeautify', 'prettier', 'stylelint'][J

line 459: endif[J

line 460: [J

line 461: " SCSS[J

line 462: if !exists('g:formatdef_sassconvert')[J

line 463:     let g:formatdef_sassconvert = '"sass-convert -F scss -T scss --indent " . (&expandtab ? shiftwidth() : "t")'[J

line 464: endif[J

line 465: [J

line 466: if !exists('g:formatters_scss')[J

line 467:     let g:formatters_scss = ['sassconvert', 'prettier', 'stylelint'][J

line 468: endif[J

line 469: [J

line 470: " Less[J

line 471: if !exists('g:formatters_less')[J

line 472:     let g:formatters_less = ['prettier', 'stylelint'][J

line 473: endif[J

line 474: [J

line 475: " Typescript[J

line 476: if !exists('g:formatdef_tsfmt')[J

line 477:     let g:formatdef_tsfmt = "'tsfmt --stdin '.bufname('%')"[J

line 478: endif[J

line 479: [J

line 480: if !exists('g:formatters_typescript')[J

line 481:     let g:formatters_typescript = ['tsfmt', 'prettier'][J

line 482: endif[J

line 483: [J

line 484: " Haxe[J

line 485: if !exists('g:formatdef_haxe_formatter')[J

line 486:     let g:formatdef_haxe_formatter = "'haxelib run formatter --stdin --source " . fnamemodify("%", ":p:h") . "'"[J

line 487: endif[J

line 488: [J

line 489: if !exists('g:formatters_haxe')[J

line 490:     let g:formatters_haxe = ["haxe_formatter"][J

line 491: endif[J

line 492: [J

line 493: " Golang[J

line 494: " Two definitions are provided for two versions of gofmt.[J

line 495: " See issue #59[J

line 496: if !exists('g:formatdef_gofmt_1')[J

line 497:     let g:formatdef_gofmt_1 = '"gofmt -tabs=".(&expandtab ? "false" : "true")." -tabwidth=".shiftwidth()'[J

line 498: endif[J

line 499: [J

line 500: if !exists('g:formatdef_gofmt_2')[J

line 501:     let g:formatdef_gofmt_2 = '"gofmt"'[J

line 502: endif[J

line 503: [J

line 504: if !exists('g:formatdef_goimports')[J

line 505:     let g:formatdef_goimports = '"goimports"'[J

line 506: endif[J

line 507: [J

line 508: if !exists('g:formatdef_gofumpt')[J

line 509:     let g:formatdef_gofumpt = '"gofumpt"'[J

line 510: endif[J

line 511: [J

line 512: if !exists('g:formatters_go')[J

line 513:     let g:formatters_go = ['gofmt_1', 'goimports', 'gofmt_2', 'gofumpt'][J

line 514: endif[J

line 515: [J

line 516: " Rust[J

line 517: if !exists('g:formatdef_rustfmt')[J

line 518:     let g:formatdef_rustfmt = '"rustfmt --edition 2018"'[J

line 519: endif[J

line 520: [J

line 521: if !exists('g:formatters_rust')[J

line 522:     let g:formatters_rust = ['rustfmt'][J

line 523: endif[J

line 524: [J

line 525: " Zig[J

line 526: if !exists('g:formatdef_zigfmt')[J

line 527:     let g:formatdef_zigfmt = '"zig fmt --stdin"'[J

line 528: endif[J

line 529: [J

line 530: if !exists('g:formatters_zig')[J

line 531:     let g:formatters_zig = ['zigfmt'][J

line 532: endif[J

line 533: [J

line 534: " Dart[J

line 535: if !exists('g:formatdef_dart_format')[J

line 536:     let g:formatdef_dart_format = '"dart format"'[J

line 537: endif[J

line 538: [J

line 539: if !exists('g:formatters_dart')[J

line 540:     let g:formatters_dart = ['dart_format'][J

line 541: endif[J

line 542: [J

line 543: " Perl[J

line 544: if !exists('g:formatdef_perltidy')[J

line 545:     " use perltidyrc file if readable[J

line 546:     if (has("win32") && (filereadable("perltidy.ini") || filereadable($HOMEPATH."/perltidy.ini"))) || ((has("unix") || has("mac")) && (filereadable(".perltidyrc") || filereadable(expand("~/.perltidyrc")) || filereadable("/usr/local/etc/perltidyrc") || filereadable("/etc/perltidyrc")))[J

line 553:         let g:formatdef_perltidy = '"perltidy -q -st"'[J

line 554:     else[J

line 555:         let g:formatdef_perltidy = '"perltidy --perl-best-practices --format-skipping -q "'[J

line 556:     endif[J

line 557: endif[J

line 558: [J

line 559: if !exists('g:formatters_perl')[J

line 560:     let g:formatters_perl = ['perltidy'][J

line 561: endif[J

line 562: [J

line 563: " Haskell[J

line 564: if !exists('g:formatdef_stylish_haskell')[J

line 565:     let g:formatdef_stylish_haskell = '"stylish-haskell"'[J

line 566: endif[J

line 567: [J

line 568: if !exists('g:formatters_haskell')[J

line 569:     let g:formatters_haskell = ['stylish_haskell'][J

line 570: endif[J

line 571: [J

line 572: " Purescript[J

line 573: if !exists('g:formatdef_purty')[J

line 574:     let g:formatdef_purty = '"purty -"'[J

line 575: endif[J

line 576: [J

line 577: if !exists('g:formatters_purescript')[J

line 578:     let g:formatters_purescript = ['purty'][J

line 579: endif[J

line 580: [J

line 581: " Markdown[J

line 582: if !exists('g:formatdef_remark_markdown')[J

line 583:     let g:formatdef_remark_markdown = '"remark --silent --no-color"'[J

line 584: endif[J

line 585: [J

line 586: if !exists('g:formatters_markdown')[J

line 587:     let g:formatters_markdown = ['remark_markdown', 'prettier', 'stylelint'][J

line 588: endif[J

line 589: [J

line 590: " Graphql[J

line 591: if !exists('g:formatters_graphql')[J

line 592:     let g:formatters_graphql = ['prettier'][J

line 593: endif[J

line 594: [J

line 595: " Fortran[J

line 596: if !exists('g:formatdef_fprettify')[J

line 597:     let g:formatdef_fprettify = '"fprettify --no-report-errors --indent=".shiftwidth()'[J

line 598: endif[J

line 599: [J

line 600: if !exists('g:formatters_fortran')[J

line 601:     let g:formatters_fortran = ['fprettify'][J

line 602: endif[J

line 603: [J

line 604: " Elixir[J

line 605: [J

line 606: if !exists('g:formatters_elixir')[J

line 607:     let s:configfile_def = '"mix format --dot-formatter " . findfile(".formatter.exs", expand("%:p:h").";") . " -"'[J

line 608:     let s:noconfigfile_def = '"mix format -"'[J

line 609: [J

line 610:     let g:formatdef_mix_format = 'g:ElixirconfigFileExists() ? (' . s:configfile_def . ') : (' . s:noconfigfile_def . ')'[J

line 611:     let g:formatters_elixir = ['mix_format'][J

line 612: endif[J

line 613: [J

line 614: [J

line 615: function! g:ElixirconfigFileExists()[J

line 618: [J

line 619: " Shell[J

line 620: if !exists('g:formatdef_shfmt')[J

line 621:     let g:formatdef_shfmt = '"shfmt -i ".(&expandtab ? shiftwidth() : "0")'[J

line 622: endif[J

line 623: [J

line 624: if !exists('g:formatters_sh')[J

line 625:     let g:formatters_sh = ['shfmt'][J

line 626: endif[J

line 627: [J

line 628: " Fish shell[J

line 629: if !exists('g:formatdef_fish_indent')[J

line 630:     let g:formatdef_fish_indent = '"fish_indent"'[J

line 631: endif[J

line 632: [J

line 633: if !exists('g:formatters_fish')[J

line 634:     let g:formatters_fish = ['fish_indent'][J

line 635: endif[J

line 636: [J

line 637: " Lua[J

line 638: if !exists('g:formatdef_luafmt')[J

line 639:     let g:formatdef_luafmt = "'luafmt --stdin '.bufname('%')"[J

line 640: endif[J

line 641: if !exists('g:formatdef_stylua')[J

line 642:     let g:formatdef_stylua = "'stylua --search-parent-directories --stdin-filepath ' . expand('%:p') .' -- -'"[J

line 643: endif[J

line 644: if !exists('g:formatters_lua')[J

line 645:     let g:formatters_lua = ['luafmt', 'stylua'][J

line 646: endif[J

line 647: [J

line 648: " SQL[J

line 649: if !exists('g:formatdef_sqlformat')[J

line 650:     let g:formatdef_sqlformat = '"sqlformat --reindent --indent_width ".shiftwidth()." --keywords upper --identifiers lower -"'[J

line 651: endif[J

line 652: if !exists('g:formatters_sql')[J

line 653:     let g:formatters_sql = ['sqlformat'][J

line 654: endif[J

line 655: [J

line 656: " CMake[J

line 657: if !exists('g:formatdef_cmake_format')[J

line 658:     let g:formatdef_cmake_format = '"cmake-format - --tab-size ".shiftwidth()." ".(&textwidth ? "--line-width=".&textwidth : "")'[J

line 659: endif[J

line 660: [J

line 661: if !exists('g:formatters_cmake')[J

line 662:     let g:formatters_cmake = ['cmake_format'][J

line 663: endif[J

line 664: [J

line 665: " Latex[J

line 666: if !exists('g:formatdef_latexindent')[J

line 667:     let g:formatdef_latexindent = '"latexindent.pl -"'[J

line 668: endif[J

line 669: [J

line 670: if !exists('g:formatters_latex')[J

line 671:     let g:formatters_tex = ['latexindent'][J

line 672: endif[J

line 673: [J

line 674: " OCaml[J

line 675: if !exists('g:formatdef_ocp_indent')[J

line 676:     let g:formatdef_ocp_indent = '"ocp-indent"'[J

line 677: endif[J

line 678: [J

line 679: if !exists('g:formatdef_ocamlformat')[J

line 680:     if filereadable('.ocamlformat')[J

line 681:         let g:formatdef_ocamlformat = '"ocamlformat --enable-outside-detected-project --name " . expand("%:p") . " -"'[J

line 682:     else[J

line 683:         let g:formatdef_ocamlformat = '"ocamlformat --profile=ocamlformat --enable-outside-detected-project --name " . expand("%:p") . " -"'[J

line 684:     endif[J

line 685: endif[J

line 686: [J

line 687: if !exists('g:formatters_ocaml')[J

line 688:     let g:formatters_ocaml = ['ocamlformat', 'ocp_indent'][J

line 689: endif[J

line 690: [J

line 691: " Assembly[J

line 692: if !exists('g:formatdef_asm_format')[J

line 693:     let g:formatdef_asm_format = '"asmfmt"'[J

line 694: endif[J

line 695: [J

line 696: if !exists('g:formatters_asm')[J

line 697:     let g:formatters_asm = ['asm_format'][J

line 698: endif[J

line 699: [J

line 700: " Nix[J

line 701: if !exists('g:formatdef_nix_format')[J

line 702:     let g:formatdef_nix_format = '"nixfmt"'[J

line 703: endif[J

line 704: [J

line 705: if !exists('g:formatters_nix')[J

line 706:     let g:formatters_nix = ['nix_format'][J

line 707: endif[J

line 708: [J

line 709: " Dhall[J

line 710: if !exists('g:formatdef_dhall_format')[J

line 711:     let g:formatdef_dhall_format = '"dhall --ascii format"'[J

line 712: endif[J

line 713: [J

line 714: if !exists('g:formatters_dhall')[J

line 715:     let g:formatters_dhall = ['dhall_format'][J

line 716: endif[J

line 717: [J

line 718: " Terraform[J

line 719: if !exists('g:formatdef_terraform_format')[J

line 720:     let g:formatdef_terraform_format = '"terraform fmt -"'[J

line 721: endif[J

line 722: [J

line 723: if !exists('g:formatters_terraform')[J

line 724:     let g:formatters_terraform = ['terraform_format'][J

line 725: endif[J

line 726: [J

line 727: " Packer[J

line 728: if !exists('g:formatdef_packer_format')[J

line 729:     let g:formatdef_packer_format = '"packer fmt -"'[J

line 730: endif[J

line 731: [J

line 732: if !exists('g:formatters_packer')[J

line 733:     let g:formatters_packer = ['packer_format'][J

line 734: endif[J

line 735: [J

line 736: " Nginx[J

line 737: if !exists('g:formatdef_nginxfmt')[J

line 738:     let g:formatdef_nginxfmt = '"nginxfmt.py -i ".shiftwidth()." -"'[J

line 739: endif[J

line 740: [J

line 741: if !exists('g:formatters_nginx')[J

line 742:     let g:formatters_nginx = ['nginxfmt'][J

line 743: endif[J

finished sourcing /Users/tsen/.vim/bundle/vim-autoformat/plugin/defaults.vim[J
chdir(/Users/tsen/.vim/bundle/vim-autoformat/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/tsen/.vim/bundle/vim-autoformat/plugin/utils.vim"[J
line 1: [J

line 2: " Simple python-based random number generator[J

line 3: function! g:RandomInt()[J

line 18: [J

line 19: " Put the uncopyable messages text into the buffer[J

line 20: command! PutMessages redir @" | messages | redir END | put[J

finished sourcing /Users/tsen/.vim/bundle/vim-autoformat/plugin/utils.vim[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/plugin/**/*.vim"[J
chdir(/Users/tsen/.vim/bundle/closetag.vim/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/tsen/.vim/bundle/closetag.vim/plugin/closetag.vim"[J
line 1: " File: closetag.vim[J

line 2: " Summary: Functions and mappings to close open HTML/XML tags[J

line 3: " Uses: <C-_> -- close matching open tag[J

line 4: " Author: Steven Mueller <diffusor@ugcs.caltech.edu>[J

line 5: " Last Modified: Tue May 24 13:29:48 PDT 2005[J

line 6: " Version: 0.9.1[J

line 7: " XXX - breaks if close attempted while XIM is in preedit mode[J

line 8: " TODO - allow usability as a global plugin -[J

line 9: "    Add g:unaryTagsStack - always contains html tags settings[J

line 10: "    and g:closetag_default_xml - user should define this to default to xml[J

line 11: "    When a close is attempted but b:unaryTagsStack undefined,[J

line 12: "    use b:closetag_html_style to determine if the file is to be treated[J

line 13: "    as html or xml.  Failing that, check the filetype for xml or html.[J

line 14: "    Finally, default to g:closetag_html_style.[J

line 15: "    If the file is html, let b:unaryTagsStack=g:unaryTagsStack[J

line 16: "    otherwise, let b:unaryTagsStack=""[J

line 17: " TODO - make matching work for all comments[J

line 18: "  -- kinda works now, but needs syn sync minlines to be very long[J

line 19: "  -- Only check whether in syntax in the beginning, then store comment tags[J

line 20: "  in the tagstacks to determine whether to move into or out of comment mode[J

line 21: " TODO - The new normal mode mapping clears recent messages with its <ESC>, and[J

line 22: " it doesn't fix the null-undo issue for vim 5.7 anyway.[J

line 23: " TODO - make use of the following neat features:[J

line 24: "  -- the ternary ?: operator[J

line 25: "  -- :echomsg and :echoerr[J

line 26: "  -- curly brace expansion for variables and function name definitions?[J

line 27: "  -- check up on map <blah> \FuncName[J

line 28: "[J

line 29: " Description:[J

line 30: " This script eases redundant typing when writing html or xml files (even if[J

line 31: " you're very good with ctrl-p and ctrl-n  :).  Hitting ctrl-_ will initiate a[J

line 32: " search for the most recent open tag above that is not closed in the[J

line 33: " intervening space and then insert the matching close tag at the cursor.  In[J

line 34: " normal mode, the close tag is inserted one character after cursor rather than[J

line 35: " at it, as if a<C-_> had been used.  This allows putting close tags at the[J

line 36: " ends of lines while in normal mode, but disallows inserting them in the[J

line 37: " first column.[J

line 38: "[J

line 39: " For HTML, a configurable list of tags are ignored in the matching process.[J

line 40: " By default, the following tags will not be matched and thus not closed[J

line 41: " automatically: area, base, br, dd, dt, hr, img, input, link, meta, and[J

line 42: " param.[J

line 43: "[J

line 44: " For XML, all tags must have a closing match or be terminated by />, as in[J

line 45: " <empty-element/>.  These empty element tags are ignored for matching.[J

line 46: "[J

line 47: " Comment checking is now handled by vim's internal syntax checking.  If tag[J

line 48: " closing is initiated outside a comment, only tags outside of comments will[J

line 49: " be matched.  When closing tags in comments, only tags within comments will[J

line 50: " be matched, skipping any non-commented out code (wee!).  However, the[J

line 51: " process of determining the syntax ID of an arbitrary position can still be[J

line 52: " erroneous if a comment is not detected because the syntax highlighting is[J

line 53: " out of sync, or really slow if syn sync minlines is large.[J

line 54: " Set the b:closetag_disable_synID variable to disable this feature if you[J

line 55: " have really big chunks of comment in your code and closing tags is too slow.[J

line 56: "[J

line 57: " If syntax highlighting is not enabled, comments will not be handled very[J

line 58: " well.  Commenting out HTML in certain ways may cause a "tag mismatch"[J

line 59: " message and no completion.  For example, '<!--a href="blah">link!</a-->'[J

line 60: " between the cursor and the most recent unclosed open tag above causes[J

line 61: " trouble.  Properly matched well formed tags in comments don't cause a[J

line 62: " problem.[J

line 63: "[J

line 64: " Install:[J

line 65: " To use, place this file in your standard vim scripts directory, and source[J

line 66: " it while editing the file you wish to close tags in.  If the filetype is not[J

line 67: " set or the file is some sort of template with embedded HTML, you may force[J

line 68: " HTML style tag matching by first defining the b:closetag_html_style buffer[J

line 69: " variable.  Otherwise, the default is XML style tag matching.[J

line 70: "[J

line 71: " Example:[J

line 72: "   :let b:closetag_html_style=1[J

line 73: "   :source ~/.vim/scripts/closetag.vim[J

line 74: "[J

line 75: " For greater convenience, load this script in an autocommand:[J

line 76: "   :au Filetype html,xml,xsl source ~/.vim/scripts/closetag.vim[J

line 77: "[J

line 78: " Also, set noignorecase for html files or edit b:unaryTagsStack to match your[J

line 79: " capitalization style.  You may set this variable before or after loading the[J

line 80: " script, or simply change the file itself.[J

line 81: "[J

line 82: " Configuration Variables:[J

line 83: "[J

line 84: " b:unaryTagsStack        Buffer local string containing a whitespace[J

line 85: "                         seperated list of element names that should be[J

line 86: "                         ignored while finding matching closetags.  Checking[J

line 87: "                         is done according to the current setting of the[J

line 88: "                         ignorecase option.[J

line 89: "[J

line 90: " b:closetag_html_style   Define this (as with let b:closetag_html_style=1)[J

line 91: "                         and source the script again to set the[J

line 92: "                         unaryTagsStack to its default value for html.[J

line 93: "[J

line 94: " b:closetag_disable_synID  Define this to disable comment checking if tag[J

line 95: "                         closing is too slow.  This can be set or unset[J

line 96: "                         without having to source again.[J

line 97: "[J

line 98: " Changelog:[J

line 99: " May 24, 2005 Tuesday[J

line 100: "   * Changed function names to be script-local to avoid conflicts with other[J

line 101: "     scripts' stack implementations.[J

line 102: "[J

line 103: " June 07, 2001 Thursday[J

line 104: "   * Added comment handling.  Currently relies on synID, so if syn sync[J

line 105: "     minlines is small, the chance for failure is high, but if minlines is[J

line 106: "     large, tagclosing becomes rather slow...[J

line 107: "[J

line 108: "   * Changed normal mode closetag mapping to use <C-R> in insert mode[J

line 109: "     rather than p in normal mode.  This has 2 implications:[J

line 110: "       - Tag closing no longer clobbers the unnamed register[J

line 111: "       - When tag closing fails or finds no match, no longer adds to the undo[J

line 112: "         buffer for recent vim 6.0 development versions.[J

line 113: "       - However, clears the last message when closing tags in normal mode[J

line 114: "[J

line 115: "   * Changed the closetag_html_style variable to be buffer-local rather than[J

line 116: "     global.[J

line 117: "[J

line 118: "   * Expanded documentation[J

line 119: [J

line 120: "------------------------------------------------------------------------------[J

line 121: " User configurable settings[J

line 122: "------------------------------------------------------------------------------[J

line 123: [J

line 124: " if html, don't close certain tags.  Works best if ignorecase is set.[J

line 125: " otherwise, capitalize these elements according to your html editing style[J

line 126: if !exists("b:unaryTagsStack") || exists("b:closetag_html_style")[J

line 127:     if &filetype == "html" || exists("b:closetag_html_style")[J

line 128: ^Ilet b:unaryTagsStack="area base br dd dt hr img input link meta param"[J

line 129:     else " for xsl and xsl[J

line 130: ^Ilet b:unaryTagsStack=""[J

line 131:     endif[J

line 132: endif[J

line 133: [J

line 134: " Has this already been loaded?[J

line 135: if exists("loaded_closetag")[J

line 136:     finish[J

line 137: endif[J

line 138: let loaded_closetag=1[J

line 139: [J

line 140: " set up mappings for tag closing[J

line 141: inoremap </ <C-R>=GetCloseTag()<CR>[J

line 142: map <C-_> a<C-_><ESC>[J

line 143: [J

line 144: "------------------------------------------------------------------------------[J

line 145: " Tag closer - uses the stringstack implementation below[J

line 146: "------------------------------------------------------------------------------[J

line 147: [J

line 148: " Returns the most recent unclosed tag-name[J

line 149: " (ignores tags in the variable referenced by a:unaryTagsStack)[J

line 150: function! GetLastOpenTag(unaryTagsStack)[J

line 225: [J

line 226: " Returns closing tag for most recent unclosed tag, respecting the[J

line 227: " current setting of b:unaryTagsStack for tags that should not be closed[J

line 228: function! GetCloseTag()[J

line 243: [J

line 244: " return 1 if the cursor is in a syntactically identified comment field[J

line 245: " (fails for empty lines: always returns not-in-comment)[J

line 246: function! s:InComment()[J

line 249: [J

line 250: " return 1 if the position specified is in a syntactically identified comment field[J

line 251: function! s:InCommentAt(line, col)[J

line 254: [J

line 255: "------------------------------------------------------------------------------[J

line 256: " String Stacks[J

line 257: "------------------------------------------------------------------------------[J

line 258: " These are strings of whitespace-separated elements, matched using the \< and[J

line 259: " \> patterns after setting the iskeyword option.[J

line 260: "[J

line 261: " The sname argument should contain a symbolic reference to the stack variable[J

line 262: " on which method should operate on (i.e., sname should be a string containing[J

line 263: " a fully qualified (ie: g:, b:, etc) variable name.)[J

line 264: [J

line 265: " Helper functions[J

line 266: function! s:SetKeywords()[J

line 270: [J

line 271: function! s:RestoreKeywords()[J

line 274: [J

line 275: " Push el onto the stack referenced by sname[J

line 276: function! s:Push(el, sname)[J

line 283: [J

line 284: " Check whether the stack is empty[J

line 285: function! s:EmptystackP(sname)[J

line 293: [J

line 294: " Return 1 if el is in stack sname, else 0.[J

line 295: function! s:Instack(el, sname)[J

line 306: [J

line 307: " Return the first element in the stack[J

line 308: function! s:Peekstack(sname)[J

line 315: [J

line 316: " Remove and return the first element in the stack[J

line 317: function! s:Pop(sname)[J

line 331: [J

line 332: function! s:Clearstack(sname)[J

line 335: [J

line 336:     """""""""""""""     add by kenshin      """"""""""""""""[J

line 337:     "to store cursor Position[J

line 338:     let s:cursorPos = 0[J

line 339:     "support </ close tag[J

line 340:     function! EasyCloseTag()[J

line 355: [J

line 356:     "set cursor to <tag>#cursor#</tag>[J

line 357:     function! SetCursor()[J

line 365: [J

line 366:     "set up key '/' to trigger closeTag and setCursor function[J

line 367:     inoremap <C+/> <C-R>=EasyCloseTag()<CR><C-R>=SetCursor()<CR>[J

finished sourcing /Users/tsen/.vim/bundle/closetag.vim/plugin/closetag.vim[J
Searching for "/Users/tsen/.vim/bundle/tagbar/plugin/**/*.vim"[J
chdir(/Users/tsen/.vim/bundle/tagbar/plugin)[J
fchdir() to previous dir[J
sourcing "/Users/tsen/.vim/bundle/tagbar/plugin/tagbar.vim"[J
line 1: " ============================================================================[J

line 2: " File:        tagbar.vim[J

line 3: " Description: List the current file's tags in a sidebar, ordered by class etc[J

line 4: " Author:      Jan Larres <jan@majutsushi.net>[J

line 5: " Licence:     Vim licence[J

line 6: " Website:     https://preservim.github.io/tagbar[J

line 7: " Version:     3.1.1[J

line 8: " Note:        This plugin was heavily inspired by the 'Taglist' plugin by[J

line 9: "              Yegappan Lakshmanan and uses a small amount of code from it.[J

line 10: "[J

line 11: " Original taglist copyright notice:[J

line 12: "              Permission is hereby granted to use and distribute this code,[J

line 13: "              with or without modifications, provided that this copyright[J

line 14: "              notice is copied with it. Like anything else that's free,[J

line 15: "              taglist.vim is provided *as is* and comes with no warranty of[J

line 16: "              any kind, either expressed or implied. In no event will the[J

line 17: "              copyright holder be liable for any damamges resulting from the[J

line 18: "              use of this software.[J

line 19: " ============================================================================[J

line 20: [J

line 21: scriptencoding utf-8[J

line 22: [J

line 23: if &compatible || exists('g:loaded_tagbar')[J

line 24:     finish[J

line 25: endif[J

line 26: [J

line 27: " Basic init {{{1[J

line 28: [J

line 29: if v:version < 700[J

line 30:     echohl WarningMsg[J

line 31:     echomsg 'Tagbar: Vim version is too old, Tagbar requires at least 7.0'[J

line 32:     echohl None[J

line 33:     finish[J

line 34: endif[J

line 35: [J

line 36: if v:version == 700 && !has('patch167')[J

line 37:     echohl WarningMsg[J

line 38:     echomsg 'Tagbar: Vim versions lower than 7.0.167 have a bug' 'that prevents this version of Tagbar from working.' 'Please use the alternate version posted on the website.'[J

line 41:     echohl None[J

line 42:     finish[J

line 43: endif[J

line 44: [J

line 45: function! s:init_var(var, value) abort[J

line 50: [J

line 51: function! s:setup_options() abort[J

line 134: call s:setup_options()[J

calling <SNR>43_setup_options[J()

line 1:     if exists('g:tagbar_position')[J

line 2:         " Map older deprecated values to correct values[J

line 3:         if g:tagbar_position ==# 'top'[J

line 4:             let g:tagbar_position = 'leftabove'[J

line 5:         elseif g:tagbar_position ==# 'bottom'[J

line 6:             let g:tagbar_position = 'rightbelow'[J

line 7:         elseif g:tagbar_position ==# 'left'[J

line 8:             let g:tagbar_position = 'topleft vertical'[J

line 9:         elseif g:tagbar_position ==# 'right'[J

line 10:             let g:tagbar_position = 'botright vertical'[J

line 11:         endif[J

line 12:         if g:tagbar_position !~# 'vertical'[J

line 13:             let previewwin_pos = 'rightbelow vertical'[J

line 14:         else[J

line 15:             let previewwin_pos = 'topleft'[J

line 16:         endif[J

line 17:         let default_pos = g:tagbar_position[J

line 18:     else[J

line 19:         if exists('g:tagbar_vertical') && g:tagbar_vertical > 0[J

line 20:             let previewwin_pos = 'rightbelow vertical'[J

line 21:             if exists('g:tagbar_left') && g:tagbar_left[J

line 22:                 let default_pos = 'leftabove'[J

line 23:             else[J

line 24:                 let default_pos = 'rightbelow'[J

line 25:             endif[J

line 26:             let g:tagbar_height = g:tagbar_vertical[J

line 27:         elseif exists('g:tagbar_left') && g:tagbar_left[J

line 28:             let previewwin_pos = 'topleft'[J

line 29:             let default_pos = 'topleft vertical'[J

line 30:         else[J

line 31:             let previewwin_pos = 'topleft'[J

line 32:             let default_pos = 'botright vertical'[J

line 33:         endif[J

line 34:     endif[J

line 35:     let options = [ ['autoclose', 0], ['autoclose_netrw', 0], ['autofocus', 0], ['autopreview', 0], ['autoshowtag', 0], ['case_insensitive', 0], ['compact', 0], ['expand', 0], ['file_size_limit', 0], ['foldlevel', 99], ['hide_nonpublic', 0], ['height', 10], ['indent', 2], ['jump_offset', 0], ['jump_lazy_scroll', 0], ['left', 0], ['help_visibility', 0], ['highlight_follow_insert', 0], ['highlight_method', 'nearest-stl'], ['ignore_anonymous', 0], ['no_autocmds', 0], ['position', default_pos], ['previewwin_pos', previewwin_pos], ['scopestrs', {}], ['scrolloff', 0], ['show_balloon', 1], ['show_data_type', 0], ['show_visibility', 1], ['show_linenumbers', 0], ['show_tag_count', 0], ['show_tag_linenumbers', 0], ['singleclick', 0], ['sort', 1], ['systemenc', &encoding], ['vertical', 0], ['width', 40], ['zoomwidth', 1], ['silent', 0], ['use_cache', 1], ['wrap', 0], ][J

line 77: [J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('autoclose', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_autoclose = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('autoclose_netrw', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_autoclose_netrw = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('autofocus', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_autofocus = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('autopreview', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_autopreview = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('autoshowtag', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_autoshowtag = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('case_insensitive', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_case_insensitive = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('compact', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_compact = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('expand', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_expand = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('file_size_limit', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_file_size_limit = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('foldlevel', 99)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_foldlevel = 99[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('hide_nonpublic', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_hide_nonpublic = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('height', 10)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_height = 10[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('indent', 2)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_indent = 2[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('jump_offset', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_jump_offset = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('jump_lazy_scroll', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_jump_lazy_scroll = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('left', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_left = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('help_visibility', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_help_visibility = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('highlight_follow_insert', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_highlight_follow_insert = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('highlight_method', 'nearest-stl')

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_highlight_method = 'nearest-stl'[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('ignore_anonymous', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_ignore_anonymous = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('no_autocmds', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_no_autocmds = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('position', 'botright vertical')

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_position = 'botright vertical'[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('previewwin_pos', 'topleft')

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_previewwin_pos = 'topleft'[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('scopestrs', {})

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_scopestrs = {}[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('scrolloff', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_scrolloff = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('show_balloon', 1)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_show_balloon = 1[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('show_data_type', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_show_data_type = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('show_visibility', 1)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_show_visibility = 1[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('show_linenumbers', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_show_linenumbers = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('show_tag_count', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_show_tag_count = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('show_tag_linenumbers', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_show_tag_linenumbers = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('singleclick', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_singleclick = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('sort', 1)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_sort = 1[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('systemenc', 'utf-8')

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_systemenc = 'utf-8'[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('vertical', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_vertical = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('width', 40)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_width = 40[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('zoomwidth', 1)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_zoomwidth = 1[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('silent', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_silent = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('use_cache', 1)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_use_cache = 1[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

calling <SNR>43_init_var[J('wrap', 0)

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_wrap = 0[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_options[J

line 80:         unlet val[J

line 81:     endfor[J

line 78:     for [opt, val] in options[J

line 79:         call s:init_var(opt, val)[J

line 80:         unlet val[J

line 81:     endfor[J

<SNR>43_setup_options returning #0[J

continuing in /Users/tsen/.vim/bundle/tagbar/plugin/tagbar.vim[J

line 135: [J

line 136: if !exists('g:tagbar_iconchars')[J

line 137:     if has('multi_byte') && has('unix') && &encoding ==# 'utf-8' && (!exists('+termencoding') || empty(&termencoding) || &termencoding ==# 'utf-8')[J

line 139:         let g:tagbar_iconchars = ['▸', '▾'][J

line 140:     else[J

line 141:         let g:tagbar_iconchars = ['+', '-'][J

line 142:     endif[J

line 143: endif[J

line 144: [J

line 145: function! s:setup_keymaps() abort[J

line 179: call s:setup_keymaps()[J

calling <SNR>43_setup_keymaps[J()

line 1:     let keymaps = [ ['jump',          '<CR>'], ['preview',       'p'], ['previewwin',    'P'], ['nexttag',       '<C-N>'], ['prevtag',       '<C-P>'], ['showproto',     '<Space>'], ['hidenonpublic', 'v'], ['openfold',      ['+', '<kPlus>', 'zo']], ['closefold',     ['-', '<kMinus>', 'zc']], ['togglefold',    ['o', 'za']], ['openallfolds',  ['*', '<kMultiply>', 'zR']], ['closeallfolds', ['=', 'zM']], ['incrementfolds',  ['zr']], ['decrementfolds',  ['zm']], ['nextfold',      'zj'], ['prevfold',      'zk'], ['togglesort',            's'], ['togglecaseinsensitive', 'i'], ['toggleautoclose',       'c'], ['togglepause',           't'], ['zoomwin',               'x'], ['close',                 'q'], ['help',                  ['<F1>', '?']], ][J

line 28: [J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_jump', '<CR>')

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_jump = '<CR>'[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_preview', 'p')

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_preview = 'p'[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_previewwin', 'P')

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_previewwin = 'P'[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_nexttag', '<C-N>')

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_nexttag = '<C-N>'[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_prevtag', '<C-P>')

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_prevtag = '<C-P>'[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_showproto', '<Space>')

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_showproto = '<Space>'[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_hidenonpublic', 'v')

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_hidenonpublic = 'v'[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_openfold', ['+', '<kPlus>', 'zo'])

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_openfold = ['+', '<kPlus>', 'zo'][J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_closefold', ['-', '<kMinus>', 'zc'])

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_closefold = ['-', '<kMinus>', 'zc'][J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_togglefold', ['o', 'za'])

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_togglefold = ['o', 'za'][J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_openallfolds', ['*', '<kMultiply>', 'zR'])

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_openallfolds = ['*', '<kMultiply>', 'zR'][J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_closeallfolds', ['=', 'zM'])

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_closeallfolds = ['=', 'zM'][J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_incrementfolds', ['zr'])

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_incrementfolds = ['zr'][J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_decrementfolds', ['zm'])

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_decrementfolds = ['zm'][J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_nextfold', 'zj')

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_nextfold = 'zj'[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_prevfold', 'zk')

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_prevfold = 'zk'[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_togglesort', 's')

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_togglesort = 's'[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_togglecaseinsensitive', 'i')

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_togglecaseinsensitive = 'i'[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_toggleautoclose', 'c')

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_toggleautoclose = 'c'[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_togglepause', 't')

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_togglepause = 't'[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_zoomwin', 'x')

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_zoomwin = 'x'[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_close', 'q')

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_close = 'q'[J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

calling <SNR>43_init_var[J('map_help', ['<F1>', '?'])

line 1:     if !exists('g:tagbar_' . a:var)[J

line 2:         execute 'let g:tagbar_' . a:var . ' = ' . string(a:value)[J

line 2: let g:tagbar_map_help = ['<F1>', '?'][J

line 3:     endif[J

<SNR>43_init_var returning #0[J

continuing in <SNR>43_setup_keymaps[J

line 31:         unlet key[J

line 32:     endfor[J

line 29:     for [map, key] in keymaps[J

line 30:         call s:init_var('map_' . map, key)[J

line 31:         unlet key[J

line 32:     endfor[J

<SNR>43_setup_keymaps returning #0[J

continuing in /Users/tsen/.vim/bundle/tagbar/plugin/tagbar.vim[J

line 180: [J

line 181: augroup TagbarSession[J

line 182:     autocmd![J

line 183:     autocmd SessionLoadPost * nested call tagbar#RestoreSession()[J

line 184: augroup END[J

line 185: [J

line 186: " Commands {{{1[J

line 187: command! -nargs=? Tagbar              call tagbar#ToggleWindow(<f-args>)[J

line 188: command! -nargs=? TagbarToggle        call tagbar#ToggleWindow(<f-args>)[J

line 189: command! -nargs=? TagbarOpen          call tagbar#OpenWindow(<f-args>)[J

line 190: command! -nargs=0 TagbarOpenAutoClose call tagbar#OpenWindow('fcj')[J

line 191: command! -nargs=0 TagbarClose         call tagbar#CloseWindow()[J

line 192: command! -nargs=1 -bang TagbarSetFoldlevel  call tagbar#SetFoldLevel(<args>, <bang>0)[J

line 193: command! -nargs=0 TagbarShowTag       call tagbar#highlighttag(1, 1)[J

line 194: command! -nargs=* TagbarCurrentTag    echo tagbar#currenttag('%s', 'No current tag', <f-args>)[J

line 195: command! -nargs=1 TagbarGetTypeConfig call tagbar#gettypeconfig(<f-args>)[J

line 196: command! -nargs=? TagbarDebug         call tagbar#debug#start_debug(<f-args>)[J

line 197: command! -nargs=0 TagbarDebugEnd      call tagbar#debug#stop_debug()[J

line 198: command! -nargs=0 TagbarTogglePause   call tagbar#toggle_pause()[J

line 199: command! -nargs=0 TagbarForceUpdate   call tagbar#ForceUpdate()[J

line 200: command! -nargs=0 TagbarJump   call tagbar#jump()[J

line 201: command! -nargs=0 TagbarJumpPrev      call tagbar#jumpToNearbyTag(-1)[J

line 202: command! -nargs=0 TagbarJumpNext      call tagbar#jumpToNearbyTag(1)[J

line 203: [J

line 204: [J

line 205: " Modeline {{{1[J

line 206: " vim: ts=8 sw=4 sts=4 et foldenable foldmethod=marker foldcolumn=1[J

finished sourcing /Users/tsen/.vim/bundle/tagbar/plugin/tagbar.vim[J
Searching for "/usr/local/share/vim/vimfiles/plugin/**/*.vim"[J
Searching for "/usr/local/share/vim/vim90/plugin/**/*.vim"[J
chdir(/usr/local/share/vim/vim90/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim90/plugin/getscriptPlugin.vim"[J
line 1: " ---------------------------------------------------------------------[J

line 2: " getscriptPlugin.vim[J

line 3: "  Author:^ICharles E. Campbell[J

line 4: "  Date:^INov 29, 2013[J

line 5: "  Installing:^I:help glvs-install[J

line 6: "  Usage:^I:help glvs[J

line 7: "[J

line 8: " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim[J

line 9: "[J

line 10: " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let[J

line 11: " all the peoples praise Him."[J

line 12: " ---------------------------------------------------------------------[J

line 13: " Initialization:^I{{{1[J

line 14: " if you're sourcing this file, surely you can't be[J

line 15: " expecting vim to be in its vi-compatible mode[J

line 16: if exists("g:loaded_getscriptPlugin")[J

line 17:  finish[J

line 18: endif[J

line 19: if &cp[J

line 20:  if &verbose[J

line 21:   echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"[J

line 22:  endif[J

line 23:  finish[J

line 24: endif[J

line 25: let g:loaded_getscriptPlugin = "v36"[J

line 26: let s:keepcpo                = &cpo[J

line 27: set cpo&vim[J

line 28: [J

line 29: " ---------------------------------------------------------------------[J

line 30: "  Public Interface: {{{1[J

line 31: com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()[J

line 32: com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()[J

line 33: sil! com    -nargs=0 GLVS                call getscript#GetLatestVimScripts()[J

line 34: [J

line 35: " ---------------------------------------------------------------------[J

line 36: " Restore Options: {{{1[J

line 37: let &cpo= s:keepcpo[J

line 38: unlet s:keepcpo[J

line 39: [J

line 40: " ---------------------------------------------------------------------[J

line 41: " vim: ts=8 sts=2 fdm=marker nowrap[J

finished sourcing /usr/local/share/vim/vim90/plugin/getscriptPlugin.vim[J
chdir(/usr/local/share/vim/vim90/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim90/plugin/gzip.vim"[J
line 1: " Vim plugin for editing compressed files.[J

line 2: " Maintainer: Bram Moolenaar <Bram@vim.org>[J

line 3: " Last Change: 2016 Oct 30[J

line 4: [J

line 5: " Exit quickly when:[J

line 6: " - this plugin was already loaded[J

line 7: " - when 'compatible' is set[J

line 8: " - some autocommands are already taking care of compressed files[J

line 9: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")[J

line 10:   finish[J

line 11: endif[J

line 12: let loaded_gzip = 1[J

line 13: [J

line 14: augroup gzip[J

line 15:   " Remove all gzip autocommands[J

line 16:   au![J

line 17: [J

line 18:   " Enable editing of gzipped files.[J

line 19:   " The functions are defined in autoload/gzip.vim.[J

line 20:   "[J

line 21:   " Set binary mode before reading the file.[J

line 22:   " Use "gzip -d", gunzip isn't always available.[J

line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst,*.br,*.lzo setlocal bin[J

line 24:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")[J

line 25:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")[J

line 26:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")[J

line 27:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")[J

line 28:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")[J

line 29:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")[J

line 30:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")[J

line 31:   autocmd BufReadPost,FileReadPost^I*.br call gzip#read("brotli -d --rm")[J

line 32:   autocmd BufReadPost,FileReadPost^I*.lzo call gzip#read("lzop -d -U")[J

line 33:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")[J

line 34:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")[J

line 35:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")[J

line 36:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")[J

line 37:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")[J

line 38:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")[J

line 39:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")[J

line 40:   autocmd BufWritePost,FileWritePost^I*.br  call gzip#write("brotli --rm")[J

line 41:   autocmd BufWritePost,FileWritePost^I*.lzo  call gzip#write("lzop -U")[J

line 42:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")[J

line 43:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")[J

line 44:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")[J

line 45:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")[J

line 46:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")[J

line 47:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")[J

line 48:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")[J

line 49:   autocmd FileAppendPre^I^I^I*.br call gzip#appre("brotli -d --rm")[J

line 50:   autocmd FileAppendPre^I^I^I*.lzo call gzip#appre("lzop -d -U")[J

line 51:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")[J

line 52:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")[J

line 53:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")[J

line 54:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")[J

line 55:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")[J

line 56:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")[J

line 57:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")[J

line 58:   autocmd FileAppendPost^I^I*.br call gzip#write("brotli --rm")[J

line 59:   autocmd FileAppendPost^I^I*.lzo call gzip#write("lzop -U")[J

line 60: augroup END[J

finished sourcing /usr/local/share/vim/vim90/plugin/gzip.vim[J
chdir(/usr/local/share/vim/vim90/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim90/plugin/logiPat.vim"[J
line 1: " LogiPat: Boolean logical pattern matcher[J

line 2: "   Author:  Charles E. Campbell[J

line 3: "   Date:    Apr 04, 2016[J

line 4: "   Version: 4[J

line 5: "   Purpose: to do Boolean-logic based regular expression pattern matching[J

line 6: " Copyright:    Copyright (C) 1999-2011 Charles E. Campbell {{{1[J

line 7: "               Permission is hereby granted to use and distribute this code,[J

line 8: "               with or without modifications, provided that this copyright[J

line 9: "               notice is copied with it. Like most anything else that's free,[J

line 10: "               LogiPat.vim is provided *as is* and comes with no warranty[J

line 11: "               of any kind, either expressed or implied. By using this[J

line 12: "               plugin, you agree that in no event will the copyright[J

line 13: "               holder be liable for any damages resulting from the use[J

line 14: "               of this software.[J

line 15: "[J

line 16: "   Usage: {{{1[J

line 17: "       :LogiPat ...[J

line 18: "[J

line 19: "         Boolean logic supported:[J

line 20: "            () grouping operators[J

line 21: "            !  not the following pattern[J

line 22: "            |  logical or[J

line 23: "            &  logical and[J

line 24: "            "..pattern.."[J

line 25: "^IExample: {{{1[J

line 26: "^I^I:LogiPat !("january"|"february")[J

line 27: "^I^I  would match all strings not containing the strings january[J

line 28: "^I^I  or february[J

line 29: "^IGetLatestVimScripts: 1290 1 :AutoInstall: LogiPat.vim[J

line 30: "[J

line 31: "  Behold, you will conceive in your womb, and bring forth a son, {{{1[J

line 32: "  and will call his name Jesus. He will be great, and will be[J

line 33: "  called the Son of the Most High. The Lord God will give him the[J

line 34: "  throne of his father, David, and he will reign over the house of[J

line 35: "  Jacob forever. There will be no end to his kingdom. (Luke 1:31-33 WEB)[J

line 36: [J

line 37: " ---------------------------------------------------------------------[J

line 38: " Load Once: {{{1[J

line 39: if &cp || exists("loaded_logiPat")[J

line 40:  finish[J

line 41: endif[J

line 42: let g:loaded_logiPat = "v4"[J

line 43: let s:keepcpo        = &cpo[J

line 44: set cpo&vim[J

line 45: "DechoRemOn[J

line 46: [J

line 47: " ---------------------------------------------------------------------[J

line 48: " Public Interface: {{{1[J

line 49: com!     -nargs=* LogiPat^I^Icall   LogiPat(<q-args>,1)[J

line 50: sil! com -nargs=* LP^I^I^Icall   LogiPat(<q-args>,1)[J

line 51: sil! com -nargs=* LPR^I^I^Icall   LogiPat(<q-args>,1,"r")[J

line 52: com!     -nargs=+ LPE^I^I^Iechomsg LogiPat(<q-args>)[J

line 53: com!     -nargs=+ LogiPatFlags^Ilet  s:LogiPatFlags="<args>"[J

line 54: sil! com -nargs=+ LPF^I^I^Ilet  s:LogiPatFlags="<args>"[J

line 55: [J

line 56: " =====================================================================[J

line 57: " Functions: {{{1[J

line 58: [J

line 59: " ---------------------------------------------------------------------[J

line 60: " LogiPat: this function interprets the boolean-logic pattern {{{2[J

line 61: fun! LogiPat(pat,...)[J

line 146: [J

line 147: " ---------------------------------------------------------------------[J

line 148: " s:String: Vim6.4 doesn't have string() {{{2[J

line 149: func! s:String(str)[J

line 152: [J

line 153: " ---------------------------------------------------------------------[J

line 154: " LP_PatPush: {{{2[J

line 155: fun! s:LP_PatPush(pat)[J

line 162: [J

line 163: " ---------------------------------------------------------------------[J

line 164: " LP_PatPop: pop a number/variable from LogiPat's pattern stack {{{2[J

line 165: fun! s:LP_PatPop(lookup)[J

line 178: [J

line 179: " ---------------------------------------------------------------------[J

line 180: " LP_OpPush: {{{2[J

line 181: fun! s:LP_OpPush(op)[J

line 232: [J

line 233: " ---------------------------------------------------------------------[J

line 234: " LP_Execute: execute operators from opstack using pattern stack {{{2[J

line 235: fun! s:LP_Execute(preclvl)[J

line 265: [J

line 266: " ---------------------------------------------------------------------[J

line 267: " LP_Not: writes a logical-not for a pattern {{{2[J

line 268: fun! s:LP_Not(pat)[J

line 279: [J

line 280: " ---------------------------------------------------------------------[J

line 281: " LP_Or: writes a logical-or branch using two patterns {{{2[J

line 282: fun! s:LP_Or(pat1,pat2)[J

line 288: [J

line 289: " ---------------------------------------------------------------------[J

line 290: " LP_And: writes a logical-and concat using two patterns {{{2[J

line 291: fun! s:LP_And(pat1,pat2)[J

line 297: [J

line 298: " ---------------------------------------------------------------------[J

line 299: " StackLook: {{{2[J

line 300: fun! s:StackLook(description)[J

line 334: [J

line 335: " ---------------------------------------------------------------------[J

line 336: "  Cleanup And Modeline: {{{1[J

line 337: let &cpo= s:keepcpo[J

line 338: unlet s:keepcpo[J

line 339: " vim: ts=4 fdm=marker[J

finished sourcing /usr/local/share/vim/vim90/plugin/logiPat.vim[J
chdir(/usr/local/share/vim/vim90/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim90/plugin/manpager.vim"[J
line 1: " Vim plugin for using Vim as manpager.[J

line 2: " Maintainer: Enno Nagel <ennonagel+vim@gmail.com>[J

line 3: " Last Change: 2022 Oct 17[J

line 4: [J

line 5: if exists('g:loaded_manpager_plugin')[J

line 6:   finish[J

line 7: endif[J

line 8: let g:loaded_manpager_plugin = 1[J

line 9: [J

line 10: " Set up the current buffer (likely read from stdin) as a manpage[J

line 11: command MANPAGER call s:ManPager()[J

line 12: [J

line 13: function s:ManPager()[J

finished sourcing /usr/local/share/vim/vim90/plugin/manpager.vim[J
chdir(/usr/local/share/vim/vim90/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim90/plugin/matchparen.vim"[J
line 1: " Vim plugin for showing matching parens[J

line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>[J

line 3: " Last Change: 2022 Dec 01[J

line 4: [J

line 5: " Exit quickly when:[J

line 6: " - this plugin was already loaded (or disabled)[J

line 7: " - when 'compatible' is set[J

line 8: if exists("g:loaded_matchparen") || &cp[J

line 9:   finish[J

line 10: endif[J

line 11: let g:loaded_matchparen = 1[J

line 12: [J

line 13: if !exists("g:matchparen_timeout")[J

line 14:   let g:matchparen_timeout = 300[J

line 15: endif[J

line 16: if !exists("g:matchparen_insert_timeout")[J

line 17:   let g:matchparen_insert_timeout = 60[J

line 18: endif[J

line 19: [J

line 20: augroup matchparen[J

line 21:   " Replace all matchparen autocommands[J

line 22:   autocmd! CursorMoved,CursorMovedI,WinEnter,BufWinEnter,WinScrolled * call s:Highlight_Matching_Pair()[J

line 23:   autocmd! WinLeave,BufLeave * call s:Remove_Matches()[J

line 24:   if exists('##TextChanged')[J

line 25:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()[J

line 26:   endif[J

line 27: augroup END[J

line 28: [J

line 29: " Skip the rest if it was already done.[J

line 30: if exists("*s:Highlight_Matching_Pair")[J

line 31:   finish[J

line 32: endif[J

line 33: [J

line 34: let s:cpo_save = &cpo[J

line 35: set cpo-=C[J

line 36: [J

line 37: " The function that is invoked (very often) to define a ":match" highlighting[J

line 38: " for any matching paren.[J

line 39: func s:Highlight_Matching_Pair()[J

line 195: [J

line 196: func s:Remove_Matches()[J

line 202: [J

line 203: [J

line 204: " Define commands that will disable and enable the plugin.[J

line 205: command DoMatchParen call s:DoMatchParen()[J

line 206: command NoMatchParen call s:NoMatchParen()[J

line 207: [J

line 208: func s:NoMatchParen()[J

line 215: [J

line 216: func s:DoMatchParen()[J

line 222: [J

line 223: let &cpo = s:cpo_save[J

line 224: unlet s:cpo_save[J

finished sourcing /usr/local/share/vim/vim90/plugin/matchparen.vim[J
chdir(/usr/local/share/vim/vim90/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim90/plugin/netrwPlugin.vim"[J
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network[J

line 2: "            PLUGIN SECTION[J

line 3: " Date:^I^IFeb 09, 2021[J

line 4: " Maintainer:^ICharles E Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>[J

line 5: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim[J

line 6: " Copyright:    Copyright (C) 1999-2021 Charles E. Campbell {{{1[J

line 7: "               Permission is hereby granted to use and distribute this code,[J

line 8: "               with or without modifications, provided that this copyright[J

line 9: "               notice is copied with it. Like anything else that's free,[J

line 10: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided[J

line 11: "               *as is* and comes with no warranty of any kind, either[J

line 12: "               expressed or implied. By using this plugin, you agree that[J

line 13: "               in no event will the copyright holder be liable for any damages[J

line 14: "               resulting from the use of this software.[J

line 15: "[J

line 16: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1[J

line 17: "  (James 1:22 RSV)[J

line 18: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-[J

line 19: " Load Once: {{{1[J

line 20: if &cp || exists("g:loaded_netrwPlugin")[J

line 21:  finish[J

line 22: endif[J

line 23: let g:loaded_netrwPlugin = "v171"[J

line 24: let s:keepcpo = &cpo[J

line 25: set cpo&vim[J

line 26: "DechoRemOn[J

line 27: [J

line 28: " ---------------------------------------------------------------------[J

line 29: " Public Interface: {{{1[J

line 30: [J

line 31: " Local Browsing Autocmds: {{{2[J

line 32: augroup FileExplorer[J

line 33:  au![J

line 34:  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif[J

line 35:  au BufEnter *^Isil call s:LocalBrowse(expand("<amatch>"))[J

line 36:  au VimEnter *^Isil call s:VimEnter(expand("<amatch>"))[J

line 37:  if has("win32") || has("win95") || has("win64") || has("win16")[J

line 38:   au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))[J

line 39:  endif[J

line 40: augroup END[J

line 41: [J

line 42: " Network Browsing Reading Writing: {{{2[J

line 43: augroup Network[J

line 44:  au![J

line 45:  au BufReadCmd   file://*^I^I^I^I^I^I^I^I^I^I^Icall netrw#FileUrlEdit(expand("<amatch>"))[J

line 46:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))[J

line 47:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))[J

line 48:  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))[J

line 49:  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))[J

line 50:  try[J

line 51:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))[J

line 52:  catch /^Vim\%((\a\+)\)\=:E216/[J

line 53:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))[J

line 54:  endtry[J

line 55: augroup END[J

line 56: [J

line 57: " Commands: :Nread, :Nwrite, :NetUserPass {{{2[J

line 58: com! -count=1 -nargs=*^INread^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)[J

line 59: com! -range=% -nargs=*^INwrite^I^Ilet s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)[J

line 60: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)[J

line 61: com! -nargs=*^I        Nsource^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)[J

line 62: com! -nargs=?^I^INtree^I^Icall netrw#SetTreetop(1,<q-args>)[J

line 63: [J

line 64: " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2[J

line 65: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)[J

line 66: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)[J

line 67: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)[J

line 68: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)[J

line 69: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)[J

line 70: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)[J

line 71: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)[J

line 72: com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore^Icall netrw#Lexplore(<count>,<bang>0,<q-args>)[J

line 73: [J

line 74: " Commands: NetrwSettings {{{2[J

line 75: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()[J

line 76: com! -bang^INetrwClean^Icall netrw#Clean(<bang>0)[J

line 77: [J

line 78: " Maps:[J

line 79: if !exists("g:netrw_nogx")[J

line 80:  if maparg('gx','n') == ""[J

line 81:   if !hasmapto('<Plug>NetrwBrowseX')[J

line 82:    nmap <unique> gx <Plug>NetrwBrowseX[J

line 83:   endif[J

line 84:   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(netrw#GX(),netrw#CheckIfRemote(netrw#GX()))<cr>[J

line 85:  endif[J

line 86:  if maparg('gx','x') == ""[J

line 87:   if !hasmapto('<Plug>NetrwBrowseXVis')[J

line 88:    xmap <unique> gx <Plug>NetrwBrowseXVis[J

line 89:   endif[J

line 90:   xno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>[J

line 91:  endif[J

line 92: endif[J

line 93: if exists("g:netrw_usetab") && g:netrw_usetab[J

line 94:  if maparg('<c-tab>','n') == ""[J

line 95:   nmap <unique> <c-tab> <Plug>NetrwShrink[J

line 96:  endif[J

line 97:  nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>[J

line 98: endif[J

line 99: [J

line 100: " ---------------------------------------------------------------------[J

line 101: " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2[J

line 102: fun! s:LocalBrowse(dirname)[J

line 146: [J

line 147: " ---------------------------------------------------------------------[J

line 148: " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2[J

line 149: "             Its purpose: to look over all windows and run s:LocalBrowse() on[J

line 150: "             them, which checks if they're directories and will create a directory[J

line 151: "             listing when appropriate.[J

line 152: "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()[J

line 153: "             has already been called.[J

line 154: fun! s:VimEnter(dirname)[J

line 174: [J

line 175: " ---------------------------------------------------------------------[J

line 176: " NetrwStatusLine: {{{1[J

line 177: fun! NetrwStatusLine()[J

line 188: [J

line 189: " ------------------------------------------------------------------------[J

line 190: " NetUserPass: set username and password for subsequent ftp transfer {{{1[J

line 191: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password[J

line 192: "^I    :call NetUserPass("uid")^I^I-- will prompt for password[J

line 193: "^I    :call NetUserPass("uid","password") -- sets global userid and password[J

line 194: fun! NetUserPass(...)[J

line 218: [J

line 219: " ------------------------------------------------------------------------[J

line 220: " Modelines And Restoration: {{{1[J

line 221: let &cpo= s:keepcpo[J

line 222: unlet s:keepcpo[J

line 223: " vim:ts=8 fdm=marker[J

finished sourcing /usr/local/share/vim/vim90/plugin/netrwPlugin.vim[J
chdir(/usr/local/share/vim/vim90/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim90/plugin/rrhelper.vim"[J
line 1: " Vim plugin with helper function(s) for --remote-wait[J

line 2: " Maintainer: Flemming Madsen <fma@cci.dk>[J

line 3: " Last Change: 2008 May 29[J

line 4: [J

line 5: " Has this already been loaded?[J

line 6: if exists("loaded_rrhelper") || !has("clientserver")[J

line 7:   finish[J

finished sourcing /usr/local/share/vim/vim90/plugin/rrhelper.vim[J
chdir(/usr/local/share/vim/vim90/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim90/plugin/spellfile.vim"[J
line 1: " Vim plugin for downloading spell files[J

line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>[J

line 3: " Last Change: 2006 Feb 01[J

line 4: [J

line 5: " Exit quickly when:[J

line 6: " - this plugin was already loaded[J

line 7: " - when 'compatible' is set[J

line 8: " - some autocommands are already taking care of spell files[J

line 9: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")[J

line 10:   finish[J

line 11: endif[J

line 12: let loaded_spellfile_plugin = 1[J

line 13: [J

line 14: " The function is in the autoload directory.[J

line 15: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))[J

finished sourcing /usr/local/share/vim/vim90/plugin/spellfile.vim[J
chdir(/usr/local/share/vim/vim90/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim90/plugin/tarPlugin.vim"[J
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles[J

line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>[J

line 3: " Modified by Charles E. Campbell[J

line 4: " Distributed under the GNU General Public License.[J

line 5: "[J

line 6: " Updates are available from <http://michael.toren.net/code/>.  If you[J

line 7: " find this script useful, or have suggestions for improvements, please[J

line 8: " let me know.[J

line 9: " Also look there for further comments and documentation.[J

line 10: "[J

line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.[J

line 12: " ---------------------------------------------------------------------[J

line 13: "  Load Once: {{{1[J

line 14: if &cp || exists("g:loaded_tarPlugin")[J

line 15:  finish[J

line 16: endif[J

line 17: let g:loaded_tarPlugin = "v32"[J

line 18: let s:keepcpo          = &cpo[J

line 19: set cpo&vim[J

line 20: [J

line 21: " ---------------------------------------------------------------------[J

line 22: "  Public Interface: {{{1[J

line 23: augroup tar[J

line 24:   au![J

line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)[J

line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)[J

line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))[J

line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))[J

line 29: [J

line 30:   if has("unix")[J

line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)[J

line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)[J

line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))[J

line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))[J

line 35:   endif[J

line 36: [J

line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))[J

line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))[J

line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))[J

line 42:   au BufReadCmd   *.tbz^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 43:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 44:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))[J

line 45:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))[J

line 46:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 47:   au BufReadCmd   *.tar.zst^I^Icall tar#Browse(expand("<amatch>"))[J

line 48:   au BufReadCmd   *.tzs^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 49: augroup END[J

line 50: com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)[J

line 51: [J

line 52: " ---------------------------------------------------------------------[J

line 53: " Restoration And Modelines: {{{1[J

line 54: " vim: fdm=marker[J

line 55: let &cpo= s:keepcpo[J

line 56: unlet s:keepcpo[J

finished sourcing /usr/local/share/vim/vim90/plugin/tarPlugin.vim[J
chdir(/usr/local/share/vim/vim90/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim90/plugin/tohtml.vim"[J
line 1: " Vim plugin for converting a syntax highlighted file to HTML.[J

line 2: " Maintainer: Ben Fritz <fritzophrenic@gmail.com>[J

line 3: " Last Change: 2019 Nov 13[J

line 4: "[J

line 5: " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and[J

line 6: " $VIMRUNTIME/syntax/2html.vim[J

line 7: "[J

line 8: if exists('g:loaded_2html_plugin')[J

line 9:   finish[J

line 10: endif[J

line 11: let g:loaded_2html_plugin = 'vim8.1_v2'[J

line 12: [J

line 13: "[J

line 14: " Changelog: {{{[J

line 15: "   8.1_v2  (this version): - Fix Bitbucket issue #19: fix calculation of tab[J

line 16: "                             stop position to use in expanding a tab, when that[J

line 17: "                             tab occurs after a syntax match which in turn[J

line 18: "                             comes after previously expanded tabs.[J

line 19: "                           - Set eventignore while splitting a window for the[J

line 20: "                             destination file to ignore FileType events;[J

line 21: "                             speeds up processing when the destination file[J

line 22: "                             already exists and HTML highlight takes too long.[J

line 23: "                           - Fix Bitbucket issue #20: progress bar could not be[J

line 24: "                             seen when DiffDelete background color matched[J

line 25: "                             StatusLine background color. Added TOhtmlProgress[J

line 26: "                             highlight group for manual user override, but[J

line 27: "                             calculate it to be visible compared to StatusLine[J

line 28: "                             by default.[J

line 29: "                           - Fix Bitbucket issue #1: Remove workaround for old[J

line 30: "                             browsers which don't support 'ch' CSS unit, since[J

line 31: "                             all modern browsers, including IE>=9, support it.[J

line 32: "                           - Fix Bitbucket issue #10: support termguicolors[J

line 33: "                           - Fix Bitbucket issue #21: default to using[J

line 34: "                             generated content instead of <input> tags for[J

line 35: "                             uncopyable text, so that text is correctly[J

line 36: "                             prevented from being copied in chrome. Use[J

line 37: "                             g:html_use_input_for_pc option to control the[J

line 38: "                             method used.[J

line 39: "                           - Switch to HTML5 to allow using vnu as a validator[J

line 40: "                             in unit test.[J

line 41: "                           - Fix fallback sizing of <input> tags for browsers[J

line 42: "                             without "ch" support.[J

line 43: "                           - Fix cursor on unselectable diff filler text.[J

line 44: "   8.1_v1  (Vim 8.1.0528): - Fix Bitbucket issue #6: Don't generate empty[J

line 45: "                             script tag.[J

line 46: "                           - Fix Bitbucket issue #5: javascript should[J

line 47: "                             declare variables with "var".[J

line 48: "                           - Fix Bitbucket issue #13: errors thrown sourcing[J

line 49: "                             2html.vim directly when plugins not loaded.[J

line 50: "                           - Fix Bitbucket issue #16: support 'vartabstop'.[J

line 51: "[J

line 52: "   7.4 updates: {{{[J

line 53: "   7.4_v2  (Vim 7.4.0899): Fix error raised when converting a diff containing[J

line 54: "                           an empty buffer. Jan Stocker: allow g:html_font to[J

line 55: "                           take a list so it is easier to specfiy fallback[J

line 56: "                           fonts in the generated CSS.[J

line 57: "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and[J

line 58: "^I^I^I    also for version-specific modelines like "vim>703:".[J

line 59: "}}}[J

line 60: "[J

line 61: "   7.3 updates: {{{[J

line 62: "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using[J

line 63: "^I^I^I    g:html_line_ids=0. Allow customizing[J

line 64: "^I^I^I    important IDs (like line IDs and fold IDs) using[J

line 65: "^I^I^I    g:html_id_expr evaluated when the buffer conversion[J

line 66: "^I^I^I    is started.[J

line 67: "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and[J

line 68: "^I^I^I    insert modeline to set it to manual.[J

line 69: "^I^I^I    Fix bug: diff mode with 2 unsaved buffers creates a[J

line 70: "^I^I^I    duplicate of one buffer instead of including both.[J

line 71: "^I^I^I    Add anchors to each line so you can put '#L123'[J

line 72: "^I^I^I    or '#123' at the end of the URL to jump to line 123[J

line 73: "^I^I^I    (idea by Andy Spencer). Add javascript to open folds[J

line 74: "^I^I^I    to show the anchor being jumped to if it is hidden.[J

line 75: "^I^I^I    Fix XML validation error: &nsbp; not part of XML.[J

line 76: "^I^I^I    Allow TOhtml to chain together with other commands[J

line 77: "^I^I^I    using |.[J

line 78: "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple[J

line 79: "^I^I^I    highlight groups make up the start-of-modeline text.[J

line 80: "^I^I^I    Improve render time of page with uncopyable regions[J

line 81: "^I^I^I    by not using one-input-per-char. Change name of[J

line 82: "^I^I^I    uncopyable option from html_unselectable to[J

line 83: "^I^I^I    html_prevent_copy. Added html_no_invalid option and[J

line 84: "^I^I^I    default to inserting invalid markup for uncopyable[J

line 85: "^I^I^I    regions to prevent MS Word from pasting undeletable[J

line 86: "^I^I^I    <input> elements. Fix 'cpo' handling (Thilo Six).[J

line 87: "^I^I 7.3_v12b1: Add html_unselectable option. Rework logic to[J

line 88: "^I^I^I    eliminate post-processing substitute commands in[J

line 89: "^I^I^I    favor of doing the work up front. Remove unnecessary[J

line 90: "^I^I^I    special treatment of 'LineNr' highlight group. Minor[J

line 91: "^I^I^I    speed improvements. Fix modeline mangling in[J

line 92: "^I^I^I    generated output so it works for text in the first[J

line 93: "^I^I^I    column. Fix missing line number and fold column in[J

line 94: "^I^I^I    diff filler lines. Fix that some fonts have a 1px[J

line 95: "^I^I^I    gap (using a dirty hack, improvements welcome). Add[J

line 96: "^I^I^I    "colorscheme" meta tag. Does NOT include support for[J

line 97: "^I^I^I    the new default foldtext added in v11, as the patch[J

line 98: "^I^I^I    adding it has not yet been included in Vim.[J

line 99: "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian[J

line 100: "^I^I^I    Brabandt in[J

line 101: "^I^I^I    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.[J

line 102: "^I^I^I    This patch has not yet been included in Vim, thus[J

line 103: "^I^I^I    these changes are removed in the next version.[J

line 104: "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside[J

line 105: "^I^I^I    multiple nested folds with dynamic folding on.[J

line 106: "^I^I^I    Also fix problem with foldtext in this situation.[J

line 107: "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css[J

line 108: "^I^I^I    and without html_no_pre, default value same as[J

line 109: "^I^I^I    'wrap' option, (Andy Spencer). Don't use[J

line 110: "^I^I^I    'fileencoding' for converted document encoding if[J

line 111: "^I^I^I    'buftype' indicates a special buffer which isn't[J

line 112: "^I^I^I    written.[J

line 113: "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab[J

line 114: "^I^I^I    characters in generated output (Andy Spencer).[J

line 115: "^I^I^I    Escape text that looks like a modeline so Vim[J

line 116: "^I^I^I    doesn't use anything in the converted HTML as a[J

line 117: "^I^I^I    modeline. Bugfixes: Fix folding when a fold starts[J

line 118: "^I^I^I    before the conversion range. Remove fold column when[J

line 119: "^I^I^I    there are no folds.[J

line 120: "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:[J

line 121: "^I^I  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.[J

line 122: "^I^I  7.3_v7b2: Remove automatic detection of encodings that are not[J

line 123: "^I^I^I    supported by all major browsers according to[J

line 124: "^I^I^I    http://wiki.whatwg.org/wiki/Web_Encodings and[J

line 125: "^I^I^I    convert to UTF-8 for all Unicode encodings. Make[J

line 126: "^I^I^I    HTML encoding to Vim encoding detection be[J

line 127: "^I^I^I    case-insensitive for built-in pairs.[J

line 128: "^I^I  7.3_v7b1: Remove use of setwinvar() function which cannot be[J

line 129: "^I^I^I    called in restricted mode (Andy Spencer). Use[J

line 130: "^I^I^I    'fencoding' instead of 'encoding' to determine by[J

line 131: "^I^I^I    charset, and make sure the 'fenc' of the generated[J

line 132: "^I^I^I    file matches its indicated charset. Add charsets for[J

line 133: "^I^I^I    all of Vim's natively supported encodings.[J

line 134: "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other[J

line 135: "^I^I^I    user settings interfering with diff mode generation,[J

line 136: "^I^I^I    trailing whitespace (e.g. line number column) when[J

line 137: "^I^I^I    using html_no_pre, and bugs when using[J

line 138: "^I^I^I    html_hover_unfold.[J

line 139: "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync[J

line 140: "^I^I^I    folds in diff mode when first line was folded.[J

line 141: "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode[J

line 142: "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css[J

line 143: "^I^I^I    default to true when not set to anything. Use strict[J

line 144: "^I^I^I    doctypes where possible. Rename use_xhtml option to[J

line 145: "^I^I^I    html_use_xhtml for consistency. Use .xhtml extension[J

line 146: "^I^I^I    when using this option. Add meta tag for settings.[J

line 147: "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the[J

line 148: "^I^I^I    diff colors and the normal syntax colors[J

line 149: "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output[J

line 150: "}}}[J

line 151: "}}}[J

line 152: [J

line 153: " TODO: {{{[J

line 154: "   * Check the issue tracker:[J

line 155: "     https://bitbucket.org/fritzophrenic/vim-tohtml/issues?status=new&status=open[J

line 156: "   * Options for generating the CSS in external style sheets. New :TOcss[J

line 157: "     command to convert the current color scheme into a (mostly) generic CSS[J

line 158: "     stylesheet which can be re-used. Alternate stylesheet support? Good start[J

line 159: "     by Erik Falor[J

line 160: "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).[J

line 161: "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,[J

line 162: "     term) to use for the styling. Suggestion by "nacitar".[J

line 163: "   * Add way to override or specify which RGB colors map to the color numbers[J

line 164: "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".[J

line 165: "   * Disable filetype detection until after all processing is done.[J

line 166: "   * Add option for not generating the hyperlink on stuff that looks like a[J

line 167: "     URL? Or just color the link to fit with the colorscheme (and only special[J

line 168: "     when hovering)?[J

line 169: "   * Bug: Opera does not allow printing more than one page if uncopyable[J

line 170: "     regions is turned on. Possible solution: Add normal text line numbers with[J

line 171: "     display:none, set to display:inline for print style sheets, and hide[J

line 172: "     <input> elements for print, to allow Opera printing multiple pages (and[J

line 173: "     other uncopyable areas?). May need to make the new text invisible to IE[J

line 174: "     with conditional comments to prevent copying it, IE for some reason likes[J

line 175: "     to copy hidden text. Other browsers too?[J

line 176: "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is[J

line 177: "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome[J

line 178: "     on Windows). Perhaps it is font related?[J

line 179: "   * Bug: still some gaps in the fold column when html_prevent_copy contains[J

line 180: "     'd' and showing the whole diff (observed in multiple browsers). Only gaps[J

line 181: "     on diff lines though.[J

line 182: "   * Undercurl support via CSS3, with fallback to dotted or something:[J

line 183: "^Ihttps://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion[J

line 184: "   * Redo updates for modified default foldtext (v11) when/if the patch is[J

line 185: "     accepted to modify it.[J

line 186: "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold[J

line 187: "^I^I+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress[J

line 188: "^I^I+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml[J

line 189: "     does not show the whole diff filler as it is supposed to?[J

line 190: "   * Bug: when 'isprint' is wrong for the current encoding, will generate[J

line 191: "     invalid content. Can/should anything be done about this? Maybe a separate[J

line 192: "     plugin to correct 'isprint' based on encoding?[J

line 193: "   * Check to see if the windows-125\d encodings actually work in Unix without[J

line 194: "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.[J

line 195: "   * Font auto-detection similar to[J

line 196: "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of[J

line 197: "     platforms.[J

line 198: "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :[J

line 199: "^I- listchars support[J

line 200: "^I- full-line background highlight[J

line 201: "^I- other?[J

line 202: "   * Make it so deleted lines in a diff don't create side-scrolling (get it[J

line 203: "     free with full-line background highlight above).[J

line 204: "   * Restore open/closed folds and cursor position after processing each file[J

line 205: "     with option not to restore for speed increase.[J

line 206: "   * Add extra meta info (generation time, etc.)?[J

line 207: "   * Tidy up so we can use strict doctype in even more situations[J

line 208: "   * Implementation detail: add threshold for writing the lines to the html[J

line 209: "     buffer before we're done (5000 or so lines should do it)[J

line 210: "   * TODO comments for code cleanup scattered throughout[J

line 211: "}}}[J

line 212: [J

line 213: " Define the :TOhtml command when:[J

line 214: " - 'compatible' is not set[J

line 215: " - this plugin or user override was not already loaded[J

line 216: " - user commands are available. {{{[J

line 217: if !&cp && !exists(":TOhtml") && has("user_commands")[J

line 218:   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)[J

line 219: endif "}}}[J

line 220: [J

line 221: " Make sure any patches will probably use consistent indent[J

line 222: "   vim: ts=8 sw=2 sts=2 noet fdm=marker[J

finished sourcing /usr/local/share/vim/vim90/plugin/tohtml.vim[J
chdir(/usr/local/share/vim/vim90/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim90/plugin/vimballPlugin.vim"[J
line 1: " vimballPlugin : construct a file containing both paths and files[J

line 2: " Author: Charles E. Campbell[J

line 3: " Copyright: (c) 2004-2014 by Charles E. Campbell[J

line 4: "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt[J

line 5: "            (see |copyright|) except use "Vimball" instead of "Vim".[J

line 6: "            No warranty, express or implied.[J

line 7: "  *** ***   Use At-Your-Own-Risk!   *** ***[J

line 8: "[J

line 9: " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who[J

line 10: "      judge. For in that which you judge another, you condemn yourself. For[J

line 11: "      you who judge practice the same things.[J

line 12: " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim[J

line 13: [J

line 14: " ---------------------------------------------------------------------[J

line 15: "  Load Once: {{{1[J

line 16: if &cp || exists("g:loaded_vimballPlugin")[J

line 17:  finish[J

line 18: endif[J

line 19: let g:loaded_vimballPlugin = "v37"[J

line 20: let s:keepcpo              = &cpo[J

line 21: set cpo&vim[J

line 22: [J

line 23: " ------------------------------------------------------------------------------[J

line 24: " Public Interface: {{{1[J

line 25: com! -range   -complete=file -nargs=+ -bang MkVimball^I^Icall vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)[J

line 26: com! -nargs=? -complete=dir  UseVimball^I^I^I^I^I^Icall vimball#Vimball(1,<f-args>)[J

line 27: com! -nargs=0                VimballList^I^I^I^I^Icall vimball#Vimball(0)[J

line 28: com! -nargs=* -complete=dir  RmVimball^I^I^I^I^I^Icall vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()[J

line 29: augroup Vimball[J

line 30:  au![J

line 31:  au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif[J

line 32:  au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif[J

line 33:  au SourceCmd *.vba^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif[J

line 34:  au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif[J

line 35:  au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif[J

line 36:  au SourceCmd *.vmb^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif[J

line 37: augroup END[J

line 38: [J

line 39: " =====================================================================[J

line 40: " Restoration And Modelines: {{{1[J

line 41: " vim: fdm=marker[J

line 42: let &cpo= s:keepcpo[J

line 43: unlet s:keepcpo[J

finished sourcing /usr/local/share/vim/vim90/plugin/vimballPlugin.vim[J
chdir(/usr/local/share/vim/vim90/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim90/plugin/zipPlugin.vim"[J
line 1: " zipPlugin.vim: Handles browsing zipfiles[J

line 2: "            PLUGIN PORTION[J

line 3: " Date:^I^I^IJan 07, 2020[J

line 4: " Maintainer:^ICharles E Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>[J

line 5: " License:^I^IVim License  (see vim's :help license)[J

line 6: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1[J

line 7: "               Permission is hereby granted to use and distribute this code,[J

line 8: "               with or without modifications, provided that this copyright[J

line 9: "               notice is copied with it. Like anything else that's free,[J

line 10: "               zipPlugin.vim is provided *as is* and comes with no warranty[J

line 11: "               of any kind, either expressed or implied. By using this[J

line 12: "               plugin, you agree that in no event will the copyright[J

line 13: "               holder be liable for any damages resulting from the use[J

line 14: "               of this software.[J

line 15: "[J

line 16: " (James 4:8 WEB) Draw near to God, and he will draw near to you.[J

line 17: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.[J

line 18: " ---------------------------------------------------------------------[J

line 19: " Load Once: {{{1[J

line 20: if &cp || exists("g:loaded_zipPlugin")[J

line 21:  finish[J

line 22: endif[J

line 23: let g:loaded_zipPlugin = "v32"[J

line 24: let s:keepcpo          = &cpo[J

line 25: set cpo&vim[J

line 26: [J

line 27: " ---------------------------------------------------------------------[J

line 28: " Options: {{{1[J

line 29: if !exists("g:zipPlugin_ext")[J

line 30:  let g:zipPlugin_ext='*.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'[J

line 31: endif[J

line 32: [J

line 33: " ---------------------------------------------------------------------[J

line 34: " Public Interface: {{{1[J

line 35: augroup zip[J

line 36:  au![J

line 37:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)[J

line 38:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)[J

line 39:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))[J

line 40:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))[J

line 41: [J

line 42:  if has("unix")[J

line 43:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)[J

line 44:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)[J

line 45:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))[J

line 46:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))[J

line 47:  endif[J

line 48: [J

line 49:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'[J

line 49: au BufReadCmd *.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))[J

line 50: augroup END[J

line 51: [J

line 52: " ---------------------------------------------------------------------[J

line 53: "  Restoration And Modelines: {{{1[J

line 54: "  vim: fdm=marker[J

line 55: let &cpo= s:keepcpo[J

line 56: unlet s:keepcpo[J

finished sourcing /usr/local/share/vim/vim90/plugin/zipPlugin.vim[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/plugin/**/*.vim"[J
Searching for "pack/*/start/*" in "/Users/tsen/.vim,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after"[J
Searching for "/Users/tsen/.vim/pack/*/start/*"[J
Searching for "/usr/local/share/vim/vimfiles/pack/*/start/*"[J
Searching for "/usr/local/share/vim/vim90/pack/*/start/*"[J
Searching for "/usr/local/share/vim/vimfiles/after/pack/*/start/*"[J
Searching for "/Users/tsen/.vim/after/pack/*/start/*"[J
not found in 'packpath': "pack/*/start/*"[J
Searching for "plugin/**/*.vim" in "/Users/tsen/.vim,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/nerdtree,/Users/tsen/.vim/bundle/vim-nerdtree-tabs,/Users/tsen/.vim/bundle/vim-autoformat,/Users/tsen/.vim/bundle/closetag.vim,/Users/tsen/.vim/bundle/tagbar,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim90,/usr/local/share/vim/vimfiles/after,/Users/tsen/.vim/after,/Users/tsen/.vim/bundle/Vundle.vim,/Users/tsen/.vim/bundle/Vundle.vim/after,/Users/tsen/.vim/bundle/nerdtree/after,/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after,/Users/tsen/.vim/bundle/vim-autoformat/after,/Users/tsen/.vim/bundle/closetag.vim/after,/Users/tsen/.vim/bundle/tagbar/after"[J
Searching for "/usr/local/share/vim/vimfiles/after/plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/after/plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/Vundle.vim/after/plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/nerdtree/after/plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-nerdtree-tabs/after/plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/vim-autoformat/after/plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/closetag.vim/after/plugin/**/*.vim"[J
Searching for "/Users/tsen/.vim/bundle/tagbar/after/plugin/**/*.vim"[J
not found in 'runtimepath': "plugin/**/*.vim"[J
Reading viminfo file "/Users/tsen/.viminfo" info oldfiles[J
Press ENTER or type command to continue[?25h[?1049h[22;0;0t[>4;2m[?1h=[?2004h[?1004h[1;42r[?12h[?12l[22;2t[22;1t[27m[23m[29m[m[38;5;145m[48;5;16m[H[2J[?25l[42;1HExecuting BufWinEnter Autocommands for "*"
autocommand call <SID>BufWinEnterHandler()
Executing: call <SID>BufWinEnterHandler()
calling <SNR>38_BufWinEnterHandler()
line 1:   if s:NewTabCreated
line 2:     " Turn off the 'NewTabCreated' flag
line 3:     let s:NewTabCreated = 0
line 4:
line 5:     " Restore focus to NERDTree if necessary
line 6:     if !g:nerdtree_tabs_focus_on_files
line 7:[7Ccall s:NERDTreeRestoreFocus()
line 8:     endif
line 9:   endif
<SNR>38_BufWinEnterHandler returning #0
continuing in BufWinEnter Autocommands for "*"
Executing BufWinEnter Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()
Executing: call s:Highlight_Matching_Pair()
calling <SNR>48_Highlight_Matching_Pair()
line 1:   " Remove any previous match.
line 2:   call s:Remove_Matches()
calling <SNR>48_Remove_Matches()
line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     silent! call matchdelete(3)
line 3:     let w:paren_hl_on = 0
line 4:   endif
<SNR>48_Remove_Matches returning #0
continuing in <SNR>48_Highlight_Matching_Pair
line 3:
line 4:   " Avoid that we remove the popup menu.
line 5:   " Return when there are no colors (looks like the cursor jumps).
line 6:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 7:     return
line 8:   endif
line 9:
line 10:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 11:   let c_lnum = line('.')
line 12:   let c_col = col('.')
line 13:   let before = 0
line 14:
line 15:   let text = getline(c_lnum)
[38;5;121m-- More --[?25h[m[38;5;145m[48;5;16m[42;1H[K[?25l[42;1Hline 16:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
[38;5;121m-- More --[?25h[m[38;5;145m[48;5;16m[42;1H[K[?25l[42;1Hline 17:   if empty(matches)
[38;5;121m-- More --[?25h[m[38;5;145m[48;5;16m[42;1H[K[?25l[42;1Hline 18:     let [c_before, c] = ['', '']
[38;5;121m-- More --[?25h[m[38;5;145m[48;5;16m[42;1H[K[?25l[42;1Hline 19:   else
[38;5;121m-- More --[?25h[m[38;5;145m[48;5;16m[42;1H[K[?25l[42;1Hline 20:     let [c_before, c] = matches[1:2]
[38;5;121m-- More --[?25h[m[38;5;145m[48;5;16m[42;1H[K[?25l[42;1Hline 21:   endif
[38;5;121m-- More --[?25h[m[38;5;145m[48;5;16m[42;1H[K[?25l[42;1Hline 22:   let plist = split(&matchpairs, '.\zs[:,]')
[38;5;121m-- More --[?25h[m[38;5;145m[48;5;16m[42;1H[K[?25l[42;1Hline 23:   let i = index(plist, c)
[38;5;121m-- More --[?25h[m[38;5;145m[48;5;16m[42;1H[K[?25l[42;1Hline 24:   if i < 0
[38;5;121m-- More --[?25h[m[38;5;145m[48;5;16m[42;1H[K[?25l[42;1Hline 25:     " not found, in Insert mode try character before the cursor
[38;5;121m-- More --[?25h[m[38;5;145m[48;5;16m[42;1H[K[?25l[42;1Hline 26:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
[38;5;121m-- More --[?25h[m[38;5;145m[48;5;16m[42;1H[K[?25l[42;1Hline 27:[7Clet before = strlen(c_before)
[38;5;121m-- More --[?25h[m[38;5;145m[48;5;16m[42;1H[K[?25l[42;1Hline 28:[7Clet c = c_before
[38;5;121m-- More --[?25h[m[38;5;145m[48;5;16m[42;1H[K[?25l[42;1Hline 29:[7Clet i = index(plist, c)
[38;5;121m-- More --[?25h[m[38;5;145m[48;5;16m[42;1H[K[?25l[42;1Hline 30:     endif
[38;5;121m-- More --[?25h[m[38;5;145m[48;5;16m[42;1H[K[?25l[42;1Hline 31:     if i < 0
line 32:[7C" not found, nothing to do
line 33:[7Creturn
<SNR>48_Highlight_Matching_Pair returning #0
continuing in BufWinEnter Autocommands for "*"
Executing BufEnter Autocommands for "*"
autocommand call nerdtree#checkForBrowse(expand('<amatch>'))
Executing: call nerdtree#checkForBrowse(expand('<amatch>'))
calling nerdtree#checkForBrowse('')
line 1:     if !isdirectory(a:dir)
line 2:[9Creturn
nerdtree#checkForBrowse returning #0
continuing in BufEnter Autocommands for "*"
Executing BufEnter Autocommands for "*"
autocommand sil call s:LocalBrowse(expand("<amatch>"))
Executing: sil call s:LocalBrowse(expand("<amatch>"))
Executing VimEnter Autocommands for "*"
[38;5;121mPress ENTER or type command to continue[?25h[m[38;5;145m[48;5;16m
[?25lautocommand silent! autocmd! FileExplorer
[38;5;121mPress ENTER or type command to continue[?25h[m[38;5;145m[48;5;16m
[?25lExecuting: silent! autocmd! FileExplorer
autocommand call nerdtree#checkForBrowse(expand('<amatch>'))
[38;5;121mPress ENTER or type command to continue[m[38;5;145m[48;5;16m
Executing: call nerdtree#checkForBrowse(expand('<amatch>'))
calling nerdtree#checkForBrowse('')
line 1:     if !isdirectory(a:dir)
line 2:[9Creturn
nerdtree#checkForBrowse returning #0
continuing in VimEnter Autocommands for "*"
Executing VimEnter Autocommands for "*"
[38;5;121mPress ENTER or type command to continue[m[38;5;145m[48;5;16m
autocommand call <SID>VimEnterHandler()
[38;5;121mPress ENTER or type command to continue[m[38;5;145m[48;5;16m
Executing: call <SID>VimEnterHandler()
calling <SNR>38_VimEnterHandler()
line 1:   let l:open_nerd_tree_on_startup = (g:nerdtree_tabs_open_on_console_startup == 1 && !has('gui_running')) || (g:nerdtree_tabs_open_on_
[41;143Hg[42;1Hui_startup == 1 && has('gui_running'))
line 3:
line 4:   let l:open_directory_on_startup = isdirectory(argv(0)) && ((g:nerdtree_tabs_open_on_console_startup == 2 && !has('gui_running')) ||
[41;143H([42;1Hg:nerdtree_tabs_open_on_gui_startup == 2 && has('gui_running')))
line 7:
line 8:   if g:nerdtree_tabs_no_startup_for_diff && &diff
line 9:[7Clet l:open_nerd_tree_on_startup = 0
line 10:   endif
line 11:
line 12:   " this makes sure that globally_active is true when using 'gvim .'
line 13:   let s:nerdtree_globally_active = l:open_nerd_tree_on_startup
line 14:
line 15:   " if the argument to vim is a directory, cd into it
line 16:   if l:open_directory_on_startup || g:nerdtree_tabs_startup_cd && isdirectory(argv(0))
line 17:     exe 'cd ' . escape(argv(0), '\ ')
line 18:   endif
line 19:
line 20:
line 21:   if l:open_nerd_tree_on_startup || l:open_directory_on_startup
line 22:     let l:focus_file = !s:IfFocusOnStartup()
line 23:     let l:main_bufnr = bufnr('%')
line 24:
line 25:     if !s:IsNERDTreePresentInCurrentTab()
line 26:[7Ccall s:NERDTreeOpenAllTabs()
line 27:     endif
line 28:
line 29:     if (l:focus_file && g:nerdtree_tabs_smart_startup_focus == 1) || g:nerdtree_tabs_smart_startup_focus == 2 || l:open_directory_on_
[41;143Hs[42;1Htartup
line 32:[7Cexe bufwinnr(l:main_bufnr) . "wincmd w"
line 33:     endif
line 34:
line 35:     if l:open_directory_on_startup
line 36:[7C" close buffer not connected to NERDTree and open connected one
line 37:[7Cnew
line 38:[7Cexe bufwinnr(l:main_bufnr) . "wincmd w"
line 39:[7Cquit
line 40:
line 41:[7Cif g:nerdtree_tabs_smart_startup_focus != 2
[38;5;121m-- More --[?25h[m[38;5;145m[48;5;16m[42;1H[K[42;1H
[?25l<SNR>38_VimEnterHandler aborted
continuing in VimEnter Autocommands for "*"
:G[?25h[?25l[42;2H[K[42;2H[?25hq[?25lExecuting: q
Writing viminfo file "/Users/tsen/.viminfo"[?2004l[>4;m[23;2t[23;1t[39;49m[?1004l[?2004l[?1l>[?25h[>4;m[?1049l[23;0;0t
